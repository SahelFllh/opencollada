/*
    Copyright (c) 2008 NetAllied Systems GmbH

    This file is part of MayaDataModel.

    Licensed under the MIT Open Source License,
    for details please see LICENSE file or the website
    http://www.opensource.org/licenses/mit-license.php
*/
#ifndef __MayaDM_TEXTUREBAKESET_H__
#define __MayaDM_TEXTUREBAKESET_H__
#include "MayaDMTypes.h"
#include "MayaDMConnectables.h"
#include "MayaDMBakeSet.h"
namespace MayaDM
{
/*
A textureBakeSet allows the user to collect together objects which are
  to be baked in the same way, for instance with the same UV range, or
  output resolution.  When Convert To File Texture is used, for each
  object being baked the textureBakeSet to which that object belongs
  specifies the parameters for the baking process.
  <p/>
*/
class TextureBakeSet : public BakeSet
{
public:
public:
	TextureBakeSet(FILE* file,const std::string& name,const std::string& parent=""):BakeSet(file, name, parent, "textureBakeSet"){}
	virtual ~TextureBakeSet(){}
	/*
	You can write one lightmap texture per shadingGroup on each shape,
	or one lightmap per shape, regarless of shadingGroup assignments,
	or one lightmap for this entire bakeSet, containing a patchwork
	of all member shapes (this third option only works if the shapes
	in this bakeSet have non-overlapping UV spaces).
	*/
	void setSeparation(unsigned int sep){if(sep == 0) return; fprintf_s(mFile, "setAttr \".sep\" %i;\n", sep);}
	/*
	You can write one lightmap texture per shadingGroup on each shape,
	or one lightmap per shape, regarless of shadingGroup assignments,
	or one lightmap for this entire bakeSet, containing a patchwork
	of all member shapes (this third option only works if the shapes
	in this bakeSet have non-overlapping UV spaces).
	*/
	void setSeparation(const UnsignedintID& sep){fprintf_s(mFile,"connectAttr \"");sep.write(mFile);fprintf_s(mFile,"\" \"%s.sep\";\n",mName.c_str());}
	/*
	The bitmaps generated by this baking will have
	names beginning with this prefix.
	*/
	void setPrefix(const StringID& pre){fprintf_s(mFile,"connectAttr \"");pre.write(mFile);fprintf_s(mFile,"\" \"%s.pre\";\n",mName.c_str());}
	/*The file texture's horizontal resolution.*/
	void setXResolution(int xres){if(xres == 512) return; fprintf_s(mFile, "setAttr \".xres\" %i;\n", xres);}
	/*The file texture's horizontal resolution.*/
	void setXResolution(const IntID& xres){fprintf_s(mFile,"connectAttr \"");xres.write(mFile);fprintf_s(mFile,"\" \"%s.xres\";\n",mName.c_str());}
	/*The file texture's vertical resolution.*/
	void setYResolution(int yres){if(yres == 512) return; fprintf_s(mFile, "setAttr \".yres\" %i;\n", yres);}
	/*The file texture's vertical resolution.*/
	void setYResolution(const IntID& yres){fprintf_s(mFile,"connectAttr \"");yres.write(mFile);fprintf_s(mFile,"\" \"%s.yres\";\n",mName.c_str());}
	/*Set the output bitmap file format to use.*/
	void setFileFormat(unsigned int format){if(format == 0) return; fprintf_s(mFile, "setAttr \".format\" %i;\n", format);}
	/*Set the output bitmap file format to use.*/
	void setFileFormat(const UnsignedintID& format){fprintf_s(mFile,"connectAttr \"");format.write(mFile);fprintf_s(mFile,"\" \"%s.format\";\n",mName.c_str());}
	/*Specifies the number of bits per channel to use in the output bitmap.*/
	void setBitsPerChannel(unsigned int bits){if(bits == 0) return; fprintf_s(mFile, "setAttr \".bits\" %i;\n", bits);}
	/*Specifies the number of bits per channel to use in the output bitmap.*/
	void setBitsPerChannel(const UnsignedintID& bits){fprintf_s(mFile,"connectAttr \"");bits.write(mFile);fprintf_s(mFile,"\" \"%s.bits\";\n",mName.c_str());}
	/*
	Activate this option if you wish any meshes being baked to
	be baked as if they were in a given UV set, instead of the
	UV sets which they are currently associated with.
	*/
	void setOverrideUvSet(bool overrideuv){if(overrideuv == 0) return; fprintf_s(mFile, "setAttr \".overrideuv\" %i;\n", overrideuv);}
	/*
	Activate this option if you wish any meshes being baked to
	be baked as if they were in a given UV set, instead of the
	UV sets which they are currently associated with.
	*/
	void setOverrideUvSet(const BoolID& overrideuv){fprintf_s(mFile,"connectAttr \"");overrideuv.write(mFile);fprintf_s(mFile,"\" \"%s.overrideuv\";\n",mName.c_str());}
	/*Which UV set to use for the meshes in this textureBakeSet.*/
	void setUvSetName(const string& set){if(set == "uvSet1") return; fprintf_s(mFile, "setAttr \".set\" -type \"string\" ");set.write(mFile);fprintf_s(mFile,";\n");}
	/*Which UV set to use for the meshes in this textureBakeSet.*/
	void setUvSetName(const StringID& set){fprintf_s(mFile,"connectAttr \"");set.write(mFile);fprintf_s(mFile,"\" \"%s.set\";\n",mName.c_str());}
	/*
	Specifies whether to bake a rectangle in UV space from 0,0 to 1,1,
	the entire UV space, or a manually specified range, below.
	*/
	void setUvRange(unsigned int range){if(range == 0) return; fprintf_s(mFile, "setAttr \".range\" %i;\n", range);}
	/*
	Specifies whether to bake a rectangle in UV space from 0,0 to 1,1,
	the entire UV space, or a manually specified range, below.
	*/
	void setUvRange(const UnsignedintID& range){fprintf_s(mFile,"connectAttr \"");range.write(mFile);fprintf_s(mFile,"\" \"%s.range\";\n",mName.c_str());}
	/*Minimum U for baking.*/
	void setUMin(float ul){if(ul == 1.0) return; fprintf_s(mFile, "setAttr \".ul\" %f;\n", ul);}
	/*Minimum U for baking.*/
	void setUMin(const FloatID& ul){fprintf_s(mFile,"connectAttr \"");ul.write(mFile);fprintf_s(mFile,"\" \"%s.ul\";\n",mName.c_str());}
	/*Maximum U for baking.*/
	void setUMax(float uh){if(uh == 1.0) return; fprintf_s(mFile, "setAttr \".uh\" %f;\n", uh);}
	/*Maximum U for baking.*/
	void setUMax(const FloatID& uh){fprintf_s(mFile,"connectAttr \"");uh.write(mFile);fprintf_s(mFile,"\" \"%s.uh\";\n",mName.c_str());}
	/*Minimum V for baking.*/
	void setVMin(float vl){if(vl == 1.0) return; fprintf_s(mFile, "setAttr \".vl\" %f;\n", vl);}
	/*Minimum V for baking.*/
	void setVMin(const FloatID& vl){fprintf_s(mFile,"connectAttr \"");vl.write(mFile);fprintf_s(mFile,"\" \"%s.vl\";\n",mName.c_str());}
	/*Maximum V for baking.*/
	void setVMax(float vh){if(vh == 1.0) return; fprintf_s(mFile, "setAttr \".vh\" %f;\n", vh);}
	/*Maximum V for baking.*/
	void setVMax(const FloatID& vh){fprintf_s(mFile,"connectAttr \"");vh.write(mFile);fprintf_s(mFile,"\" \"%s.vh\";\n",mName.c_str());}
	/*Specifies how to fill the background of the light map texture*/
	void setBackgroundMode(unsigned int bmode){if(bmode == 0) return; fprintf_s(mFile, "setAttr \".bmode\" %i;\n", bmode);}
	/*Specifies how to fill the background of the light map texture*/
	void setBackgroundMode(const UnsignedintID& bmode){fprintf_s(mFile,"connectAttr \"");bmode.write(mFile);fprintf_s(mFile,"\" \"%s.bmode\";\n",mName.c_str());}
	/*
	<b>Background Color</b> is the color used if the user sets
	the background mode to custom color.
	*/
	void setBackgroundColor(const float3& bgc){if(bgc == float3(0.0, 0.0, 0.0)) return; fprintf_s(mFile, "setAttr \".bgc\" -type \"float3\" ");bgc.write(mFile);fprintf_s(mFile,";\n");}
	/*
	<b>Background Color</b> is the color used if the user sets
	the background mode to custom color.
	*/
	void setBackgroundColor(const Float3ID& bgc){fprintf_s(mFile,"connectAttr \"");bgc.write(mFile);fprintf_s(mFile,"\" \"%s.bgc\";\n",mName.c_str());}
	/*Red component of Background Color*/
	void setBackgroundColorR(float bgr){if(bgr == 0.0) return; fprintf_s(mFile, "setAttr \".bgc.bgr\" %f;\n", bgr);}
	/*Red component of Background Color*/
	void setBackgroundColorR(const FloatID& bgr){fprintf_s(mFile,"connectAttr \"");bgr.write(mFile);fprintf_s(mFile,"\" \"%s.bgc.bgr\";\n",mName.c_str());}
	/*Green component of Background Color*/
	void setBackgroundColorG(float bgg){if(bgg == 0.0) return; fprintf_s(mFile, "setAttr \".bgc.bgg\" %f;\n", bgg);}
	/*Green component of Background Color*/
	void setBackgroundColorG(const FloatID& bgg){fprintf_s(mFile,"connectAttr \"");bgg.write(mFile);fprintf_s(mFile,"\" \"%s.bgc.bgg\";\n",mName.c_str());}
	/*Blue component of Background Color*/
	void setBackgroundColorB(float bgb){if(bgb == 0.0) return; fprintf_s(mFile, "setAttr \".bgc.bgb\" %f;\n", bgb);}
	/*Blue component of Background Color*/
	void setBackgroundColorB(const FloatID& bgb){fprintf_s(mFile,"connectAttr \"");bgb.write(mFile);fprintf_s(mFile,"\" \"%s.bgc.bgb\";\n",mName.c_str());}
	/*
	If the selected UV space contains boundaries, these boundaries may
	become visible as black stripes in renderings which use the baked
	textures.  This occurs when the texture is sampled close enough to
	a boundary that the filter picks up values (generally black) from
	outside the desired space.  fillTextureSeams artificially extends
	the boundaries by a small amount to alleviate this problem.
	fillTextureSeams is measured in texels (pixels of texture).
	Typically, the filter will only be a few texels in diameter, and
	can only reach as far as its radius into these boundary spaces,
	so a value of 1 or 2 is usually enough.
	*/
	void setFillTextureSeams(float fillseams){if(fillseams == 1.0) return; fprintf_s(mFile, "setAttr \".fillseams\" %f;\n", fillseams);}
	/*
	If the selected UV space contains boundaries, these boundaries may
	become visible as black stripes in renderings which use the baked
	textures.  This occurs when the texture is sampled close enough to
	a boundary that the filter picks up values (generally black) from
	outside the desired space.  fillTextureSeams artificially extends
	the boundaries by a small amount to alleviate this problem.
	fillTextureSeams is measured in texels (pixels of texture).
	Typically, the filter will only be a few texels in diameter, and
	can only reach as far as its radius into these boundary spaces,
	so a value of 1 or 2 is usually enough.
	*/
	void setFillTextureSeams(const FloatID& fillseams){fprintf_s(mFile,"connectAttr \"");fillseams.write(mFile);fprintf_s(mFile,"\" \"%s.fillseams\";\n",mName.c_str());}
	/*OBSOLETE*/
	void setFillScale(const FloatID& fillscale){fprintf_s(mFile,"connectAttr \"");fillscale.write(mFile);fprintf_s(mFile,"\" \"%s.fillscale\";\n",mName.c_str());}
	/*
	mental ray carries out a final gather pass before actually rendering the scene.
	This pass computes a sufficiently dense final gather map to ensure image quality.
	But the precomputation pass is disabled by default for baking
	because it is depending on the view,
	guaranteeing quality only for surfaces visible to the camera.
	When this value is set to non zero,
	mental ray computes a number of final gather points before baking takes place.
	If set to one, baking should yield roughly the same quality as would rendering from the camera.
	Values beyond one increase quality by precomputing a denser map of final gather points.
	Do not just use finalGatherQuality to tune final gather quality for baking.
	It is still necessary to adjust final gather accuracy and maximum radius in the Render Settings.
	*/
	void setFinalGatherQuality(float fgq){if(fgq == 1) return; fprintf_s(mFile, "setAttr \".fgq\" %f;\n", fgq);}
	/*
	mental ray carries out a final gather pass before actually rendering the scene.
	This pass computes a sufficiently dense final gather map to ensure image quality.
	But the precomputation pass is disabled by default for baking
	because it is depending on the view,
	guaranteeing quality only for surfaces visible to the camera.
	When this value is set to non zero,
	mental ray computes a number of final gather points before baking takes place.
	If set to one, baking should yield roughly the same quality as would rendering from the camera.
	Values beyond one increase quality by precomputing a denser map of final gather points.
	Do not just use finalGatherQuality to tune final gather quality for baking.
	It is still necessary to adjust final gather accuracy and maximum radius in the Render Settings.
	*/
	void setFinalGatherQuality(const FloatID& fgq){fprintf_s(mFile,"connectAttr \"");fgq.write(mFile);fprintf_s(mFile,"\" \"%s.fgq\";\n",mName.c_str());}
	/*
	This parameter determines the reflectivity of an object
	when precomputing final gather points for lightmapping.
	A certain fraction of all final gather points (as given by finalGatherQuality)
	is not prebaked on the object which is being baked,
	but on objects hit by reflection rays cast from this bake object.
	For example, if finalGatherReflect is set to 0.25,
	every 4th final gather point will be precomputed on the object
	hit by the reflection ray.
	*/
	void setFinalGatherReflect(float fgr){if(fgr == 0) return; fprintf_s(mFile, "setAttr \".fgr\" %f;\n", fgr);}
	/*
	This parameter determines the reflectivity of an object
	when precomputing final gather points for lightmapping.
	A certain fraction of all final gather points (as given by finalGatherQuality)
	is not prebaked on the object which is being baked,
	but on objects hit by reflection rays cast from this bake object.
	For example, if finalGatherReflect is set to 0.25,
	every 4th final gather point will be precomputed on the object
	hit by the reflection ray.
	*/
	void setFinalGatherReflect(const FloatID& fgr){fprintf_s(mFile,"connectAttr \"");fgr.write(mFile);fprintf_s(mFile,"\" \"%s.fgr\";\n",mName.c_str());}
	/*
	If this option is on, objects that belong to this bakeset
	is baked to a single texture file.
	Example of such a case is an object with multiple shaders.
	Without this option, each component of the object will be baked to separate textures.
	With <b>bakeToOneMap</b> on, a single texture will be generated for the object.
	Make sure that UV of the objects in the bakeset are not overlapped.
	*/
	void setBakeToOneMap(bool one){if(one == 0) return; fprintf_s(mFile, "setAttr \".one\" %i;\n", one);}
	/*
	If this option is on, objects that belong to this bakeset
	is baked to a single texture file.
	Example of such a case is an object with multiple shaders.
	Without this option, each component of the object will be baked to separate textures.
	With <b>bakeToOneMap</b> on, a single texture will be generated for the object.
	Make sure that UV of the objects in the bakeset are not overlapped.
	*/
	void setBakeToOneMap(const BoolID& one){fprintf_s(mFile,"connectAttr \"");one.write(mFile);fprintf_s(mFile,"\" \"%s.one\";\n",mName.c_str());}
	/*
	Number of samples for anti-aliasing control.
	<b>samples</b> is used during rasterization.
	*/
	void setSamples(int nsp){if(nsp == 1) return; fprintf_s(mFile, "setAttr \".nsp\" %i;\n", nsp);}
	/*
	Number of samples for anti-aliasing control.
	<b>samples</b> is used during rasterization.
	*/
	void setSamples(const IntID& nsp){fprintf_s(mFile,"connectAttr \"");nsp.write(mFile);fprintf_s(mFile,"\" \"%s.nsp\";\n",mName.c_str());}
	/*
	You can write one lightmap texture per shadingGroup on each shape,
	or one lightmap per shape, regarless of shadingGroup assignments,
	or one lightmap for this entire bakeSet, containing a patchwork
	of all member shapes (this third option only works if the shapes
	in this bakeSet have non-overlapping UV spaces).
	*/
	UnsignedintID getSeparation(){char buffer[4096];sprintf_s (buffer, "%s.sep",mName.c_str());return (const char*)buffer;}
	/*
	The bitmaps generated by this baking will have
	names beginning with this prefix.
	*/
	StringID getPrefix(){char buffer[4096];sprintf_s (buffer, "%s.pre",mName.c_str());return (const char*)buffer;}
	/*The file texture's horizontal resolution.*/
	IntID getXResolution(){char buffer[4096];sprintf_s (buffer, "%s.xres",mName.c_str());return (const char*)buffer;}
	/*The file texture's vertical resolution.*/
	IntID getYResolution(){char buffer[4096];sprintf_s (buffer, "%s.yres",mName.c_str());return (const char*)buffer;}
	/*Set the output bitmap file format to use.*/
	UnsignedintID getFileFormat(){char buffer[4096];sprintf_s (buffer, "%s.format",mName.c_str());return (const char*)buffer;}
	/*Specifies the number of bits per channel to use in the output bitmap.*/
	UnsignedintID getBitsPerChannel(){char buffer[4096];sprintf_s (buffer, "%s.bits",mName.c_str());return (const char*)buffer;}
	/*
	Activate this option if you wish any meshes being baked to
	be baked as if they were in a given UV set, instead of the
	UV sets which they are currently associated with.
	*/
	BoolID getOverrideUvSet(){char buffer[4096];sprintf_s (buffer, "%s.overrideuv",mName.c_str());return (const char*)buffer;}
	/*Which UV set to use for the meshes in this textureBakeSet.*/
	StringID getUvSetName(){char buffer[4096];sprintf_s (buffer, "%s.set",mName.c_str());return (const char*)buffer;}
	/*
	Specifies whether to bake a rectangle in UV space from 0,0 to 1,1,
	the entire UV space, or a manually specified range, below.
	*/
	UnsignedintID getUvRange(){char buffer[4096];sprintf_s (buffer, "%s.range",mName.c_str());return (const char*)buffer;}
	/*Minimum U for baking.*/
	FloatID getUMin(){char buffer[4096];sprintf_s (buffer, "%s.ul",mName.c_str());return (const char*)buffer;}
	/*Maximum U for baking.*/
	FloatID getUMax(){char buffer[4096];sprintf_s (buffer, "%s.uh",mName.c_str());return (const char*)buffer;}
	/*Minimum V for baking.*/
	FloatID getVMin(){char buffer[4096];sprintf_s (buffer, "%s.vl",mName.c_str());return (const char*)buffer;}
	/*Maximum V for baking.*/
	FloatID getVMax(){char buffer[4096];sprintf_s (buffer, "%s.vh",mName.c_str());return (const char*)buffer;}
	/*Specifies how to fill the background of the light map texture*/
	UnsignedintID getBackgroundMode(){char buffer[4096];sprintf_s (buffer, "%s.bmode",mName.c_str());return (const char*)buffer;}
	/*
	<b>Background Color</b> is the color used if the user sets
	the background mode to custom color.
	*/
	Float3ID getBackgroundColor(){char buffer[4096];sprintf_s (buffer, "%s.bgc",mName.c_str());return (const char*)buffer;}
	/*Red component of Background Color*/
	FloatID getBackgroundColorR(){char buffer[4096];sprintf_s (buffer, "%s.bgc.bgr",mName.c_str());return (const char*)buffer;}
	/*Green component of Background Color*/
	FloatID getBackgroundColorG(){char buffer[4096];sprintf_s (buffer, "%s.bgc.bgg",mName.c_str());return (const char*)buffer;}
	/*Blue component of Background Color*/
	FloatID getBackgroundColorB(){char buffer[4096];sprintf_s (buffer, "%s.bgc.bgb",mName.c_str());return (const char*)buffer;}
	/*
	If the selected UV space contains boundaries, these boundaries may
	become visible as black stripes in renderings which use the baked
	textures.  This occurs when the texture is sampled close enough to
	a boundary that the filter picks up values (generally black) from
	outside the desired space.  fillTextureSeams artificially extends
	the boundaries by a small amount to alleviate this problem.
	fillTextureSeams is measured in texels (pixels of texture).
	Typically, the filter will only be a few texels in diameter, and
	can only reach as far as its radius into these boundary spaces,
	so a value of 1 or 2 is usually enough.
	*/
	FloatID getFillTextureSeams(){char buffer[4096];sprintf_s (buffer, "%s.fillseams",mName.c_str());return (const char*)buffer;}
	/*OBSOLETE*/
	FloatID getFillScale(){char buffer[4096];sprintf_s (buffer, "%s.fillscale",mName.c_str());return (const char*)buffer;}
	/*
	mental ray carries out a final gather pass before actually rendering the scene.
	This pass computes a sufficiently dense final gather map to ensure image quality.
	But the precomputation pass is disabled by default for baking
	because it is depending on the view,
	guaranteeing quality only for surfaces visible to the camera.
	When this value is set to non zero,
	mental ray computes a number of final gather points before baking takes place.
	If set to one, baking should yield roughly the same quality as would rendering from the camera.
	Values beyond one increase quality by precomputing a denser map of final gather points.
	Do not just use finalGatherQuality to tune final gather quality for baking.
	It is still necessary to adjust final gather accuracy and maximum radius in the Render Settings.
	*/
	FloatID getFinalGatherQuality(){char buffer[4096];sprintf_s (buffer, "%s.fgq",mName.c_str());return (const char*)buffer;}
	/*
	This parameter determines the reflectivity of an object
	when precomputing final gather points for lightmapping.
	A certain fraction of all final gather points (as given by finalGatherQuality)
	is not prebaked on the object which is being baked,
	but on objects hit by reflection rays cast from this bake object.
	For example, if finalGatherReflect is set to 0.25,
	every 4th final gather point will be precomputed on the object
	hit by the reflection ray.
	*/
	FloatID getFinalGatherReflect(){char buffer[4096];sprintf_s (buffer, "%s.fgr",mName.c_str());return (const char*)buffer;}
	/*
	If this option is on, objects that belong to this bakeset
	is baked to a single texture file.
	Example of such a case is an object with multiple shaders.
	Without this option, each component of the object will be baked to separate textures.
	With <b>bakeToOneMap</b> on, a single texture will be generated for the object.
	Make sure that UV of the objects in the bakeset are not overlapped.
	*/
	BoolID getBakeToOneMap(){char buffer[4096];sprintf_s (buffer, "%s.one",mName.c_str());return (const char*)buffer;}
	/*
	Number of samples for anti-aliasing control.
	<b>samples</b> is used during rasterization.
	*/
	IntID getSamples(){char buffer[4096];sprintf_s (buffer, "%s.nsp",mName.c_str());return (const char*)buffer;}
protected:
	TextureBakeSet(FILE* file,const std::string& name,const std::string& parent,const std::string& nodeType):BakeSet(file, name, parent, nodeType) {}
private:

};
}//namespace MayaDM
#endif//__MayaDM_TEXTUREBAKESET_H__
