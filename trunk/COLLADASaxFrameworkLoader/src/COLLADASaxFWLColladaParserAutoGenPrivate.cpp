#include "COLLADASaxFWLStableHeaders.h"
#include "GeneratedSaxParserUtils.h"

#include "COLLADASaxFWLColladaParserAutoGenPrivate.h"


namespace COLLADASaxFWL
{


	//---------------------------------------------------------------------
	const char* ColladaParserAutoGenPrivate::PARENT_CHILD_ELEMENT_SEPARATOR = "__";


	//---------------------------------------------------------------------
	ColladaParserAutoGenPrivate::ColladaParserAutoGenPrivate( COLLADASaxFWL::ColladaParserAutoGen* impl, GeneratedSaxParser::IErrorHandler* errorHandler 
		)    : 
	ParserTemplate<ColladaParserAutoGenPrivate, ColladaParserAutoGen>(impl, errorHandler)
	{
		initFunctionMap();
		initNameMap();
	}

	//---------------------------------------------------------------------
	ColladaParserAutoGenPrivate::~ColladaParserAutoGenPrivate()
	{
	}


	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS = "library_force_fields";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_FORCE_FIELDS = "COLLADA__library_force_fields";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_ID = "id";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_NAME = "name";

	//---------------------------------------------------------------------
	const library_force_fields__AttributeData library_force_fields__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_force_fields( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_force_fields__AttributeData* attributeData = newData<library_force_fields__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_FORCE_FIELDS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET = "asset";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__ASSET = "library_force_fields__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_force_fields__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR = "contributor";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__CONTRIBUTOR = "asset__contributor";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__contributor( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__contributor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__contributor()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AUTHOR = "author";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR__AUTHOR = "contributor__author";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__author( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__author(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__author( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__author()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AUTHORING_TOOL = "authoring_tool";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR__AUTHORING_TOOL = "contributor__authoring_tool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__authoring_tool( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__authoring_tool(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__authoring_tool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__authoring_tool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COMMENTS = "comments";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR__COMMENTS = "contributor__comments";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__comments( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__comments(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__comments( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__comments()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COPYRIGHT = "copyright";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR__COPYRIGHT = "contributor__copyright";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__copyright( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__copyright(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__copyright( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__copyright()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE_DATA = "source_data";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTRIBUTOR__SOURCE_DATA = "contributor__source_data";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__source_data( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__source_data(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__source_data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__source_data()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CREATED = "created";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__CREATED = "asset__created";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__created( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__created(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__created( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__created()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_KEYWORDS = "keywords";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__KEYWORDS = "asset__keywords";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__keywords( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__keywords(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__keywords( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__keywords()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MODIFIED = "modified";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__MODIFIED = "asset__modified";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__modified( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__modified(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__modified( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__modified()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REVISION = "revision";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__REVISION = "asset__revision";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__revision( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__revision(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__revision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__revision()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SUBJECT = "subject";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__SUBJECT = "asset__subject";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__subject( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__subject(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__subject( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__subject()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TITLE = "title";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__TITLE = "asset__title";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__title( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__title(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__title( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__title()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_UNIT = "unit";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__UNIT = "asset__unit";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_METER = "meter";

	//---------------------------------------------------------------------
	const unit__AttributeData unit__AttributeData::DEFAULT = {1.0E0, (const GeneratedSaxParser::ParserChar *)"meter"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__unit( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		unit__AttributeData* attributeData = newData<unit__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_METER:
					{
						bool failed;
						attributeData->meter = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_UNIT, HASH_ATTRIBUTE_METER, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_UNIT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__unit()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_UP_AXIS = "up_axis";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASSET__UP_AXIS = "asset__up_axis";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__up_axis( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__up_axis(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__up_axis( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__up_axis()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORCE_FIELD = "force_field";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__FORCE_FIELD = "library_force_fields__force_field";

	//---------------------------------------------------------------------
	const force_field__AttributeData force_field__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__force_field( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		force_field__AttributeData* attributeData = newData<force_field__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__force_field()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORCE_FIELD__ASSET = "force_field__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__force_field__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__force_field__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__force_field__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE = "technique";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORCE_FIELD__TECHNIQUE = "force_field__technique";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_PROFILE = "profile";

	//---------------------------------------------------------------------
	const force_field__technique__AttributeData force_field__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__force_field__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__force_field__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		force_field__technique__AttributeData* attributeData = newData<force_field__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__force_field__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EXTRA = "extra";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORCE_FIELD__EXTRA = "force_field__extra";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_TYPE = "type";

	//---------------------------------------------------------------------
	const force_field__extra__AttributeData force_field__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__force_field__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		force_field__extra__AttributeData* attributeData = newData<force_field__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__force_field__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EXTRA__ASSET = "extra__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__extra__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__extra__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__extra__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EXTRA__TECHNIQUE = "extra__technique";

	//---------------------------------------------------------------------
	const extra__technique__AttributeData extra__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__extra__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__extra__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		extra__technique__AttributeData* attributeData = newData<extra__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EXTRA__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__extra__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_FORCE_FIELDS__EXTRA = "library_force_fields__extra";

	//---------------------------------------------------------------------
	const library_force_fields__extra__AttributeData library_force_fields__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_force_fields__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_force_fields__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_force_fields__extra__AttributeData* attributeData = newData<library_force_fields__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_FORCE_FIELDS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_force_fields__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_EFFECT = "instance_effect";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RENDER__INSTANCE_EFFECT = "render__instance_effect";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_URL = "url";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SID = "sid";

	//---------------------------------------------------------------------
	const instance_effect__AttributeData instance_effect__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_effect( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_effect__AttributeData* attributeData = newData<instance_effect__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_effect()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_HINT = "technique_hint";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_EFFECT__TECHNIQUE_HINT = "instance_effect__technique_hint";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_PLATFORM = "platform";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_REF = "ref";

	//---------------------------------------------------------------------
	const technique_hint__AttributeData technique_hint__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique_hint( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique_hint__AttributeData* attributeData = newData<technique_hint__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PLATFORM:
					{

						attributeData->platform = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_HINT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique_hint()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM = "setparam";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_EFFECT__SETPARAM = "instance_effect__setparam";

	//---------------------------------------------------------------------
	const instance_effect__setparam__AttributeData instance_effect__setparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_effect__setparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_effect__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_effect__setparam__AttributeData* attributeData = newData<instance_effect__setparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT__SETPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_effect__setparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL = "bool";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL = "setparam__bool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL2 = "bool2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL2 = "setparam__bool2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL3 = "bool3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL3 = "setparam__bool3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL4 = "bool4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL4 = "setparam__bool4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT = "int";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT = "setparam__int";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT2 = "int2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT2 = "setparam__int2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT3 = "int3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT3 = "setparam__int3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT4 = "int4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT4 = "setparam__int4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT = "float";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT = "setparam__float";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT2 = "float2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT2 = "setparam__float2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT3 = "float3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT3 = "setparam__float3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT4 = "float4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT4 = "setparam__float4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT1X1 = "float1x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT1X1 = "setparam__float1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT1X2 = "float1x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT1X2 = "setparam__float1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT1X3 = "float1x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT1X3 = "setparam__float1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT1X4 = "float1x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT1X4 = "setparam__float1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT2X1 = "float2x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT2X1 = "setparam__float2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT2X2 = "float2x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT2X2 = "setparam__float2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT2X3 = "float2x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT2X3 = "setparam__float2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT2X4 = "float2x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT2X4 = "setparam__float2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT3X1 = "float3x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT3X1 = "setparam__float3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT3X2 = "float3x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT3X2 = "setparam__float3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT3X3 = "float3x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT3X3 = "setparam__float3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT3X4 = "float3x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT3X4 = "setparam__float3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT4X1 = "float4x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT4X1 = "setparam__float4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT4X2 = "float4x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT4X2 = "setparam__float4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT4X3 = "float4x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT4X3 = "setparam__float4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT4X4 = "float4x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT4X4 = "setparam__float4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__float4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE = "surface";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SURFACE = "setparam__surface";

	//---------------------------------------------------------------------
	const setparam__surface__AttributeData setparam__surface__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__surface( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__surface__AttributeData* attributeData = newData<setparam__surface__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__SURFACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__surface()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_AS_NULL = "init_as_null";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_AS_NULL = "surface__init_as_null";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_as_null( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__init_as_null(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_as_null( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_as_null()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_AS_TARGET = "init_as_target";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_AS_TARGET = "surface__init_as_target";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_as_target( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__init_as_target(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_as_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_as_target()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_CUBE = "init_cube";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_CUBE = "surface__init_cube";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_cube( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_cube( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_cube()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALL = "all";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_CUBE__ALL = "init_cube__all";

	//---------------------------------------------------------------------
	const init_cube__all__AttributeData init_cube__all__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_cube__all( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_cube__all__AttributeData* attributeData = newData<init_cube__all__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__ALL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__all()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PRIMARY = "primary";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_CUBE__PRIMARY = "init_cube__primary";

	//---------------------------------------------------------------------
	const init_cube__primary__AttributeData init_cube__primary__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_cube__primary( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_cube__primary__AttributeData* attributeData = newData<init_cube__primary__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__PRIMARY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__primary()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORDER = "order";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PRIMARY__ORDER = "primary__order";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__order( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__order(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__order( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__order()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FACE = "face";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_CUBE__FACE = "init_cube__face";

	//---------------------------------------------------------------------
	const init_cube__face__AttributeData init_cube__face__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_cube__face( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_cube__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_cube__face__AttributeData* attributeData = newData<init_cube__face__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__FACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_cube__face()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_VOLUME = "init_volume";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_VOLUME = "surface__init_volume";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_volume( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_volume( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_volume()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_VOLUME__ALL = "init_volume__all";

	//---------------------------------------------------------------------
	const init_volume__all__AttributeData init_volume__all__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_volume__all( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_volume__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_volume__all__AttributeData* attributeData = newData<init_volume__all__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_VOLUME__ALL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_volume__all()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_VOLUME__PRIMARY = "init_volume__primary";

	//---------------------------------------------------------------------
	const init_volume__primary__AttributeData init_volume__primary__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_volume__primary( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_volume__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_volume__primary__AttributeData* attributeData = newData<init_volume__primary__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_VOLUME__PRIMARY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_volume__primary()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_PLANAR = "init_planar";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_PLANAR = "surface__init_planar";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_planar( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_planar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_planar()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_PLANAR__ALL = "init_planar__all";

	//---------------------------------------------------------------------
	const init_planar__all__AttributeData init_planar__all__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__init_planar__all( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__init_planar__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		init_planar__all__AttributeData* attributeData = newData<init_planar__all__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_PLANAR__ALL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__init_planar__all()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INIT_FROM = "init_from";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__INIT_FROM = "surface__init_from";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_MIP = "mip";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SLICE = "slice";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_FACE = "face";

	//---------------------------------------------------------------------
	const surface__init_from__AttributeData surface__init_from__AttributeData::DEFAULT = {0, 0, (const GeneratedSaxParser::ParserChar *)"POSITIVE_X"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__surface__init_from( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__surface__init_from(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__surface__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		surface__init_from__AttributeData* attributeData = newData<surface__init_from__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_MIP:
					{
						bool failed;
						attributeData->mip = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_MIP, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_SLICE:
					{
						bool failed;
						attributeData->slice = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_SLICE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_FACE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__surface__init_from()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT = "format";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__FORMAT = "surface__format";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__format( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__format(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__format()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT = "format_hint";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__FORMAT_HINT = "surface__format_hint";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__format_hint( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__format_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__format_hint()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CHANNELS = "channels";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT__CHANNELS = "format_hint__channels";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__channels( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__channels(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__channels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__channels()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RANGE = "range";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT__RANGE = "format_hint__range";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__range( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__range(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__range()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PRECISION = "precision";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT__PRECISION = "format_hint__precision";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__precision( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__precision(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__precision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__precision()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_OPTION = "option";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT__OPTION = "format_hint__option";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__option( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__option(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__option( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__option()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FORMAT_HINT__EXTRA = "format_hint__extra";

	//---------------------------------------------------------------------
	const format_hint__extra__AttributeData format_hint__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__format_hint__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__format_hint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		format_hint__extra__AttributeData* attributeData = newData<format_hint__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORMAT_HINT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__format_hint__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SIZE = "size";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__SIZE = "surface__size";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__surface__size( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__surface__size);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__surface__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__surface__size()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VIEWPORT_RATIO = "viewport_ratio";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__VIEWPORT_RATIO = "surface__viewport_ratio";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__viewport_ratio( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__viewport_ratio);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__viewport_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__viewport_ratio()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIP_LEVELS = "mip_levels";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__MIP_LEVELS = "surface__mip_levels";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mip_levels( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__mip_levels);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mip_levels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mip_levels()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIPMAP_GENERATE = "mipmap_generate";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__MIPMAP_GENERATE = "surface__mipmap_generate";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mipmap_generate( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__mipmap_generate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mipmap_generate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mipmap_generate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__EXTRA = "surface__extra";

	//---------------------------------------------------------------------
	const surface__extra__AttributeData surface__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__surface__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__surface__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		surface__extra__AttributeData* attributeData = newData<surface__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__surface__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D = "sampler1D";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLER1D = "setparam__sampler1D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__sampler1D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler1D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE = "source";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__SOURCE = "sampler1D__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler1D__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_WRAP_S = "wrap_s";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__WRAP_S = "sampler1D__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler1D__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MINFILTER = "minfilter";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__MINFILTER = "sampler1D__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler1D__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MAGFILTER = "magfilter";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__MAGFILTER = "sampler1D__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler1D__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIPFILTER = "mipfilter";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__MIPFILTER = "sampler1D__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler1D__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BORDER_COLOR = "border_color";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__BORDER_COLOR = "sampler1D__border_color";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__border_color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler1D__border_color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__border_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIPMAP_MAXLEVEL = "mipmap_maxlevel";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__MIPMAP_MAXLEVEL = "sampler1D__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler1D__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIPMAP_BIAS = "mipmap_bias";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__MIPMAP_BIAS = "sampler1D__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__sampler1D__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER1D__EXTRA = "sampler1D__extra";

	//---------------------------------------------------------------------
	const sampler1D__extra__AttributeData sampler1D__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler1D__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler1D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler1D__extra__AttributeData* attributeData = newData<sampler1D__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER1D__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler1D__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D = "sampler2D";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLER2D = "setparam__sampler2D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__sampler2D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler2D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__SOURCE = "sampler2D__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__WRAP_S = "sampler2D__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_WRAP_T = "wrap_t";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__WRAP_T = "sampler2D__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__MINFILTER = "sampler2D__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__MAGFILTER = "sampler2D__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__MIPFILTER = "sampler2D__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler2D__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__BORDER_COLOR = "sampler2D__border_color";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__border_color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler2D__border_color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__border_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__MIPMAP_MAXLEVEL = "sampler2D__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler2D__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__MIPMAP_BIAS = "sampler2D__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__sampler2D__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER2D__EXTRA = "sampler2D__extra";

	//---------------------------------------------------------------------
	const sampler2D__extra__AttributeData sampler2D__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler2D__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler2D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler2D__extra__AttributeData* attributeData = newData<sampler2D__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER2D__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler2D__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D = "sampler3D";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLER3D = "setparam__sampler3D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__sampler3D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler3D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__SOURCE = "sampler3D__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__WRAP_S = "sampler3D__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__WRAP_T = "sampler3D__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_WRAP_P = "wrap_p";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__WRAP_P = "sampler3D__wrap_p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__wrap_p( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__wrap_p(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__wrap_p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__MINFILTER = "sampler3D__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__MAGFILTER = "sampler3D__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__MIPFILTER = "sampler3D__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler3D__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__BORDER_COLOR = "sampler3D__border_color";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__border_color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler3D__border_color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__border_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__MIPMAP_MAXLEVEL = "sampler3D__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler3D__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__MIPMAP_BIAS = "sampler3D__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__sampler3D__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER3D__EXTRA = "sampler3D__extra";

	//---------------------------------------------------------------------
	const sampler3D__extra__AttributeData sampler3D__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler3D__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler3D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler3D__extra__AttributeData* attributeData = newData<sampler3D__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER3D__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler3D__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE = "samplerCUBE";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLERCUBE = "setparam__samplerCUBE";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__samplerCUBE( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerCUBE()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__SOURCE = "samplerCUBE__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_S = "samplerCUBE__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_T = "samplerCUBE__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__WRAP_P = "samplerCUBE__wrap_p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__wrap_p( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__wrap_p(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__wrap_p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__MINFILTER = "samplerCUBE__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__MAGFILTER = "samplerCUBE__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__MIPFILTER = "samplerCUBE__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerCUBE__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__BORDER_COLOR = "samplerCUBE__border_color";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__border_color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerCUBE__border_color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__border_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__MIPMAP_MAXLEVEL = "samplerCUBE__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerCUBE__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__MIPMAP_BIAS = "samplerCUBE__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__samplerCUBE__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERCUBE__EXTRA = "samplerCUBE__extra";

	//---------------------------------------------------------------------
	const samplerCUBE__extra__AttributeData samplerCUBE__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerCUBE__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerCUBE__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		samplerCUBE__extra__AttributeData* attributeData = newData<samplerCUBE__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERCUBE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerCUBE__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT = "samplerRECT";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLERRECT = "setparam__samplerRECT";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__samplerRECT( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerRECT()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__SOURCE = "samplerRECT__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__WRAP_S = "samplerRECT__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__WRAP_T = "samplerRECT__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__MINFILTER = "samplerRECT__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__MAGFILTER = "samplerRECT__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__MIPFILTER = "samplerRECT__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerRECT__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__BORDER_COLOR = "samplerRECT__border_color";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__border_color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerRECT__border_color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__border_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__MIPMAP_MAXLEVEL = "samplerRECT__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__samplerRECT__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__MIPMAP_BIAS = "samplerRECT__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__samplerRECT__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERRECT__EXTRA = "samplerRECT__extra";

	//---------------------------------------------------------------------
	const samplerRECT__extra__AttributeData samplerRECT__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerRECT__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerRECT__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		samplerRECT__extra__AttributeData* attributeData = newData<samplerRECT__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERRECT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerRECT__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH = "samplerDEPTH";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLERDEPTH = "setparam__samplerDEPTH";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__samplerDEPTH( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__samplerDEPTH()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__SOURCE = "samplerDEPTH__source";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__source( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerDEPTH__source(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__WRAP_S = "samplerDEPTH__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerDEPTH__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__WRAP_T = "samplerDEPTH__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerDEPTH__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__MINFILTER = "samplerDEPTH__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerDEPTH__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__MAGFILTER = "samplerDEPTH__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__samplerDEPTH__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLERDEPTH__EXTRA = "samplerDEPTH__extra";

	//---------------------------------------------------------------------
	const samplerDEPTH__extra__AttributeData samplerDEPTH__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__samplerDEPTH__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__samplerDEPTH__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		samplerDEPTH__extra__AttributeData* attributeData = newData<samplerDEPTH__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERDEPTH__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__samplerDEPTH__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ENUM = "enum";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__ENUM = "setparam__enum";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__enum( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__setparam__enum(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__enum()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_EFFECT__EXTRA = "instance_effect__extra";

	//---------------------------------------------------------------------
	const instance_effect__extra__AttributeData instance_effect__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_effect__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_effect__extra__AttributeData* attributeData = newData<instance_effect__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_effect__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION = "animation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__ANIMATION = "library_animations__animation";

	//---------------------------------------------------------------------
	const animation__AttributeData animation__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		animation__AttributeData* attributeData = newData<animation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION__ASSET = "animation__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION__SOURCE = "animation__source";

	//---------------------------------------------------------------------
	const animation__source__AttributeData animation__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		animation__source__AttributeData* attributeData = newData<animation__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__ASSET = "source__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__source__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__source__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__source__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IDREF_ARRAY = "IDREF_array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__IDREF_ARRAY = "source__IDREF_array";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_COUNT = "count";

	//---------------------------------------------------------------------
	const IDREF_array__AttributeData IDREF_array__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__IDREF_array( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__IDREF_array(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__IDREF_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		IDREF_array__AttributeData* attributeData = newData<IDREF_array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IDREF_ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__IDREF_array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NAME_ARRAY = "Name_array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__NAME_ARRAY = "source__Name_array";

	//---------------------------------------------------------------------
	const Name_array__AttributeData Name_array__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__Name_array( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__Name_array(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__Name_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		Name_array__AttributeData* attributeData = newData<Name_array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NAME_ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__Name_array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL_ARRAY = "bool_array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__BOOL_ARRAY = "source__bool_array";

	//---------------------------------------------------------------------
	const bool_array__AttributeData bool_array__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bool_array( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__bool_array);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bool_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		bool_array__AttributeData* attributeData = newData<bool_array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BOOL_ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bool_array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT_ARRAY = "float_array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__FLOAT_ARRAY = "source__float_array";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_DIGITS = "digits";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_MAGNITUDE = "magnitude";

	//---------------------------------------------------------------------
	const float_array__AttributeData float_array__AttributeData::DEFAULT = {0, 0, 0, 6, 38};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__float_array( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__float_array);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__float_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		float_array__AttributeData* attributeData = newData<float_array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_DIGITS:
					{
						bool failed;
						attributeData->digits = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_DIGITS, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_MAGNITUDE:
					{
						bool failed;
						attributeData->magnitude = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_MAGNITUDE, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__float_array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT_ARRAY = "int_array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__INT_ARRAY = "source__int_array";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_MININCLUSIVE = "minInclusive";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_MAXINCLUSIVE = "maxInclusive";

	//---------------------------------------------------------------------
	const int_array__AttributeData int_array__AttributeData::DEFAULT = {0, 0, 0, -2147483648, 2147483647};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__int_array( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__int_array);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__int_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		int_array__AttributeData* attributeData = newData<int_array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MININCLUSIVE:
					{
						bool failed;
						attributeData->minInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MININCLUSIVE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_MAXINCLUSIVE:
					{
						bool failed;
						attributeData->maxInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MAXINCLUSIVE, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__int_array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON = "technique_common";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__TECHNIQUE_COMMON = "source__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__source__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__source__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__source__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ACCESSOR = "accessor";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__ACCESSOR = "technique_common__accessor";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_OFFSET = "offset";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SOURCE = "source";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_STRIDE = "stride";

	//---------------------------------------------------------------------
	const accessor__AttributeData accessor__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"0", 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__accessor( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__accessor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		accessor__AttributeData* attributeData = newData<accessor__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_STRIDE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__accessor()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PARAM = "param";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ACCESSOR__PARAM = "accessor__param";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SEMANTIC = "semantic";

	//---------------------------------------------------------------------
	const accessor__param__AttributeData accessor__param__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__accessor__param( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__accessor__param(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__accessor__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		accessor__param__AttributeData* attributeData = newData<accessor__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__accessor__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SOURCE__TECHNIQUE = "source__technique";

	//---------------------------------------------------------------------
	const source__technique__AttributeData source__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__source__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__source__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		source__technique__AttributeData* attributeData = newData<source__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SOURCE__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__source__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER = "sampler";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION__SAMPLER = "animation__sampler";

	//---------------------------------------------------------------------
	const sampler__AttributeData sampler__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler__AttributeData* attributeData = newData<sampler__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INPUT = "input";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER__INPUT = "sampler__input";

	//---------------------------------------------------------------------
	const sampler__input__AttributeData sampler__input__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler__input__AttributeData* attributeData = newData<sampler__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CHANNEL = "channel";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION__CHANNEL = "animation__channel";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_TARGET = "target";

	//---------------------------------------------------------------------
	const channel__AttributeData channel__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__channel( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__channel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		channel__AttributeData* attributeData = newData<channel__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_TARGET:
					{

						attributeData->target = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CHANNEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__channel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION__EXTRA = "animation__extra";

	//---------------------------------------------------------------------
	const animation__extra__AttributeData animation__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		animation__extra__AttributeData* attributeData = newData<animation__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIFANS = "trifans";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__TRIFANS = "mesh__trifans";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_MATERIAL = "material";

	//---------------------------------------------------------------------
	const trifans__AttributeData trifans__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__trifans( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		trifans__AttributeData* attributeData = newData<trifans__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__trifans()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIFANS__INPUT = "trifans__input";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SET = "set";

	//---------------------------------------------------------------------
	const trifans__input__AttributeData trifans__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__trifans__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__trifans__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		trifans__input__AttributeData* attributeData = newData<trifans__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__trifans__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_P = "p";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIFANS__P = "trifans__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__trifans__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__trifans__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__trifans__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__trifans__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIFANS__EXTRA = "trifans__extra";

	//---------------------------------------------------------------------
	const trifans__extra__AttributeData trifans__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__trifans__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__trifans__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		trifans__extra__AttributeData* attributeData = newData<trifans__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__trifans__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const source__AttributeData source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		source__AttributeData* attributeData = newData<source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES = "profile_GLES";

	//---------------------------------------------------------------------
	const profile_GLES__AttributeData profile_GLES__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"PC"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLES__AttributeData* attributeData = newData<profile_GLES__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PLATFORM:
					{

						attributeData->platform = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES__ASSET = "profile_GLES__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGE = "image";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES__IMAGE = "profile_GLES__image";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_FORMAT = "format";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_HEIGHT = "height";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_WIDTH = "width";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_DEPTH = "depth";

	//---------------------------------------------------------------------
	const profile_GLES__image__AttributeData profile_GLES__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLES__image__AttributeData* attributeData = newData<profile_GLES__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGE__ASSET = "image__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__image__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__image__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__image__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DATA = "data";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGE__DATA = "image__data";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__data( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__data(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__data()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGE__INIT_FROM = "image__init_from";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__image__init_from( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__image__init_from(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__image__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__image__init_from()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGE__EXTRA = "image__extra";

	//---------------------------------------------------------------------
	const image__extra__AttributeData image__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__image__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__image__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		image__extra__AttributeData* attributeData = newData<image__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__image__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM = "newparam";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES__NEWPARAM = "profile_GLES__newparam";

	//---------------------------------------------------------------------
	const profile_GLES__newparam__AttributeData profile_GLES__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLES__newparam__AttributeData* attributeData = newData<profile_GLES__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE = "annotate";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__ANNOTATE = "newparam__annotate";

	//---------------------------------------------------------------------
	const newparam__annotate__AttributeData newparam__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__annotate__AttributeData* attributeData = newData<newparam__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__BOOL = "annotate__bool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__bool( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__BOOL2 = "annotate__bool2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__bool2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__BOOL3 = "annotate__bool3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__bool3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__BOOL4 = "annotate__bool4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__bool4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__annotate__bool4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__bool4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__INT = "annotate__int";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__int( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__int);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__INT2 = "annotate__int2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__int2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__int2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__INT3 = "annotate__int3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__int3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__int3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__INT4 = "annotate__int4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__int4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__int4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__int4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT = "annotate__float";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT2 = "annotate__float2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT3 = "annotate__float3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT4 = "annotate__float4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT2X2 = "annotate__float2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT3X3 = "annotate__float3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__FLOAT4X4 = "annotate__float4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__float4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__annotate__float4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__float4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STRING = "string";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANNOTATE__STRING = "annotate__string";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__annotate__string( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__annotate__string(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__annotate__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__annotate__string()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SEMANTIC = "semantic";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SEMANTIC = "newparam__semantic";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__semantic( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__semantic(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__semantic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__semantic()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MODIFIER = "modifier";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__MODIFIER = "newparam__modifier";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__modifier( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__modifier(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__modifier( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__modifier()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL = "newparam__bool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL2 = "newparam__bool2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL3 = "newparam__bool3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL4 = "newparam__bool4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT = "newparam__int";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT2 = "newparam__int2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT3 = "newparam__int3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT4 = "newparam__int4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT = "newparam__float";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT2 = "newparam__float2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT3 = "newparam__float3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT4 = "newparam__float4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT1X1 = "newparam__float1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT1X2 = "newparam__float1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT1X3 = "newparam__float1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT1X4 = "newparam__float1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT2X1 = "newparam__float2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT2X2 = "newparam__float2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT2X3 = "newparam__float2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT2X4 = "newparam__float2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT3X1 = "newparam__float3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT3X2 = "newparam__float3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT3X3 = "newparam__float3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT3X4 = "newparam__float3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT4X1 = "newparam__float4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT4X2 = "newparam__float4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT4X3 = "newparam__float4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT4X4 = "newparam__float4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__float4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SURFACE = "newparam__surface";

	//---------------------------------------------------------------------
	const newparam__surface__AttributeData newparam__surface__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__surface( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__surface__AttributeData* attributeData = newData<newparam__surface__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__SURFACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__surface()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE = "texture_pipeline";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__TEXTURE_PIPELINE = "newparam__texture_pipeline";

	//---------------------------------------------------------------------
	const newparam__texture_pipeline__AttributeData newparam__texture_pipeline__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__texture_pipeline( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__texture_pipeline__AttributeData* attributeData = newData<newparam__texture_pipeline__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__TEXTURE_PIPELINE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__texture_pipeline()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXCOMBINER = "texcombiner";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE__TEXCOMBINER = "texture_pipeline__texcombiner";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_pipeline__texcombiner( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__texcombiner()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT = "constant";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXCOMBINER__CONSTANT = "texcombiner__constant";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_VALUE = "value";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_PARAM = "param";

	//---------------------------------------------------------------------
	const texcombiner__constant__AttributeData texcombiner__constant__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texcombiner__constant( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texcombiner__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texcombiner__constant__AttributeData* attributeData = newData<texcombiner__constant__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__CONSTANT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texcombiner__constant()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RGB = "RGB";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXCOMBINER__RGB = "texcombiner__RGB";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE__OPERATOR = "_operator";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SCALE = "scale";

	//---------------------------------------------------------------------
	const RGB__AttributeData RGB__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__RGB( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__RGB( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		RGB__AttributeData* attributeData = newData<RGB__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE__OPERATOR:
					{



						break;
					}
				case HASH_ATTRIBUTE_SCALE:
					{
						bool failed;
						attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB, HASH_ATTRIBUTE_SCALE, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__RGB()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARGUMENT = "argument";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RGB__ARGUMENT = "RGB__argument";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_OPERAND = "operand";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_UNIT = "unit";

	//---------------------------------------------------------------------
	const RGB__argument__AttributeData RGB__argument__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"SRC_COLOR", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__RGB__argument( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__RGB__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		RGB__argument__AttributeData* attributeData = newData<RGB__argument__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_OPERAND:
					{



						break;
					}
				case HASH_ATTRIBUTE_UNIT:
					{

						attributeData->unit = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB__ARGUMENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__RGB__argument()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA = "alpha";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXCOMBINER__ALPHA = "texcombiner__alpha";

	//---------------------------------------------------------------------
	const texcombiner__alpha__AttributeData texcombiner__alpha__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texcombiner__alpha( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texcombiner__alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texcombiner__alpha__AttributeData* attributeData = newData<texcombiner__alpha__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE__OPERATOR:
					{



						break;
					}
				case HASH_ATTRIBUTE_SCALE:
					{
						bool failed;
						attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA, HASH_ATTRIBUTE_SCALE, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texcombiner__alpha()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA__ARGUMENT = "alpha__argument";

	//---------------------------------------------------------------------
	const alpha__argument__AttributeData alpha__argument__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"SRC_ALPHA", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__alpha__argument( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__alpha__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		alpha__argument__AttributeData* attributeData = newData<alpha__argument__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_OPERAND:
					{



						break;
					}
				case HASH_ATTRIBUTE_UNIT:
					{

						attributeData->unit = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA__ARGUMENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__alpha__argument()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXENV = "texenv";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE__TEXENV = "texture_pipeline__texenv";

	//---------------------------------------------------------------------
	const texture_pipeline__texenv__AttributeData texture_pipeline__texenv__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_pipeline__texenv( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture_pipeline__texenv__AttributeData* attributeData = newData<texture_pipeline__texenv__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE__OPERATOR:
					{



						break;
					}
				case HASH_ATTRIBUTE_UNIT:
					{

						attributeData->unit = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__TEXENV , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__texenv()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXENV__CONSTANT = "texenv__constant";

	//---------------------------------------------------------------------
	const texenv__constant__AttributeData texenv__constant__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texenv__constant( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texenv__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texenv__constant__AttributeData* attributeData = newData<texenv__constant__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXENV__CONSTANT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texenv__constant()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE__EXTRA = "texture_pipeline__extra";

	//---------------------------------------------------------------------
	const texture_pipeline__extra__AttributeData texture_pipeline__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_pipeline__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture_pipeline__extra__AttributeData* attributeData = newData<texture_pipeline__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE = "sampler_state";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLER_STATE = "newparam__sampler_state";

	//---------------------------------------------------------------------
	const newparam__sampler_state__AttributeData newparam__sampler_state__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__sampler_state( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__sampler_state__AttributeData* attributeData = newData<newparam__sampler_state__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__SAMPLER_STATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler_state()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__WRAP_S = "sampler_state__wrap_s";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__wrap_s( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler_state__wrap_s(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__wrap_s()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__WRAP_T = "sampler_state__wrap_t";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__wrap_t( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler_state__wrap_t(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__wrap_t()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__MINFILTER = "sampler_state__minfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__minfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler_state__minfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__minfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__MAGFILTER = "sampler_state__magfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__magfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler_state__magfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__magfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__MIPFILTER = "sampler_state__mipfilter";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__mipfilter( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__sampler_state__mipfilter(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipfilter()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__MIPMAP_MAXLEVEL = "sampler_state__mipmap_maxlevel";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__mipmap_maxlevel( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sampler_state__mipmap_maxlevel);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipmap_maxlevel()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__MIPMAP_BIAS = "sampler_state__mipmap_bias";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__mipmap_bias( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__sampler_state__mipmap_bias);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__mipmap_bias()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLER_STATE__EXTRA = "sampler_state__extra";

	//---------------------------------------------------------------------
	const sampler_state__extra__AttributeData sampler_state__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sampler_state__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sampler_state__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sampler_state__extra__AttributeData* attributeData = newData<sampler_state__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER_STATE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sampler_state__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_UNIT = "texture_unit";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__TEXTURE_UNIT = "newparam__texture_unit";

	//---------------------------------------------------------------------
	const newparam__texture_unit__AttributeData newparam__texture_unit__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__texture_unit( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__texture_unit__AttributeData* attributeData = newData<newparam__texture_unit__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__TEXTURE_UNIT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__texture_unit()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_UNIT__SURFACE = "texture_unit__surface";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_unit__surface( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__texture_unit__surface(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__surface()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_UNIT__SAMPLER_STATE = "texture_unit__sampler_state";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_unit__sampler_state( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__texture_unit__sampler_state(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__sampler_state()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXCOORD = "texcoord";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_UNIT__TEXCOORD = "texture_unit__texcoord";

	//---------------------------------------------------------------------
	const texcoord__AttributeData texcoord__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texcoord( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texcoord( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texcoord__AttributeData* attributeData = newData<texcoord__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOORD , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texcoord()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_UNIT__EXTRA = "texture_unit__extra";

	//---------------------------------------------------------------------
	const texture_unit__extra__AttributeData texture_unit__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_unit__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_unit__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture_unit__extra__AttributeData* attributeData = newData<texture_unit__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_UNIT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_unit__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__ENUM = "newparam__enum";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__enum( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__newparam__enum(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__enum()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES__TECHNIQUE = "profile_GLES__technique";

	//---------------------------------------------------------------------
	const profile_GLES__technique__AttributeData profile_GLES__technique__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLES__technique__AttributeData* attributeData = newData<profile_GLES__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__ASSET = "technique__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__ANNOTATE = "technique__annotate";

	//---------------------------------------------------------------------
	const technique__annotate__AttributeData technique__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__annotate__AttributeData* attributeData = newData<technique__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__IMAGE = "technique__image";

	//---------------------------------------------------------------------
	const technique__image__AttributeData technique__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__image__AttributeData* attributeData = newData<technique__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__NEWPARAM = "technique__newparam";

	//---------------------------------------------------------------------
	const technique__newparam__AttributeData technique__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__newparam__AttributeData* attributeData = newData<technique__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__SETPARAM = "technique__setparam";

	//---------------------------------------------------------------------
	const technique__setparam__AttributeData technique__setparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__setparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__setparam__AttributeData* attributeData = newData<technique__setparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__SETPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__setparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__ANNOTATE = "setparam__annotate";

	//---------------------------------------------------------------------
	const setparam__annotate__AttributeData setparam__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__annotate__AttributeData* attributeData = newData<setparam__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__TEXTURE_PIPELINE = "setparam__texture_pipeline";

	//---------------------------------------------------------------------
	const setparam__texture_pipeline__AttributeData setparam__texture_pipeline__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__texture_pipeline( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__texture_pipeline__AttributeData* attributeData = newData<setparam__texture_pipeline__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__TEXTURE_PIPELINE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__texture_pipeline()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__SAMPLER_STATE = "setparam__sampler_state";

	//---------------------------------------------------------------------
	const setparam__sampler_state__AttributeData setparam__sampler_state__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__sampler_state( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__sampler_state__AttributeData* attributeData = newData<setparam__sampler_state__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__SAMPLER_STATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__sampler_state()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__TEXTURE_UNIT = "setparam__texture_unit";

	//---------------------------------------------------------------------
	const setparam__texture_unit__AttributeData setparam__texture_unit__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__texture_unit( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__texture_unit__AttributeData* attributeData = newData<setparam__texture_unit__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__TEXTURE_UNIT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__texture_unit()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS = "pass";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__PASS = "technique__pass";

	//---------------------------------------------------------------------
	const pass__AttributeData pass__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__pass( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__pass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		pass__AttributeData* attributeData = newData<pass__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__pass()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__ANNOTATE = "pass__annotate";

	//---------------------------------------------------------------------
	const pass__annotate__AttributeData pass__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__pass__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__pass__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		pass__annotate__AttributeData* attributeData = newData<pass__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__pass__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR_TARGET = "color_target";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__COLOR_TARGET = "pass__color_target";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__color_target( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__color_target(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__color_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__color_target()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_TARGET = "depth_target";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_TARGET = "pass__depth_target";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_target( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__depth_target(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_target()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_TARGET = "stencil_target";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_TARGET = "pass__stencil_target";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_target( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__stencil_target(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_target()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR_CLEAR = "color_clear";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__COLOR_CLEAR = "pass__color_clear";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__color_clear( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__color_clear);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__color_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__color_clear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_CLEAR = "depth_clear";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_CLEAR = "pass__depth_clear";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_clear( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__depth_clear);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_clear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_CLEAR = "stencil_clear";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_CLEAR = "pass__stencil_clear";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_clear( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__stencil_clear);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_clear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DRAW = "draw";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DRAW = "pass__draw";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__draw( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__draw(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__draw( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__draw()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA_FUNC = "alpha_func";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__ALPHA_FUNC = "pass__alpha_func";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__alpha_func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FUNC = "func";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA_FUNC__FUNC = "alpha_func__func";

	//---------------------------------------------------------------------
	const alpha_func__func__AttributeData alpha_func__func__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"ALWAYS", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__alpha_func__func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		alpha_func__func__AttributeData* attributeData = newData<alpha_func__func__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__FUNC , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func__func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VALUE = "value";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA_FUNC__VALUE = "alpha_func__value";

	//---------------------------------------------------------------------
	const alpha_func__value__AttributeData alpha_func__value__AttributeData::DEFAULT = {0.0E1, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__alpha_func__value( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__alpha_func__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		alpha_func__value__AttributeData* attributeData = newData<alpha_func__value__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__VALUE, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__VALUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__alpha_func__value()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLEND_FUNC = "blend_func";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__BLEND_FUNC = "pass__blend_func";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blend_func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blend_func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SRC = "src";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLEND_FUNC__SRC = "blend_func__src";

	//---------------------------------------------------------------------
	const src__AttributeData src__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"ONE", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__src( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		src__AttributeData* attributeData = newData<src__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SRC , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__src()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEST = "dest";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLEND_FUNC__DEST = "blend_func__dest";

	//---------------------------------------------------------------------
	const dest__AttributeData dest__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"ZERO", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__dest( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		dest__AttributeData* attributeData = newData<dest__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEST , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__dest()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CLEAR_COLOR = "clear_color";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CLEAR_COLOR = "pass__clear_color";

	//---------------------------------------------------------------------
	const clear_color__AttributeData clear_color__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__clear_color( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__clear_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		clear_color__AttributeData* attributeData = newData<clear_color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__clear_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CLEAR_STENCIL = "clear_stencil";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CLEAR_STENCIL = "pass__clear_stencil";

	//---------------------------------------------------------------------
	const clear_stencil__AttributeData clear_stencil__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__clear_stencil( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__clear_stencil( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		clear_stencil__AttributeData* attributeData = newData<clear_stencil__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_STENCIL, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_STENCIL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__clear_stencil()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CLEAR_DEPTH = "clear_depth";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CLEAR_DEPTH = "pass__clear_depth";

	//---------------------------------------------------------------------
	const clear_depth__AttributeData clear_depth__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__clear_depth( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__clear_depth( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		clear_depth__AttributeData* attributeData = newData<clear_depth__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_DEPTH, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_DEPTH , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__clear_depth()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CLIP_PLANE = "clip_plane";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CLIP_PLANE = "pass__clip_plane";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_INDEX = "index";

	//---------------------------------------------------------------------
	const clip_plane__AttributeData clip_plane__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__clip_plane( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__clip_plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		clip_plane__AttributeData* attributeData = newData<clip_plane__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__clip_plane()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR_MASK = "color_mask";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__COLOR_MASK = "pass__color_mask";

	//---------------------------------------------------------------------
	const color_mask__AttributeData color_mask__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__color_mask( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		color_mask__AttributeData* attributeData = newData<color_mask__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MASK , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__color_mask()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CULL_FACE = "cull_face";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CULL_FACE = "pass__cull_face";

	//---------------------------------------------------------------------
	const cull_face__AttributeData cull_face__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"BACK", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cull_face( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		cull_face__AttributeData* attributeData = newData<cull_face__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cull_face()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_FUNC = "depth_func";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_FUNC = "pass__depth_func";

	//---------------------------------------------------------------------
	const depth_func__AttributeData depth_func__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"ALWAYS", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		depth_func__AttributeData* attributeData = newData<depth_func__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_FUNC , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_MASK = "depth_mask";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_MASK = "pass__depth_mask";

	//---------------------------------------------------------------------
	const depth_mask__AttributeData depth_mask__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_mask( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		depth_mask__AttributeData* attributeData = newData<depth_mask__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_MASK , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_mask()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_RANGE = "depth_range";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_RANGE = "pass__depth_range";

	//---------------------------------------------------------------------
	const depth_range__AttributeData depth_range__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_range( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		depth_range__AttributeData* attributeData = newData<depth_range__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_RANGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_range()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_COLOR = "fog_color";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_COLOR = "pass__fog_color";

	//---------------------------------------------------------------------
	const fog_color__AttributeData fog_color__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_color( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_color__AttributeData* attributeData = newData<fog_color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_DENSITY = "fog_density";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_DENSITY = "pass__fog_density";

	//---------------------------------------------------------------------
	const fog_density__AttributeData fog_density__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_density( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_density__AttributeData* attributeData = newData<fog_density__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_DENSITY, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_DENSITY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_density()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_MODE = "fog_mode";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_MODE = "pass__fog_mode";

	//---------------------------------------------------------------------
	const fog_mode__AttributeData fog_mode__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"EXP", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_mode( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_mode__AttributeData* attributeData = newData<fog_mode__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_MODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_mode()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_START = "fog_start";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_START = "pass__fog_start";

	//---------------------------------------------------------------------
	const fog_start__AttributeData fog_start__AttributeData::DEFAULT = {0.0E1, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_start( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_start__AttributeData* attributeData = newData<fog_start__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_START, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_START , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_start()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_END = "fog_end";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_END = "pass__fog_end";

	//---------------------------------------------------------------------
	const fog_end__AttributeData fog_end__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_end( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_end__AttributeData* attributeData = newData<fog_end__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_END, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_END , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_end()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FRONT_FACE = "front_face";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FRONT_FACE = "pass__front_face";

	//---------------------------------------------------------------------
	const front_face__AttributeData front_face__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"CCW", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__front_face( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		front_face__AttributeData* attributeData = newData<front_face__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FRONT_FACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__front_face()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__TEXTURE_PIPELINE = "pass__texture_pipeline";

	//---------------------------------------------------------------------
	const pass__texture_pipeline__AttributeData pass__texture_pipeline__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__pass__texture_pipeline( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__pass__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		pass__texture_pipeline__AttributeData* attributeData = newData<pass__texture_pipeline__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__TEXTURE_PIPELINE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__pass__texture_pipeline()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE__VALUE = "texture_pipeline__value";

	//---------------------------------------------------------------------
	const texture_pipeline__value__AttributeData texture_pipeline__value__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_pipeline__value( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture_pipeline__value__AttributeData* attributeData = newData<texture_pipeline__value__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__VALUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline__value()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VALUE__TEXCOMBINER = "value__texcombiner";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__value__texcombiner( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__value__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__value__texcombiner()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VALUE__TEXENV = "value__texenv";

	//---------------------------------------------------------------------
	const value__texenv__AttributeData value__texenv__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__value__texenv( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__value__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		value__texenv__AttributeData* attributeData = newData<value__texenv__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE__OPERATOR:
					{



						break;
					}
				case HASH_ATTRIBUTE_UNIT:
					{

						attributeData->unit = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VALUE__TEXENV , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__value__texenv()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VALUE__EXTRA = "value__extra";

	//---------------------------------------------------------------------
	const value__extra__AttributeData value__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__value__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__value__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		value__extra__AttributeData* attributeData = newData<value__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VALUE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__value__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LOGIC_OP = "logic_op";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LOGIC_OP = "pass__logic_op";

	//---------------------------------------------------------------------
	const logic_op__AttributeData logic_op__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"COPY", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__logic_op( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__logic_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		logic_op__AttributeData* attributeData = newData<logic_op__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LOGIC_OP , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__logic_op()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_AMBIENT = "light_ambient";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_AMBIENT = "pass__light_ambient";

	//---------------------------------------------------------------------
	const light_ambient__AttributeData light_ambient__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_ambient__AttributeData* attributeData = newData<light_ambient__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_DIFFUSE = "light_diffuse";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_DIFFUSE = "pass__light_diffuse";

	//---------------------------------------------------------------------
	const light_diffuse__AttributeData light_diffuse__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_diffuse( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_diffuse__AttributeData* attributeData = newData<light_diffuse__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_diffuse()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_SPECULAR = "light_specular";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_SPECULAR = "pass__light_specular";

	//---------------------------------------------------------------------
	const light_specular__AttributeData light_specular__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_specular( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_specular__AttributeData* attributeData = newData<light_specular__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_specular()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_POSITION = "light_position";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_POSITION = "pass__light_position";

	//---------------------------------------------------------------------
	const light_position__AttributeData light_position__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 1.0E0 0.0E1", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_position( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_position( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_position__AttributeData* attributeData = newData<light_position__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_position()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_CONSTANT_ATTENUATION = "light_constant_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_CONSTANT_ATTENUATION = "pass__light_constant_attenuation";

	//---------------------------------------------------------------------
	const light_constant_attenuation__AttributeData light_constant_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_constant_attenuation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_constant_attenuation__AttributeData* attributeData = newData<light_constant_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_constant_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_LINEAR_ATTENUTATION = "light_linear_attenutation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_LINEAR_ATTENUTATION = "pass__light_linear_attenutation";

	//---------------------------------------------------------------------
	const light_linear_attenutation__AttributeData light_linear_attenutation__AttributeData::DEFAULT = {1.0E0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_linear_attenutation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_linear_attenutation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_linear_attenutation__AttributeData* attributeData = newData<light_linear_attenutation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_linear_attenutation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_QUADRATIC_ATTENUATION = "light_quadratic_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_QUADRATIC_ATTENUATION = "pass__light_quadratic_attenuation";

	//---------------------------------------------------------------------
	const light_quadratic_attenuation__AttributeData light_quadratic_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_quadratic_attenuation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_quadratic_attenuation__AttributeData* attributeData = newData<light_quadratic_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_quadratic_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_SPOT_CUTOFF = "light_spot_cutoff";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_SPOT_CUTOFF = "pass__light_spot_cutoff";

	//---------------------------------------------------------------------
	const light_spot_cutoff__AttributeData light_spot_cutoff__AttributeData::DEFAULT = {1.8E2, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_spot_cutoff( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_cutoff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_spot_cutoff__AttributeData* attributeData = newData<light_spot_cutoff__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_cutoff()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_SPOT_DIRECTION = "light_spot_direction";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_SPOT_DIRECTION = "pass__light_spot_direction";

	//---------------------------------------------------------------------
	const light_spot_direction__AttributeData light_spot_direction__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 -1.0E0", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_spot_direction( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_spot_direction__AttributeData* attributeData = newData<light_spot_direction__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_direction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_SPOT_EXPONENT = "light_spot_exponent";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_SPOT_EXPONENT = "pass__light_spot_exponent";

	//---------------------------------------------------------------------
	const light_spot_exponent__AttributeData light_spot_exponent__AttributeData::DEFAULT = {0.0E1, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_spot_exponent( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_spot_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_spot_exponent__AttributeData* attributeData = newData<light_spot_exponent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_spot_exponent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_MODEL_AMBIENT = "light_model_ambient";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_MODEL_AMBIENT = "pass__light_model_ambient";

	//---------------------------------------------------------------------
	const light_model_ambient__AttributeData light_model_ambient__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"2.0E-1 2.0E-1 2.0E-1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_model_ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_model_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_model_ambient__AttributeData* attributeData = newData<light_model_ambient__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_AMBIENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_model_ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINE_WIDTH = "line_width";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LINE_WIDTH = "pass__line_width";

	//---------------------------------------------------------------------
	const line_width__AttributeData line_width__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__line_width( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		line_width__AttributeData* attributeData = newData<line_width__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_WIDTH, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_WIDTH , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__line_width()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL_AMBIENT = "material_ambient";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MATERIAL_AMBIENT = "pass__material_ambient";

	//---------------------------------------------------------------------
	const material_ambient__AttributeData material_ambient__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"2.0E-1 2.0E-1 2.0E-1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material_ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material_ambient__AttributeData* attributeData = newData<material_ambient__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_AMBIENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material_ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL_DIFFUSE = "material_diffuse";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MATERIAL_DIFFUSE = "pass__material_diffuse";

	//---------------------------------------------------------------------
	const material_diffuse__AttributeData material_diffuse__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"8.0E-1 8.0E-1 8.0E-1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material_diffuse( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material_diffuse__AttributeData* attributeData = newData<material_diffuse__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_DIFFUSE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material_diffuse()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL_EMISSION = "material_emission";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MATERIAL_EMISSION = "pass__material_emission";

	//---------------------------------------------------------------------
	const material_emission__AttributeData material_emission__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material_emission( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material_emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material_emission__AttributeData* attributeData = newData<material_emission__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_EMISSION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material_emission()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL_SHININESS = "material_shininess";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MATERIAL_SHININESS = "pass__material_shininess";

	//---------------------------------------------------------------------
	const material_shininess__AttributeData material_shininess__AttributeData::DEFAULT = {0.0E1, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material_shininess( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material_shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material_shininess__AttributeData* attributeData = newData<material_shininess__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SHININESS, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SHININESS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material_shininess()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL_SPECULAR = "material_specular";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MATERIAL_SPECULAR = "pass__material_specular";

	//---------------------------------------------------------------------
	const material_specular__AttributeData material_specular__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material_specular( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material_specular__AttributeData* attributeData = newData<material_specular__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SPECULAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material_specular()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MODEL_VIEW_MATRIX = "model_view_matrix";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MODEL_VIEW_MATRIX = "pass__model_view_matrix";

	//---------------------------------------------------------------------
	const model_view_matrix__AttributeData model_view_matrix__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__model_view_matrix( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__model_view_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		model_view_matrix__AttributeData* attributeData = newData<model_view_matrix__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MODEL_VIEW_MATRIX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__model_view_matrix()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_DISTANCE_ATTENUATION = "point_distance_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_DISTANCE_ATTENUATION = "pass__point_distance_attenuation";

	//---------------------------------------------------------------------
	const point_distance_attenuation__AttributeData point_distance_attenuation__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"1.0E0 0.0E1 0.0E1", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_distance_attenuation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_distance_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_distance_attenuation__AttributeData* attributeData = newData<point_distance_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_DISTANCE_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_distance_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_FADE_THRESHOLD_SIZE = "point_fade_threshold_size";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_FADE_THRESHOLD_SIZE = "pass__point_fade_threshold_size";

	//---------------------------------------------------------------------
	const point_fade_threshold_size__AttributeData point_fade_threshold_size__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_fade_threshold_size( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_fade_threshold_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_fade_threshold_size__AttributeData* attributeData = newData<point_fade_threshold_size__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_fade_threshold_size()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_SIZE = "point_size";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_SIZE = "pass__point_size";

	//---------------------------------------------------------------------
	const point_size__AttributeData point_size__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_size( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_size__AttributeData* attributeData = newData<point_size__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_size()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_SIZE_MIN = "point_size_min";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_SIZE_MIN = "pass__point_size_min";

	//---------------------------------------------------------------------
	const point_size_min__AttributeData point_size_min__AttributeData::DEFAULT = {0.0E1, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_size_min( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_size_min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_size_min__AttributeData* attributeData = newData<point_size_min__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MIN, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MIN , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_size_min()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_SIZE_MAX = "point_size_max";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_SIZE_MAX = "pass__point_size_max";

	//---------------------------------------------------------------------
	const point_size_max__AttributeData point_size_max__AttributeData::DEFAULT = {1.0E0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_size_max( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_size_max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_size_max__AttributeData* attributeData = newData<point_size_max__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MAX, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MAX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_size_max()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGON_OFFSET = "polygon_offset";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POLYGON_OFFSET = "pass__polygon_offset";

	//---------------------------------------------------------------------
	const polygon_offset__AttributeData polygon_offset__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"0.0E1 0.0E1", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygon_offset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polygon_offset__AttributeData* attributeData = newData<polygon_offset__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygon_offset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROJECTION_MATRIX = "projection_matrix";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__PROJECTION_MATRIX = "pass__projection_matrix";

	//---------------------------------------------------------------------
	const projection_matrix__AttributeData projection_matrix__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__projection_matrix( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__projection_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		projection_matrix__AttributeData* attributeData = newData<projection_matrix__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROJECTION_MATRIX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__projection_matrix()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCISSOR = "scissor";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SCISSOR = "pass__scissor";

	//---------------------------------------------------------------------
	const scissor__AttributeData scissor__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__scissor( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		scissor__AttributeData* attributeData = newData<scissor__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__scissor()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHADE_MODEL = "shade_model";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SHADE_MODEL = "pass__shade_model";

	//---------------------------------------------------------------------
	const shade_model__AttributeData shade_model__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"SMOOTH", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shade_model( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shade_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shade_model__AttributeData* attributeData = newData<shade_model__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHADE_MODEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shade_model()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_FUNC = "stencil_func";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_FUNC = "pass__stencil_func";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_FUNC__FUNC = "stencil_func__func";

	//---------------------------------------------------------------------
	const stencil_func__func__AttributeData stencil_func__func__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"ALWAYS", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_func__func( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_func__func__AttributeData* attributeData = newData<stencil_func__func__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__FUNC , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__func()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REF = "ref";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_FUNC__REF = "stencil_func__ref";

	//---------------------------------------------------------------------
	const stencil_func__ref__AttributeData stencil_func__ref__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_func__ref( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_func__ref__AttributeData* attributeData = newData<stencil_func__ref__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__REF, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__REF , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__ref()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MASK = "mask";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_FUNC__MASK = "stencil_func__mask";

	//---------------------------------------------------------------------
	const stencil_func__mask__AttributeData stencil_func__mask__AttributeData::DEFAULT = {255, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_func__mask( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_func__mask__AttributeData* attributeData = newData<stencil_func__mask__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__MASK , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_func__mask()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_MASK = "stencil_mask";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_MASK = "pass__stencil_mask";

	//---------------------------------------------------------------------
	const stencil_mask__AttributeData stencil_mask__AttributeData::DEFAULT = {4294967295, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_mask( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_mask__AttributeData* attributeData = newData<stencil_mask__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{
						bool failed;
						attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_MASK , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_mask()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_OP = "stencil_op";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_OP = "pass__stencil_op";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_op( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FAIL = "fail";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_OP__FAIL = "stencil_op__fail";

	//---------------------------------------------------------------------
	const stencil_op__fail__AttributeData stencil_op__fail__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"KEEP", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_op__fail( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_op__fail__AttributeData* attributeData = newData<stencil_op__fail__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__FAIL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__fail()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ZFAIL = "zfail";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_OP__ZFAIL = "stencil_op__zfail";

	//---------------------------------------------------------------------
	const stencil_op__zfail__AttributeData stencil_op__zfail__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"KEEP", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_op__zfail( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_op__zfail__AttributeData* attributeData = newData<stencil_op__zfail__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZFAIL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__zfail()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ZPASS = "zpass";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_OP__ZPASS = "stencil_op__zpass";

	//---------------------------------------------------------------------
	const stencil_op__zpass__AttributeData stencil_op__zpass__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"KEEP", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_op__zpass( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_op__zpass__AttributeData* attributeData = newData<stencil_op__zpass__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZPASS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_op__zpass()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ALPHA_TEST_ENABLE = "alpha_test_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__ALPHA_TEST_ENABLE = "pass__alpha_test_enable";

	//---------------------------------------------------------------------
	const alpha_test_enable__AttributeData alpha_test_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__alpha_test_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__alpha_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		alpha_test_enable__AttributeData* attributeData = newData<alpha_test_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_TEST_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__alpha_test_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLEND_ENABLE = "blend_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__BLEND_ENABLE = "pass__blend_enable";

	//---------------------------------------------------------------------
	const blend_enable__AttributeData blend_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blend_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		blend_enable__AttributeData* attributeData = newData<blend_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLEND_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blend_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CLIP_PLANE_ENABLE = "clip_plane_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CLIP_PLANE_ENABLE = "pass__clip_plane_enable";

	//---------------------------------------------------------------------
	const clip_plane_enable__AttributeData clip_plane_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__clip_plane_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__clip_plane_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		clip_plane_enable__AttributeData* attributeData = newData<clip_plane_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__clip_plane_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR_LOGIC_OP_ENABLE = "color_logic_op_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__COLOR_LOGIC_OP_ENABLE = "pass__color_logic_op_enable";

	//---------------------------------------------------------------------
	const color_logic_op_enable__AttributeData color_logic_op_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__color_logic_op_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__color_logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		color_logic_op_enable__AttributeData* attributeData = newData<color_logic_op_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__color_logic_op_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR_MATERIAL_ENABLE = "color_material_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__COLOR_MATERIAL_ENABLE = "pass__color_material_enable";

	//---------------------------------------------------------------------
	const color_material_enable__AttributeData color_material_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"true", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__color_material_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__color_material_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		color_material_enable__AttributeData* attributeData = newData<color_material_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MATERIAL_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__color_material_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CULL_FACE_ENABLE = "cull_face_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__CULL_FACE_ENABLE = "pass__cull_face_enable";

	//---------------------------------------------------------------------
	const cull_face_enable__AttributeData cull_face_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cull_face_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		cull_face_enable__AttributeData* attributeData = newData<cull_face_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cull_face_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DEPTH_TEST_ENABLE = "depth_test_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DEPTH_TEST_ENABLE = "pass__depth_test_enable";

	//---------------------------------------------------------------------
	const depth_test_enable__AttributeData depth_test_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__depth_test_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		depth_test_enable__AttributeData* attributeData = newData<depth_test_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_TEST_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__depth_test_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DITHER_ENABLE = "dither_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__DITHER_ENABLE = "pass__dither_enable";

	//---------------------------------------------------------------------
	const dither_enable__AttributeData dither_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__dither_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		dither_enable__AttributeData* attributeData = newData<dither_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DITHER_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__dither_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FOG_ENABLE = "fog_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__FOG_ENABLE = "pass__fog_enable";

	//---------------------------------------------------------------------
	const fog_enable__AttributeData fog_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fog_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fog_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		fog_enable__AttributeData* attributeData = newData<fog_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fog_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE_PIPELINE_ENABLE = "texture_pipeline_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__TEXTURE_PIPELINE_ENABLE = "pass__texture_pipeline_enable";

	//---------------------------------------------------------------------
	const texture_pipeline_enable__AttributeData texture_pipeline_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture_pipeline_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture_pipeline_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture_pipeline_enable__AttributeData* attributeData = newData<texture_pipeline_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture_pipeline_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_ENABLE = "light_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_ENABLE = "pass__light_enable";

	//---------------------------------------------------------------------
	const light_enable__AttributeData light_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_enable__AttributeData* attributeData = newData<light_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INDEX:
					{
						bool failed;
						attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHTING_ENABLE = "lighting_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHTING_ENABLE = "pass__lighting_enable";

	//---------------------------------------------------------------------
	const lighting_enable__AttributeData lighting_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lighting_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lighting_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lighting_enable__AttributeData* attributeData = newData<lighting_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHTING_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lighting_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE = "light_model_two_side_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LIGHT_MODEL_TWO_SIDE_ENABLE = "pass__light_model_two_side_enable";

	//---------------------------------------------------------------------
	const light_model_two_side_enable__AttributeData light_model_two_side_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light_model_two_side_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light_model_two_side_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light_model_two_side_enable__AttributeData* attributeData = newData<light_model_two_side_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light_model_two_side_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINE_SMOOTH_ENABLE = "line_smooth_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__LINE_SMOOTH_ENABLE = "pass__line_smooth_enable";

	//---------------------------------------------------------------------
	const line_smooth_enable__AttributeData line_smooth_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__line_smooth_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__line_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		line_smooth_enable__AttributeData* attributeData = newData<line_smooth_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_SMOOTH_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__line_smooth_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MULTISAMPLE_ENABLE = "multisample_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__MULTISAMPLE_ENABLE = "pass__multisample_enable";

	//---------------------------------------------------------------------
	const multisample_enable__AttributeData multisample_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__multisample_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__multisample_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		multisample_enable__AttributeData* attributeData = newData<multisample_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MULTISAMPLE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__multisample_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NORMALIZE_ENABLE = "normalize_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__NORMALIZE_ENABLE = "pass__normalize_enable";

	//---------------------------------------------------------------------
	const normalize_enable__AttributeData normalize_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__normalize_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__normalize_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		normalize_enable__AttributeData* attributeData = newData<normalize_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NORMALIZE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__normalize_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT_SMOOTH_ENABLE = "point_smooth_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POINT_SMOOTH_ENABLE = "pass__point_smooth_enable";

	//---------------------------------------------------------------------
	const point_smooth_enable__AttributeData point_smooth_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point_smooth_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point_smooth_enable__AttributeData* attributeData = newData<point_smooth_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SMOOTH_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point_smooth_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGON_OFFSET_FILL_ENABLE = "polygon_offset_fill_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__POLYGON_OFFSET_FILL_ENABLE = "pass__polygon_offset_fill_enable";

	//---------------------------------------------------------------------
	const polygon_offset_fill_enable__AttributeData polygon_offset_fill_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polygon_offset_fill_enable__AttributeData* attributeData = newData<polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygon_offset_fill_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RESCALE_NORMAL_ENABLE = "rescale_normal_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__RESCALE_NORMAL_ENABLE = "pass__rescale_normal_enable";

	//---------------------------------------------------------------------
	const rescale_normal_enable__AttributeData rescale_normal_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rescale_normal_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rescale_normal_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rescale_normal_enable__AttributeData* attributeData = newData<rescale_normal_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RESCALE_NORMAL_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rescale_normal_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "sample_alpha_to_coverage_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SAMPLE_ALPHA_TO_COVERAGE_ENABLE = "pass__sample_alpha_to_coverage_enable";

	//---------------------------------------------------------------------
	const sample_alpha_to_coverage_enable__AttributeData sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sample_alpha_to_coverage_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE = "sample_alpha_to_one_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SAMPLE_ALPHA_TO_ONE_ENABLE = "pass__sample_alpha_to_one_enable";

	//---------------------------------------------------------------------
	const sample_alpha_to_one_enable__AttributeData sample_alpha_to_one_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sample_alpha_to_one_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sample_alpha_to_one_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sample_alpha_to_one_enable__AttributeData* attributeData = newData<sample_alpha_to_one_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sample_alpha_to_one_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SAMPLE_COVERAGE_ENABLE = "sample_coverage_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SAMPLE_COVERAGE_ENABLE = "pass__sample_coverage_enable";

	//---------------------------------------------------------------------
	const sample_coverage_enable__AttributeData sample_coverage_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sample_coverage_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sample_coverage_enable__AttributeData* attributeData = newData<sample_coverage_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sample_coverage_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCISSOR_TEST_ENABLE = "scissor_test_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__SCISSOR_TEST_ENABLE = "pass__scissor_test_enable";

	//---------------------------------------------------------------------
	const scissor_test_enable__AttributeData scissor_test_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__scissor_test_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		scissor_test_enable__AttributeData* attributeData = newData<scissor_test_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR_TEST_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__scissor_test_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STENCIL_TEST_ENABLE = "stencil_test_enable";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__STENCIL_TEST_ENABLE = "pass__stencil_test_enable";

	//---------------------------------------------------------------------
	const stencil_test_enable__AttributeData stencil_test_enable__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__stencil_test_enable( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		stencil_test_enable__AttributeData* attributeData = newData<stencil_test_enable__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VALUE:
					{



						break;
					}
				case HASH_ATTRIBUTE_PARAM:
					{

						attributeData->param = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_TEST_ENABLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__stencil_test_enable()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__EXTRA = "pass__extra";

	//---------------------------------------------------------------------
	const pass__extra__AttributeData pass__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__pass__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__pass__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		pass__extra__AttributeData* attributeData = newData<pass__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__pass__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__EXTRA = "technique__extra";

	//---------------------------------------------------------------------
	const technique__extra__AttributeData technique__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__extra__AttributeData* attributeData = newData<technique__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLES__EXTRA = "profile_GLES__extra";

	//---------------------------------------------------------------------
	const profile_GLES__extra__AttributeData profile_GLES__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLES__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLES__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLES__extra__AttributeData* attributeData = newData<profile_GLES__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLES__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FX_PROFILE_ABSTRACT = "fx_profile_abstract";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__FX_PROFILE_ABSTRACT = "effect__fx_profile_abstract";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__fx_profile_abstract( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__fx_profile_abstract(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__fx_profile_abstract( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__fx_profile_abstract()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH = "mesh";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY__MESH = "geometry__mesh";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__SOURCE = "mesh__source";

	//---------------------------------------------------------------------
	const mesh__source__AttributeData mesh__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__source__AttributeData* attributeData = newData<mesh__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTICES = "vertices";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__VERTICES = "mesh__vertices";

	//---------------------------------------------------------------------
	const mesh__vertices__AttributeData mesh__vertices__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__vertices( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__vertices__AttributeData* attributeData = newData<mesh__vertices__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__VERTICES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__vertices()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTICES__INPUT = "vertices__input";

	//---------------------------------------------------------------------
	const vertices__input__AttributeData vertices__input__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertices__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertices__input__AttributeData* attributeData = newData<vertices__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertices__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTICES__EXTRA = "vertices__extra";

	//---------------------------------------------------------------------
	const vertices__extra__AttributeData vertices__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertices__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertices__extra__AttributeData* attributeData = newData<vertices__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertices__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINES = "lines";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__LINES = "mesh__lines";

	//---------------------------------------------------------------------
	const mesh__lines__AttributeData mesh__lines__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__lines( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__lines__AttributeData* attributeData = newData<mesh__lines__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__lines()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINES__INPUT = "lines__input";

	//---------------------------------------------------------------------
	const lines__input__AttributeData lines__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lines__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lines__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lines__input__AttributeData* attributeData = newData<lines__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lines__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINES__P = "lines__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lines__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__lines__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lines__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lines__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINES__EXTRA = "lines__extra";

	//---------------------------------------------------------------------
	const lines__extra__AttributeData lines__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lines__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lines__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lines__extra__AttributeData* attributeData = newData<lines__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lines__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINESTRIPS = "linestrips";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__LINESTRIPS = "mesh__linestrips";

	//---------------------------------------------------------------------
	const mesh__linestrips__AttributeData mesh__linestrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__linestrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__linestrips__AttributeData* attributeData = newData<mesh__linestrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINESTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__linestrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINESTRIPS__INPUT = "linestrips__input";

	//---------------------------------------------------------------------
	const linestrips__input__AttributeData linestrips__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linestrips__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linestrips__input__AttributeData* attributeData = newData<linestrips__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINESTRIPS__P = "linestrips__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linestrips__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linestrips__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINESTRIPS__EXTRA = "linestrips__extra";

	//---------------------------------------------------------------------
	const linestrips__extra__AttributeData linestrips__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linestrips__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linestrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linestrips__extra__AttributeData* attributeData = newData<linestrips__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linestrips__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGONS = "polygons";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__POLYGONS = "mesh__polygons";

	//---------------------------------------------------------------------
	const mesh__polygons__AttributeData mesh__polygons__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__polygons( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__polygons__AttributeData* attributeData = newData<mesh__polygons__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYGONS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__polygons()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGONS__INPUT = "polygons__input";

	//---------------------------------------------------------------------
	const polygons__input__AttributeData polygons__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygons__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygons__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polygons__input__AttributeData* attributeData = newData<polygons__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygons__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGONS__P = "polygons__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygons__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__polygons__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygons__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygons__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PH = "ph";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGONS__PH = "polygons__ph";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ph( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ph()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PH__P = "ph__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ph__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ph__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ph__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ph__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_H = "h";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PH__H = "ph__h";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__h( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__h);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__h( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__h()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYGONS__EXTRA = "polygons__extra";

	//---------------------------------------------------------------------
	const polygons__extra__AttributeData polygons__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygons__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygons__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polygons__extra__AttributeData* attributeData = newData<polygons__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygons__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYLIST = "polylist";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__POLYLIST = "mesh__polylist";

	//---------------------------------------------------------------------
	const mesh__polylist__AttributeData mesh__polylist__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__polylist( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__polylist__AttributeData* attributeData = newData<mesh__polylist__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYLIST , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__polylist()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYLIST__INPUT = "polylist__input";

	//---------------------------------------------------------------------
	const polylist__input__AttributeData polylist__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polylist__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polylist__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polylist__input__AttributeData* attributeData = newData<polylist__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polylist__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VCOUNT = "vcount";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYLIST__VCOUNT = "polylist__vcount";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polylist__vcount( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__polylist__vcount);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polylist__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polylist__vcount()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYLIST__P = "polylist__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polylist__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__polylist__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polylist__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polylist__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POLYLIST__EXTRA = "polylist__extra";

	//---------------------------------------------------------------------
	const polylist__extra__AttributeData polylist__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polylist__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polylist__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polylist__extra__AttributeData* attributeData = newData<polylist__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polylist__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIANGLES = "triangles";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__TRIANGLES = "mesh__triangles";

	//---------------------------------------------------------------------
	const mesh__triangles__AttributeData mesh__triangles__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__triangles( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__triangles__AttributeData* attributeData = newData<mesh__triangles__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIANGLES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__triangles()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIANGLES__INPUT = "triangles__input";

	//---------------------------------------------------------------------
	const triangles__input__AttributeData triangles__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__triangles__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__triangles__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		triangles__input__AttributeData* attributeData = newData<triangles__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__triangles__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIANGLES__P = "triangles__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__triangles__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__triangles__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__triangles__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__triangles__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRIANGLES__EXTRA = "triangles__extra";

	//---------------------------------------------------------------------
	const triangles__extra__AttributeData triangles__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__triangles__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__triangles__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		triangles__extra__AttributeData* attributeData = newData<triangles__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__triangles__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const mesh__trifans__AttributeData mesh__trifans__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__trifans( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__trifans__AttributeData* attributeData = newData<mesh__trifans__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIFANS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__trifans()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRISTRIPS = "tristrips";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__TRISTRIPS = "mesh__tristrips";

	//---------------------------------------------------------------------
	const mesh__tristrips__AttributeData mesh__tristrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__tristrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__tristrips__AttributeData* attributeData = newData<mesh__tristrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRISTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__tristrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRISTRIPS__INPUT = "tristrips__input";

	//---------------------------------------------------------------------
	const tristrips__input__AttributeData tristrips__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tristrips__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		tristrips__input__AttributeData* attributeData = newData<tristrips__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRISTRIPS__P = "tristrips__p";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tristrips__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tristrips__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRISTRIPS__EXTRA = "tristrips__extra";

	//---------------------------------------------------------------------
	const tristrips__extra__AttributeData tristrips__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tristrips__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tristrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		tristrips__extra__AttributeData* attributeData = newData<tristrips__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tristrips__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MESH__EXTRA = "mesh__extra";

	//---------------------------------------------------------------------
	const mesh__extra__AttributeData mesh__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mesh__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mesh__extra__AttributeData* attributeData = newData<mesh__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mesh__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const lines__AttributeData lines__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lines( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lines__AttributeData* attributeData = newData<lines__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lines()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_NODE = "instance_node";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__INSTANCE_NODE = "node__instance_node";

	//---------------------------------------------------------------------
	const instance_node__AttributeData instance_node__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_node( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_node__AttributeData* attributeData = newData<instance_node__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_NODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_node()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_NODE__EXTRA = "instance_node__extra";

	//---------------------------------------------------------------------
	const instance_node__extra__AttributeData instance_node__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_node__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_node__extra__AttributeData* attributeData = newData<instance_node__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_NODE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_node__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VISUAL_SCENE = "visual_scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__VISUAL_SCENE = "library_visual_scenes__visual_scene";

	//---------------------------------------------------------------------
	const visual_scene__AttributeData visual_scene__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__visual_scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		visual_scene__AttributeData* attributeData = newData<visual_scene__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VISUAL_SCENE__ASSET = "visual_scene__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__visual_scene__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE = "node";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VISUAL_SCENE__NODE = "visual_scene__node";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_LAYER = "layer";

	//---------------------------------------------------------------------
	const visual_scene__node__AttributeData visual_scene__node__AttributeData::DEFAULT = {0, 0, 0, (const GeneratedSaxParser::ParserChar *)"NODE", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__visual_scene__node( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		visual_scene__node__AttributeData* attributeData = newData<visual_scene__node__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				case HASH_ATTRIBUTE_LAYER:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE__NODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__node()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__ASSET = "node__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LOOKAT = "lookat";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__LOOKAT = "node__lookat";

	//---------------------------------------------------------------------
	const lookat__AttributeData lookat__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lookat( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__lookat);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lookat( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lookat__AttributeData* attributeData = newData<lookat__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LOOKAT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lookat()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATRIX = "matrix";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__MATRIX = "node__matrix";

	//---------------------------------------------------------------------
	const matrix__AttributeData matrix__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__matrix( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__matrix);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		matrix__AttributeData* attributeData = newData<matrix__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATRIX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__matrix()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ROTATE = "rotate";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__ROTATE = "node__rotate";

	//---------------------------------------------------------------------
	const node__rotate__AttributeData node__rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__node__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		node__rotate__AttributeData* attributeData = newData<node__rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCALE = "scale";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__SCALE = "node__scale";

	//---------------------------------------------------------------------
	const scale__AttributeData scale__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__scale( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__scale);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__scale( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		scale__AttributeData* attributeData = newData<scale__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCALE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__scale()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKEW = "skew";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__SKEW = "node__skew";

	//---------------------------------------------------------------------
	const skew__AttributeData skew__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__skew( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__skew);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__skew( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		skew__AttributeData* attributeData = newData<skew__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKEW , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__skew()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSLATE = "translate";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__TRANSLATE = "node__translate";

	//---------------------------------------------------------------------
	const node__translate__AttributeData node__translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__node__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		node__translate__AttributeData* attributeData = newData<node__translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node__translate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CAMERA = "instance_camera";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__INSTANCE_CAMERA = "node__instance_camera";

	//---------------------------------------------------------------------
	const instance_camera__AttributeData instance_camera__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_camera( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_camera__AttributeData* attributeData = newData<instance_camera__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CAMERA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_camera()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CAMERA__EXTRA = "instance_camera__extra";

	//---------------------------------------------------------------------
	const instance_camera__extra__AttributeData instance_camera__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_camera__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_camera__extra__AttributeData* attributeData = newData<instance_camera__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CAMERA__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_camera__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CONTROLLER = "instance_controller";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__INSTANCE_CONTROLLER = "node__instance_controller";

	//---------------------------------------------------------------------
	const instance_controller__AttributeData instance_controller__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_controller( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_controller__AttributeData* attributeData = newData<instance_controller__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CONTROLLER , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKELETON = "skeleton";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CONTROLLER__SKELETON = "instance_controller__skeleton";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__skeleton( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__skeleton(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__skeleton( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__skeleton()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_MATERIAL = "bind_material";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CONTROLLER__BIND_MATERIAL = "instance_controller__bind_material";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_controller__bind_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller__bind_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_MATERIAL__PARAM = "bind_material__param";

	//---------------------------------------------------------------------
	const bind_material__param__AttributeData bind_material__param__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_material__param( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__bind_material__param(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		bind_material__param__AttributeData* attributeData = newData<bind_material__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_MATERIAL__TECHNIQUE_COMMON = "bind_material__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_material__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_MATERIAL = "instance_material";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__INSTANCE_MATERIAL = "technique_common__instance_material";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_SYMBOL = "symbol";

	//---------------------------------------------------------------------
	const instance_material__AttributeData instance_material__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_material__AttributeData* attributeData = newData<instance_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SYMBOL:
					{

						attributeData->symbol = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TARGET:
					{

						attributeData->target = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND = "bind";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_MATERIAL__BIND = "instance_material__bind";

	//---------------------------------------------------------------------
	const instance_material__bind__AttributeData instance_material__bind__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_material__bind( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_material__bind( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_material__bind__AttributeData* attributeData = newData<instance_material__bind__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TARGET:
					{

						attributeData->target = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL__BIND , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_material__bind()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_VERTEX_INPUT = "bind_vertex_input";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_MATERIAL__BIND_VERTEX_INPUT = "instance_material__bind_vertex_input";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_INPUT_SEMANTIC = "input_semantic";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_INPUT_SET = "input_set";

	//---------------------------------------------------------------------
	const bind_vertex_input__AttributeData bind_vertex_input__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_vertex_input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_vertex_input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		bind_vertex_input__AttributeData* attributeData = newData<bind_vertex_input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INPUT_SEMANTIC:
					{

						attributeData->input_semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_INPUT_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_VERTEX_INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_vertex_input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_MATERIAL__EXTRA = "instance_material__extra";

	//---------------------------------------------------------------------
	const instance_material__extra__AttributeData instance_material__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_material__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_material__extra__AttributeData* attributeData = newData<instance_material__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_material__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_MATERIAL__TECHNIQUE = "bind_material__technique";

	//---------------------------------------------------------------------
	const bind_material__technique__AttributeData bind_material__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_material__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		bind_material__technique__AttributeData* attributeData = newData<bind_material__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_MATERIAL__EXTRA = "bind_material__extra";

	//---------------------------------------------------------------------
	const bind_material__extra__AttributeData bind_material__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_material__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		bind_material__extra__AttributeData* attributeData = newData<bind_material__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_material__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_CONTROLLER__EXTRA = "instance_controller__extra";

	//---------------------------------------------------------------------
	const instance_controller__extra__AttributeData instance_controller__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_controller__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_controller__extra__AttributeData* attributeData = newData<instance_controller__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CONTROLLER__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_controller__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_GEOMETRY = "instance_geometry";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__INSTANCE_GEOMETRY = "node__instance_geometry";

	//---------------------------------------------------------------------
	const node__instance_geometry__AttributeData node__instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node__instance_geometry( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		node__instance_geometry__AttributeData* attributeData = newData<node__instance_geometry__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__INSTANCE_GEOMETRY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node__instance_geometry()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_GEOMETRY__BIND_MATERIAL = "instance_geometry__bind_material";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_geometry__bind_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_geometry__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_geometry__bind_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_GEOMETRY__EXTRA = "instance_geometry__extra";

	//---------------------------------------------------------------------
	const instance_geometry__extra__AttributeData instance_geometry__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_geometry__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_geometry__extra__AttributeData* attributeData = newData<instance_geometry__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_GEOMETRY__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_geometry__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_LIGHT = "instance_light";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__INSTANCE_LIGHT = "node__instance_light";

	//---------------------------------------------------------------------
	const instance_light__AttributeData instance_light__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_light( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_light__AttributeData* attributeData = newData<instance_light__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_LIGHT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_light()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_LIGHT__EXTRA = "instance_light__extra";

	//---------------------------------------------------------------------
	const instance_light__extra__AttributeData instance_light__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_light__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_light__extra__AttributeData* attributeData = newData<instance_light__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_LIGHT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_light__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NODE__EXTRA = "node__extra";

	//---------------------------------------------------------------------
	const node__extra__AttributeData node__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		node__extra__AttributeData* attributeData = newData<node__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EVALUATE_SCENE = "evaluate_scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VISUAL_SCENE__EVALUATE_SCENE = "visual_scene__evaluate_scene";

	//---------------------------------------------------------------------
	const evaluate_scene__AttributeData evaluate_scene__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__evaluate_scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__evaluate_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		evaluate_scene__AttributeData* attributeData = newData<evaluate_scene__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EVALUATE_SCENE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__evaluate_scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RENDER = "render";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EVALUATE_SCENE__RENDER = "evaluate_scene__render";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_CAMERA_NODE = "camera_node";

	//---------------------------------------------------------------------
	const render__AttributeData render__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__render( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__render( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		render__AttributeData* attributeData = newData<render__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_CAMERA_NODE:
					{

						attributeData->camera_node = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RENDER , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__render()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAYER = "layer";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RENDER__LAYER = "render__layer";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__layer( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__layer(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__layer( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__layer()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const render__instance_effect__AttributeData render__instance_effect__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__render__instance_effect( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__render__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		render__instance_effect__AttributeData* attributeData = newData<render__instance_effect__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RENDER__INSTANCE_EFFECT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__render__instance_effect()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VISUAL_SCENE__EXTRA = "visual_scene__extra";

	//---------------------------------------------------------------------
	const visual_scene__extra__AttributeData visual_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__visual_scene__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		visual_scene__extra__AttributeData* attributeData = newData<visual_scene__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__visual_scene__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL = "material";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_MATERIALS__MATERIAL = "library_materials__material";

	//---------------------------------------------------------------------
	const material__AttributeData material__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material__AttributeData* attributeData = newData<material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL__ASSET = "material__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL__INSTANCE_EFFECT = "material__instance_effect";

	//---------------------------------------------------------------------
	const material__instance_effect__AttributeData material__instance_effect__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material__instance_effect( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material__instance_effect__AttributeData* attributeData = newData<material__instance_effect__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL__INSTANCE_EFFECT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material__instance_effect()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MATERIAL__EXTRA = "material__extra";

	//---------------------------------------------------------------------
	const material__extra__AttributeData material__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__material__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		material__extra__AttributeData* attributeData = newData<material__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__material__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAPSULE = "capsule";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__CAPSULE = "shape__capsule";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__capsule( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__capsule()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HEIGHT = "height";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAPSULE__HEIGHT = "capsule__height";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__capsule__height( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__capsule__height);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__capsule__height()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RADIUS = "radius";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAPSULE__RADIUS = "capsule__radius";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__capsule__radius( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__capsule__radius);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__capsule__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__capsule__radius()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAPSULE__EXTRA = "capsule__extra";

	//---------------------------------------------------------------------
	const capsule__extra__AttributeData capsule__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__capsule__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		capsule__extra__AttributeData* attributeData = newData<capsule__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAPSULE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__capsule__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__p( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__p);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__p()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ELLIPSOID = "ellipsoid";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ellipsoid( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ellipsoid( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ellipsoid()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ELLIPSOID__SIZE = "ellipsoid__size";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ellipsoid__size( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ellipsoid__size);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ellipsoid__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ellipsoid__size()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES = "library_physics_scenes";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_SCENES = "COLLADA__library_physics_scenes";

	//---------------------------------------------------------------------
	const library_physics_scenes__AttributeData library_physics_scenes__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_scenes( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_scenes__AttributeData* attributeData = newData<library_physics_scenes__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_SCENES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__ASSET = "library_physics_scenes__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_scenes__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE = "physics_scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__PHYSICS_SCENE = "library_physics_scenes__physics_scene";

	//---------------------------------------------------------------------
	const physics_scene__AttributeData physics_scene__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_scene__AttributeData* attributeData = newData<physics_scene__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__ASSET = "physics_scene__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_FORCE_FIELD = "instance_force_field";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__INSTANCE_FORCE_FIELD = "physics_scene__instance_force_field";

	//---------------------------------------------------------------------
	const physics_scene__instance_force_field__AttributeData physics_scene__instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__instance_force_field( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_scene__instance_force_field__AttributeData* attributeData = newData<physics_scene__instance_force_field__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_FORCE_FIELD , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__instance_force_field()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_FORCE_FIELD__EXTRA = "instance_force_field__extra";

	//---------------------------------------------------------------------
	const instance_force_field__extra__AttributeData instance_force_field__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_force_field__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_force_field__extra__AttributeData* attributeData = newData<instance_force_field__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_FORCE_FIELD__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_force_field__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL = "instance_physics_model";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__INSTANCE_PHYSICS_MODEL = "physics_scene__instance_physics_model";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_PARENT = "parent";

	//---------------------------------------------------------------------
	const physics_scene__instance_physics_model__AttributeData physics_scene__instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__instance_physics_model( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_scene__instance_physics_model__AttributeData* attributeData = newData<physics_scene__instance_physics_model__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PARENT:
					{

						attributeData->parent = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_PHYSICS_MODEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__instance_physics_model()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_FORCE_FIELD = "instance_physics_model__instance_force_field";

	//---------------------------------------------------------------------
	const instance_physics_model__instance_force_field__AttributeData instance_physics_model__instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_model__instance_force_field( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_model__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_model__instance_force_field__AttributeData* attributeData = newData<instance_physics_model__instance_force_field__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_FORCE_FIELD , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_model__instance_force_field()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_BODY = "instance_rigid_body";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_RIGID_BODY = "instance_physics_model__instance_rigid_body";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_BODY = "body";

	//---------------------------------------------------------------------
	const instance_rigid_body__AttributeData instance_rigid_body__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_body( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_rigid_body__AttributeData* attributeData = newData<instance_rigid_body__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_BODY:
					{

						attributeData->body = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TARGET:
					{

						attributeData->target = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE_COMMON = "instance_rigid_body__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANGULAR_VELOCITY = "angular_velocity";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__ANGULAR_VELOCITY = "technique_common__angular_velocity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__angular_velocity( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__angular_velocity);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__angular_velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__angular_velocity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VELOCITY = "velocity";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__VELOCITY = "technique_common__velocity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__velocity( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__velocity);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__velocity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DYNAMIC = "dynamic";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__DYNAMIC = "technique_common__dynamic";

	//---------------------------------------------------------------------
	const dynamic__AttributeData dynamic__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__dynamic( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__dynamic);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__dynamic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		dynamic__AttributeData* attributeData = newData<dynamic__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DYNAMIC , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__dynamic()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MASS = "mass";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__MASS = "technique_common__mass";

	//---------------------------------------------------------------------
	const technique_common__mass__AttributeData technique_common__mass__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique_common__mass( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__technique_common__mass);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique_common__mass__AttributeData* attributeData = newData<technique_common__mass__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__MASS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__mass()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MASS_FRAME = "mass_frame";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__MASS_FRAME = "technique_common__mass_frame";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mass_frame( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MASS_FRAME__TRANSLATE = "mass_frame__translate";

	//---------------------------------------------------------------------
	const mass_frame__translate__AttributeData mass_frame__translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mass_frame__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__mass_frame__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mass_frame__translate__AttributeData* attributeData = newData<mass_frame__translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MASS_FRAME__TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame__translate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MASS_FRAME__ROTATE = "mass_frame__rotate";

	//---------------------------------------------------------------------
	const mass_frame__rotate__AttributeData mass_frame__rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__mass_frame__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__mass_frame__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__mass_frame__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		mass_frame__rotate__AttributeData* attributeData = newData<mass_frame__rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MASS_FRAME__ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__mass_frame__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INERTIA = "inertia";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__INERTIA = "technique_common__inertia";

	//---------------------------------------------------------------------
	const inertia__AttributeData inertia__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__inertia( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__inertia);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__inertia( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		inertia__AttributeData* attributeData = newData<inertia__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INERTIA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__inertia()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MATERIAL = "instance_physics_material";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__INSTANCE_PHYSICS_MATERIAL = "technique_common__instance_physics_material";

	//---------------------------------------------------------------------
	const technique_common__instance_physics_material__AttributeData technique_common__instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique_common__instance_physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique_common__instance_physics_material__AttributeData* attributeData = newData<technique_common__instance_physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__instance_physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MATERIAL__EXTRA = "instance_physics_material__extra";

	//---------------------------------------------------------------------
	const instance_physics_material__extra__AttributeData instance_physics_material__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_material__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_material__extra__AttributeData* attributeData = newData<instance_physics_material__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_material__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MATERIAL = "physics_material";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__PHYSICS_MATERIAL = "technique_common__physics_material";

	//---------------------------------------------------------------------
	const technique_common__physics_material__AttributeData technique_common__physics_material__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique_common__physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique_common__physics_material__AttributeData* attributeData = newData<technique_common__physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MATERIAL__ASSET = "physics_material__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_material__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE_COMMON = "physics_material__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_material__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DYNAMIC_FRICTION = "dynamic_friction";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__DYNAMIC_FRICTION = "technique_common__dynamic_friction";

	//---------------------------------------------------------------------
	const dynamic_friction__AttributeData dynamic_friction__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__dynamic_friction( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__dynamic_friction);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__dynamic_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		dynamic_friction__AttributeData* attributeData = newData<dynamic_friction__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DYNAMIC_FRICTION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__dynamic_friction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RESTITUTION = "restitution";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__RESTITUTION = "technique_common__restitution";

	//---------------------------------------------------------------------
	const restitution__AttributeData restitution__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__restitution( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__restitution);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__restitution( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		restitution__AttributeData* attributeData = newData<restitution__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RESTITUTION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__restitution()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STATIC_FRICTION = "static_friction";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__STATIC_FRICTION = "technique_common__static_friction";

	//---------------------------------------------------------------------
	const static_friction__AttributeData static_friction__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__static_friction( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__static_friction);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__static_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		static_friction__AttributeData* attributeData = newData<static_friction__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STATIC_FRICTION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__static_friction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE = "physics_material__technique";

	//---------------------------------------------------------------------
	const physics_material__technique__AttributeData physics_material__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_material__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_material__technique__AttributeData* attributeData = newData<physics_material__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MATERIAL__EXTRA = "physics_material__extra";

	//---------------------------------------------------------------------
	const physics_material__extra__AttributeData physics_material__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_material__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_material__extra__AttributeData* attributeData = newData<physics_material__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_material__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE = "shape";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__SHAPE = "technique_common__shape";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HOLLOW = "hollow";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__HOLLOW = "shape__hollow";

	//---------------------------------------------------------------------
	const hollow__AttributeData hollow__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__hollow( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__hollow);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__hollow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		hollow__AttributeData* attributeData = newData<hollow__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_HOLLOW , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__hollow()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__MASS = "shape__mass";

	//---------------------------------------------------------------------
	const shape__mass__AttributeData shape__mass__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__mass( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shape__mass);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__mass__AttributeData* attributeData = newData<shape__mass__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__MASS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__mass()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DENSITY = "density";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__DENSITY = "shape__density";

	//---------------------------------------------------------------------
	const density__AttributeData density__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__density( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__density);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		density__AttributeData* attributeData = newData<density__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DENSITY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__density()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__INSTANCE_PHYSICS_MATERIAL = "shape__instance_physics_material";

	//---------------------------------------------------------------------
	const shape__instance_physics_material__AttributeData shape__instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__instance_physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__instance_physics_material__AttributeData* attributeData = newData<shape__instance_physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__instance_physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__PHYSICS_MATERIAL = "shape__physics_material";

	//---------------------------------------------------------------------
	const shape__physics_material__AttributeData shape__physics_material__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__physics_material__AttributeData* attributeData = newData<shape__physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__INSTANCE_GEOMETRY = "shape__instance_geometry";

	//---------------------------------------------------------------------
	const shape__instance_geometry__AttributeData shape__instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__instance_geometry( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__instance_geometry__AttributeData* attributeData = newData<shape__instance_geometry__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__INSTANCE_GEOMETRY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__instance_geometry()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PLANE = "plane";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__PLANE = "shape__plane";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__plane( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__plane()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EQUATION = "equation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PLANE__EQUATION = "plane__equation";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__equation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__equation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__equation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PLANE__EXTRA = "plane__extra";

	//---------------------------------------------------------------------
	const plane__extra__AttributeData plane__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__plane__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__plane__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		plane__extra__AttributeData* attributeData = newData<plane__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PLANE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__plane__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOX = "box";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__BOX = "shape__box";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__box( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__box( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__box()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF_EXTENTS = "half_extents";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOX__HALF_EXTENTS = "box__half_extents";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__half_extents( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__half_extents);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__half_extents( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__half_extents()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOX__EXTRA = "box__extra";

	//---------------------------------------------------------------------
	const box__extra__AttributeData box__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__box__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__box__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		box__extra__AttributeData* attributeData = newData<box__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BOX__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__box__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPHERE = "sphere";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__SPHERE = "shape__sphere";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sphere( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sphere( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sphere()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPHERE__RADIUS = "sphere__radius";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sphere__radius( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__sphere__radius);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sphere__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sphere__radius()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPHERE__EXTRA = "sphere__extra";

	//---------------------------------------------------------------------
	const sphere__extra__AttributeData sphere__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__sphere__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__sphere__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		sphere__extra__AttributeData* attributeData = newData<sphere__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPHERE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__sphere__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CYLINDER = "cylinder";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__CYLINDER = "shape__cylinder";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cylinder( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cylinder()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CYLINDER__HEIGHT = "cylinder__height";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cylinder__height( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__cylinder__height);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__height()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CYLINDER__RADIUS = "cylinder__radius";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cylinder__radius( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__cylinder__radius);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__radius()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CYLINDER__EXTRA = "cylinder__extra";

	//---------------------------------------------------------------------
	const cylinder__extra__AttributeData cylinder__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__cylinder__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		cylinder__extra__AttributeData* attributeData = newData<cylinder__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CYLINDER__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__cylinder__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CYLINDER = "tapered_cylinder";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__TAPERED_CYLINDER = "shape__tapered_cylinder";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_cylinder( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CYLINDER__HEIGHT = "tapered_cylinder__height";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__height( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_cylinder__height);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__height()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RADIUS1 = "radius1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CYLINDER__RADIUS1 = "tapered_cylinder__radius1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__radius1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_cylinder__radius1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__radius1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RADIUS2 = "radius2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CYLINDER__RADIUS2 = "tapered_cylinder__radius2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__radius2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_cylinder__radius2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__radius2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CYLINDER__EXTRA = "tapered_cylinder__extra";

	//---------------------------------------------------------------------
	const tapered_cylinder__extra__AttributeData tapered_cylinder__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_cylinder__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		tapered_cylinder__extra__AttributeData* attributeData = newData<tapered_cylinder__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TAPERED_CYLINDER__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_cylinder__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CAPSULE = "tapered_capsule";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__TAPERED_CAPSULE = "shape__tapered_capsule";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_capsule( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CAPSULE__HEIGHT = "tapered_capsule__height";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_capsule__height( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_capsule__height);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__height()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CAPSULE__RADIUS1 = "tapered_capsule__radius1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_capsule__radius1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_capsule__radius1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__radius1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CAPSULE__RADIUS2 = "tapered_capsule__radius2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_capsule__radius2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__tapered_capsule__radius2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__radius2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TAPERED_CAPSULE__EXTRA = "tapered_capsule__extra";

	//---------------------------------------------------------------------
	const tapered_capsule__extra__AttributeData tapered_capsule__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tapered_capsule__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tapered_capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		tapered_capsule__extra__AttributeData* attributeData = newData<tapered_capsule__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TAPERED_CAPSULE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tapered_capsule__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__TRANSLATE = "shape__translate";

	//---------------------------------------------------------------------
	const shape__translate__AttributeData shape__translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shape__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__translate__AttributeData* attributeData = newData<shape__translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__translate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__ROTATE = "shape__rotate";

	//---------------------------------------------------------------------
	const shape__rotate__AttributeData shape__rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shape__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__rotate__AttributeData* attributeData = newData<shape__rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHAPE__EXTRA = "shape__extra";

	//---------------------------------------------------------------------
	const shape__extra__AttributeData shape__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shape__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shape__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shape__extra__AttributeData* attributeData = newData<shape__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shape__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE = "instance_rigid_body__technique";

	//---------------------------------------------------------------------
	const instance_rigid_body__technique__AttributeData instance_rigid_body__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_rigid_body__technique__AttributeData* attributeData = newData<instance_rigid_body__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_BODY__EXTRA = "instance_rigid_body__extra";

	//---------------------------------------------------------------------
	const instance_rigid_body__extra__AttributeData instance_rigid_body__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_body__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_rigid_body__extra__AttributeData* attributeData = newData<instance_rigid_body__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_body__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_CONSTRAINT = "instance_rigid_constraint";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_RIGID_CONSTRAINT = "instance_physics_model__instance_rigid_constraint";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_CONSTRAINT = "constraint";

	//---------------------------------------------------------------------
	const instance_rigid_constraint__AttributeData instance_rigid_constraint__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_constraint( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_rigid_constraint__AttributeData* attributeData = newData<instance_rigid_constraint__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_CONSTRAINT:
					{

						attributeData->constraint = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_constraint()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_RIGID_CONSTRAINT__EXTRA = "instance_rigid_constraint__extra";

	//---------------------------------------------------------------------
	const instance_rigid_constraint__extra__AttributeData instance_rigid_constraint__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_rigid_constraint__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_rigid_constraint__extra__AttributeData* attributeData = newData<instance_rigid_constraint__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_rigid_constraint__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_MODEL__EXTRA = "instance_physics_model__extra";

	//---------------------------------------------------------------------
	const instance_physics_model__extra__AttributeData instance_physics_model__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_model__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_model__extra__AttributeData* attributeData = newData<instance_physics_model__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_model__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__TECHNIQUE_COMMON = "physics_scene__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GRAVITY = "gravity";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__GRAVITY = "technique_common__gravity";

	//---------------------------------------------------------------------
	const gravity__AttributeData gravity__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__gravity( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__gravity);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__gravity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		gravity__AttributeData* attributeData = newData<gravity__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GRAVITY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__gravity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TIME_STEP = "time_step";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__TIME_STEP = "technique_common__time_step";

	//---------------------------------------------------------------------
	const time_step__AttributeData time_step__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__time_step( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__time_step);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__time_step( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		time_step__AttributeData* attributeData = newData<time_step__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TIME_STEP , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__time_step()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__TECHNIQUE = "physics_scene__technique";

	//---------------------------------------------------------------------
	const physics_scene__technique__AttributeData physics_scene__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_scene__technique__AttributeData* attributeData = newData<physics_scene__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_SCENE__EXTRA = "physics_scene__extra";

	//---------------------------------------------------------------------
	const physics_scene__extra__AttributeData physics_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_scene__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_scene__extra__AttributeData* attributeData = newData<physics_scene__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_scene__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_SCENES__EXTRA = "library_physics_scenes__extra";

	//---------------------------------------------------------------------
	const library_physics_scenes__extra__AttributeData library_physics_scenes__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_scenes__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_scenes__extra__AttributeData* attributeData = newData<library_physics_scenes__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_SCENES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_scenes__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA = "COLLADA";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_VERSION = "version";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_BASE = "base";

	//---------------------------------------------------------------------
	const COLLADA__AttributeData COLLADA__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__COLLADA( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		COLLADA__AttributeData* attributeData = newData<COLLADA__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_VERSION:
					{



						break;
					}
				case HASH_ATTRIBUTE_BASE:
					{

						attributeData->base = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLLADA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__ASSET = "COLLADA__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__COLLADA__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATIONS = "library_animations";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_ANIMATIONS = "COLLADA__library_animations";

	//---------------------------------------------------------------------
	const library_animations__AttributeData library_animations__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animations( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animations( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_animations__AttributeData* attributeData = newData<library_animations__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATIONS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animations()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__ASSET = "library_animations__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animations__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animations__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animations__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATIONS__EXTRA = "library_animations__extra";

	//---------------------------------------------------------------------
	const library_animations__extra__AttributeData library_animations__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animations__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animations__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_animations__extra__AttributeData* attributeData = newData<library_animations__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATIONS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animations__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS = "library_animation_clips";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_ANIMATION_CLIPS = "COLLADA__library_animation_clips";

	//---------------------------------------------------------------------
	const library_animation_clips__AttributeData library_animation_clips__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animation_clips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_animation_clips__AttributeData* attributeData = newData<library_animation_clips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__ASSET = "library_animation_clips__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animation_clips__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION_CLIP = "animation_clip";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__ANIMATION_CLIP = "library_animation_clips__animation_clip";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_START = "start";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_END = "end";

	//---------------------------------------------------------------------
	const animation_clip__AttributeData animation_clip__AttributeData::DEFAULT = {0, 0, 0.0E1, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation_clip( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		animation_clip__AttributeData* attributeData = newData<animation_clip__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_START:
					{
						bool failed;
						attributeData->start = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_START, attributeValue))
						{return false;}
						break;
					}
				case HASH_ATTRIBUTE_END:
					{
						bool failed;
						attributeData->end = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_END, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION_CLIP__ASSET = "animation_clip__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation_clip__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_ANIMATION = "instance_animation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION_CLIP__INSTANCE_ANIMATION = "animation_clip__instance_animation";

	//---------------------------------------------------------------------
	const instance_animation__AttributeData instance_animation__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_animation( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_animation__AttributeData* attributeData = newData<instance_animation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_ANIMATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_animation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_ANIMATION__EXTRA = "instance_animation__extra";

	//---------------------------------------------------------------------
	const instance_animation__extra__AttributeData instance_animation__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_animation__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_animation__extra__AttributeData* attributeData = newData<instance_animation__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_ANIMATION__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_animation__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANIMATION_CLIP__EXTRA = "animation_clip__extra";

	//---------------------------------------------------------------------
	const animation_clip__extra__AttributeData animation_clip__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__animation_clip__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__animation_clip__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		animation_clip__extra__AttributeData* attributeData = newData<animation_clip__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__animation_clip__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_ANIMATION_CLIPS__EXTRA = "library_animation_clips__extra";

	//---------------------------------------------------------------------
	const library_animation_clips__extra__AttributeData library_animation_clips__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_animation_clips__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_animation_clips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_animation_clips__extra__AttributeData* attributeData = newData<library_animation_clips__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_animation_clips__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CAMERAS = "library_cameras";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_CAMERAS = "COLLADA__library_cameras";

	//---------------------------------------------------------------------
	const library_cameras__AttributeData library_cameras__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_cameras( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_cameras__AttributeData* attributeData = newData<library_cameras__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CAMERAS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CAMERAS__ASSET = "library_cameras__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_cameras__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAMERA = "camera";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CAMERAS__CAMERA = "library_cameras__camera";

	//---------------------------------------------------------------------
	const camera__AttributeData camera__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__camera( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		camera__AttributeData* attributeData = newData<camera__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAMERA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__camera()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAMERA__ASSET = "camera__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__camera__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__camera__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__camera__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_OPTICS = "optics";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAMERA__OPTICS = "camera__optics";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__optics( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__optics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__optics()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_OPTICS__TECHNIQUE_COMMON = "optics__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__optics__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__optics__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__optics__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC = "orthographic";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__ORTHOGRAPHIC = "technique_common__orthographic";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__orthographic( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__orthographic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__orthographic()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_XMAG = "xmag";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC__XMAG = "orthographic__xmag";

	//---------------------------------------------------------------------
	const xmag__AttributeData xmag__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__xmag( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__xmag);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__xmag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		xmag__AttributeData* attributeData = newData<xmag__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_XMAG , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__xmag()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_YMAG = "ymag";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC__YMAG = "orthographic__ymag";

	//---------------------------------------------------------------------
	const ymag__AttributeData ymag__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ymag( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ymag);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ymag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ymag__AttributeData* attributeData = newData<ymag__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_YMAG , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ymag()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ASPECT_RATIO = "aspect_ratio";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO = "orthographic__aspect_ratio";

	//---------------------------------------------------------------------
	const orthographic__aspect_ratio__AttributeData orthographic__aspect_ratio__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__orthographic__aspect_ratio( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__orthographic__aspect_ratio);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		orthographic__aspect_ratio__AttributeData* attributeData = newData<orthographic__aspect_ratio__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__aspect_ratio()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ZNEAR = "znear";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC__ZNEAR = "orthographic__znear";

	//---------------------------------------------------------------------
	const orthographic__znear__AttributeData orthographic__znear__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__orthographic__znear( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__orthographic__znear);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		orthographic__znear__AttributeData* attributeData = newData<orthographic__znear__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ZNEAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__znear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ZFAR = "zfar";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ORTHOGRAPHIC__ZFAR = "orthographic__zfar";

	//---------------------------------------------------------------------
	const orthographic__zfar__AttributeData orthographic__zfar__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__orthographic__zfar( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__orthographic__zfar);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__orthographic__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		orthographic__zfar__AttributeData* attributeData = newData<orthographic__zfar__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ZFAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__orthographic__zfar()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE = "perspective";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__PERSPECTIVE = "technique_common__perspective";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__perspective( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__perspective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__perspective()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_XFOV = "xfov";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE__XFOV = "perspective__xfov";

	//---------------------------------------------------------------------
	const xfov__AttributeData xfov__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__xfov( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__xfov);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__xfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		xfov__AttributeData* attributeData = newData<xfov__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_XFOV , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__xfov()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_YFOV = "yfov";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE__YFOV = "perspective__yfov";

	//---------------------------------------------------------------------
	const yfov__AttributeData yfov__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__yfov( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__yfov);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__yfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		yfov__AttributeData* attributeData = newData<yfov__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_YFOV , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__yfov()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE__ASPECT_RATIO = "perspective__aspect_ratio";

	//---------------------------------------------------------------------
	const perspective__aspect_ratio__AttributeData perspective__aspect_ratio__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__perspective__aspect_ratio( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__perspective__aspect_ratio);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__perspective__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		perspective__aspect_ratio__AttributeData* attributeData = newData<perspective__aspect_ratio__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ASPECT_RATIO , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__perspective__aspect_ratio()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE__ZNEAR = "perspective__znear";

	//---------------------------------------------------------------------
	const perspective__znear__AttributeData perspective__znear__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__perspective__znear( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__perspective__znear);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__perspective__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		perspective__znear__AttributeData* attributeData = newData<perspective__znear__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ZNEAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__perspective__znear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PERSPECTIVE__ZFAR = "perspective__zfar";

	//---------------------------------------------------------------------
	const perspective__zfar__AttributeData perspective__zfar__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__perspective__zfar( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__perspective__zfar);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__perspective__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		perspective__zfar__AttributeData* attributeData = newData<perspective__zfar__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ZFAR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__perspective__zfar()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_OPTICS__TECHNIQUE = "optics__technique";

	//---------------------------------------------------------------------
	const optics__technique__AttributeData optics__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__optics__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__optics__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		optics__technique__AttributeData* attributeData = newData<optics__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_OPTICS__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__optics__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_OPTICS__EXTRA = "optics__extra";

	//---------------------------------------------------------------------
	const optics__extra__AttributeData optics__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__optics__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__optics__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		optics__extra__AttributeData* attributeData = newData<optics__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_OPTICS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__optics__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGER = "imager";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAMERA__IMAGER = "camera__imager";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__imager( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__imager( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__imager()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGER__TECHNIQUE = "imager__technique";

	//---------------------------------------------------------------------
	const imager__technique__AttributeData imager__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__imager__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__imager__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		imager__technique__AttributeData* attributeData = newData<imager__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGER__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__imager__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_IMAGER__EXTRA = "imager__extra";

	//---------------------------------------------------------------------
	const imager__extra__AttributeData imager__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__imager__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__imager__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		imager__extra__AttributeData* attributeData = newData<imager__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGER__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__imager__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CAMERA__EXTRA = "camera__extra";

	//---------------------------------------------------------------------
	const camera__extra__AttributeData camera__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__camera__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		camera__extra__AttributeData* attributeData = newData<camera__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAMERA__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__camera__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CAMERAS__EXTRA = "library_cameras__extra";

	//---------------------------------------------------------------------
	const library_cameras__extra__AttributeData library_cameras__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_cameras__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_cameras__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_cameras__extra__AttributeData* attributeData = newData<library_cameras__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CAMERAS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_cameras__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CONTROLLERS = "library_controllers";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_CONTROLLERS = "COLLADA__library_controllers";

	//---------------------------------------------------------------------
	const library_controllers__AttributeData library_controllers__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_controllers( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_controllers__AttributeData* attributeData = newData<library_controllers__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CONTROLLERS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__ASSET = "library_controllers__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_controllers__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROLLER = "controller";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__CONTROLLER = "library_controllers__controller";

	//---------------------------------------------------------------------
	const controller__AttributeData controller__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__controller( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		controller__AttributeData* attributeData = newData<controller__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROLLER , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__controller()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROLLER__ASSET = "controller__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__controller__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__controller__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__controller__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN = "skin";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROLLER__SKIN = "controller__skin";

	//---------------------------------------------------------------------
	const skin__AttributeData skin__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__skin( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__skin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		skin__AttributeData* attributeData = newData<skin__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__skin()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BIND_SHAPE_MATRIX = "bind_shape_matrix";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN__BIND_SHAPE_MATRIX = "skin__bind_shape_matrix";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_shape_matrix( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__bind_shape_matrix);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_shape_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_shape_matrix()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN__SOURCE = "skin__source";

	//---------------------------------------------------------------------
	const skin__source__AttributeData skin__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__skin__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__skin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		skin__source__AttributeData* attributeData = newData<skin__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__skin__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_JOINTS = "joints";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN__JOINTS = "skin__joints";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__joints( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__joints( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__joints()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_JOINTS__INPUT = "joints__input";

	//---------------------------------------------------------------------
	const joints__input__AttributeData joints__input__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__joints__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__joints__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		joints__input__AttributeData* attributeData = newData<joints__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_JOINTS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__joints__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_JOINTS__EXTRA = "joints__extra";

	//---------------------------------------------------------------------
	const joints__extra__AttributeData joints__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__joints__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__joints__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		joints__extra__AttributeData* attributeData = newData<joints__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_JOINTS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__joints__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTEX_WEIGHTS = "vertex_weights";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN__VERTEX_WEIGHTS = "skin__vertex_weights";

	//---------------------------------------------------------------------
	const vertex_weights__AttributeData vertex_weights__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertex_weights( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertex_weights__AttributeData* attributeData = newData<vertex_weights__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTEX_WEIGHTS__INPUT = "vertex_weights__input";

	//---------------------------------------------------------------------
	const vertex_weights__input__AttributeData vertex_weights__input__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertex_weights__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertex_weights__input__AttributeData* attributeData = newData<vertex_weights__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OFFSET:
					{



						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				case HASH_ATTRIBUTE_SET:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTEX_WEIGHTS__VCOUNT = "vertex_weights__vcount";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertex_weights__vcount( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__vertex_weights__vcount);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__vcount()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_V = "v";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTEX_WEIGHTS__V = "vertex_weights__v";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__v( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__v);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__v( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__v()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_VERTEX_WEIGHTS__EXTRA = "vertex_weights__extra";

	//---------------------------------------------------------------------
	const vertex_weights__extra__AttributeData vertex_weights__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertex_weights__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertex_weights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertex_weights__extra__AttributeData* attributeData = newData<vertex_weights__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertex_weights__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SKIN__EXTRA = "skin__extra";

	//---------------------------------------------------------------------
	const skin__extra__AttributeData skin__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__skin__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__skin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		skin__extra__AttributeData* attributeData = newData<skin__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__skin__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MORPH = "morph";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROLLER__MORPH = "controller__morph";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_METHOD = "method";

	//---------------------------------------------------------------------
	const morph__AttributeData morph__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"NORMALIZED", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__morph( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__morph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		morph__AttributeData* attributeData = newData<morph__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_METHOD:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__morph()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MORPH__SOURCE = "morph__source";

	//---------------------------------------------------------------------
	const morph__source__AttributeData morph__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__morph__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__morph__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		morph__source__AttributeData* attributeData = newData<morph__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__morph__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TARGETS = "targets";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MORPH__TARGETS = "morph__targets";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__targets( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__targets( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__targets()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TARGETS__INPUT = "targets__input";

	//---------------------------------------------------------------------
	const targets__input__AttributeData targets__input__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__targets__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__targets__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		targets__input__AttributeData* attributeData = newData<targets__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TARGETS__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__targets__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TARGETS__EXTRA = "targets__extra";

	//---------------------------------------------------------------------
	const targets__extra__AttributeData targets__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__targets__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__targets__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		targets__extra__AttributeData* attributeData = newData<targets__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TARGETS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__targets__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MORPH__EXTRA = "morph__extra";

	//---------------------------------------------------------------------
	const morph__extra__AttributeData morph__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__morph__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__morph__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		morph__extra__AttributeData* attributeData = newData<morph__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__morph__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROLLER__EXTRA = "controller__extra";

	//---------------------------------------------------------------------
	const controller__extra__AttributeData controller__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__controller__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		controller__extra__AttributeData* attributeData = newData<controller__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROLLER__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__controller__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_CONTROLLERS__EXTRA = "library_controllers__extra";

	//---------------------------------------------------------------------
	const library_controllers__extra__AttributeData library_controllers__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_controllers__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_controllers__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_controllers__extra__AttributeData* attributeData = newData<library_controllers__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CONTROLLERS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_controllers__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_GEOMETRIES = "library_geometries";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_GEOMETRIES = "COLLADA__library_geometries";

	//---------------------------------------------------------------------
	const library_geometries__AttributeData library_geometries__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_geometries( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_geometries__AttributeData* attributeData = newData<library_geometries__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_GEOMETRIES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__ASSET = "library_geometries__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_geometries__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY = "geometry";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__GEOMETRY = "library_geometries__geometry";

	//---------------------------------------------------------------------
	const geometry__AttributeData geometry__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__geometry( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		geometry__AttributeData* attributeData = newData<geometry__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GEOMETRY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__geometry()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY__ASSET = "geometry__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__geometry__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__geometry__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__geometry__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH = "convex_mesh";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY__CONVEX_MESH = "geometry__convex_mesh";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_CONVEX_HULL_OF = "convex_hull_of";

	//---------------------------------------------------------------------
	const convex_mesh__AttributeData convex_mesh__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__AttributeData* attributeData = newData<convex_mesh__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_CONVEX_HULL_OF:
					{

						attributeData->convex_hull_of = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__SOURCE = "convex_mesh__source";

	//---------------------------------------------------------------------
	const convex_mesh__source__AttributeData convex_mesh__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__source__AttributeData* attributeData = newData<convex_mesh__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__VERTICES = "convex_mesh__vertices";

	//---------------------------------------------------------------------
	const convex_mesh__vertices__AttributeData convex_mesh__vertices__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__vertices( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__vertices__AttributeData* attributeData = newData<convex_mesh__vertices__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__VERTICES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__vertices()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__LINES = "convex_mesh__lines";

	//---------------------------------------------------------------------
	const convex_mesh__lines__AttributeData convex_mesh__lines__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__lines( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__lines__AttributeData* attributeData = newData<convex_mesh__lines__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__lines()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__LINESTRIPS = "convex_mesh__linestrips";

	//---------------------------------------------------------------------
	const convex_mesh__linestrips__AttributeData convex_mesh__linestrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__linestrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__linestrips__AttributeData* attributeData = newData<convex_mesh__linestrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINESTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__linestrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__POLYGONS = "convex_mesh__polygons";

	//---------------------------------------------------------------------
	const convex_mesh__polygons__AttributeData convex_mesh__polygons__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__polygons( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__polygons__AttributeData* attributeData = newData<convex_mesh__polygons__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYGONS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__polygons()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__POLYLIST = "convex_mesh__polylist";

	//---------------------------------------------------------------------
	const convex_mesh__polylist__AttributeData convex_mesh__polylist__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__polylist( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__polylist__AttributeData* attributeData = newData<convex_mesh__polylist__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYLIST , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__polylist()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__TRIANGLES = "convex_mesh__triangles";

	//---------------------------------------------------------------------
	const convex_mesh__triangles__AttributeData convex_mesh__triangles__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__triangles( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__triangles__AttributeData* attributeData = newData<convex_mesh__triangles__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIANGLES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__triangles()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__TRIFANS = "convex_mesh__trifans";

	//---------------------------------------------------------------------
	const convex_mesh__trifans__AttributeData convex_mesh__trifans__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__trifans( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__trifans__AttributeData* attributeData = newData<convex_mesh__trifans__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIFANS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__trifans()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__TRISTRIPS = "convex_mesh__tristrips";

	//---------------------------------------------------------------------
	const convex_mesh__tristrips__AttributeData convex_mesh__tristrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__tristrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__tristrips__AttributeData* attributeData = newData<convex_mesh__tristrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRISTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__tristrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONVEX_MESH__EXTRA = "convex_mesh__extra";

	//---------------------------------------------------------------------
	const convex_mesh__extra__AttributeData convex_mesh__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__convex_mesh__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__convex_mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		convex_mesh__extra__AttributeData* attributeData = newData<convex_mesh__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__convex_mesh__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPLINE = "spline";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY__SPLINE = "geometry__spline";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_CLOSED = "closed";

	//---------------------------------------------------------------------
	const spline__AttributeData spline__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"false"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spline( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spline__AttributeData* attributeData = newData<spline__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_CLOSED:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spline()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPLINE__SOURCE = "spline__source";

	//---------------------------------------------------------------------
	const spline__source__AttributeData spline__source__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spline__source( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spline__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spline__source__AttributeData* attributeData = newData<spline__source__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE__SOURCE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spline__source()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROL_VERTICES = "control_vertices";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPLINE__CONTROL_VERTICES = "spline__control_vertices";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__control_vertices( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROL_VERTICES__INPUT = "control_vertices__input";

	//---------------------------------------------------------------------
	const control_vertices__input__AttributeData control_vertices__input__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__control_vertices__input( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		control_vertices__input__AttributeData* attributeData = newData<control_vertices__input__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROL_VERTICES__INPUT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices__input()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONTROL_VERTICES__EXTRA = "control_vertices__extra";

	//---------------------------------------------------------------------
	const control_vertices__extra__AttributeData control_vertices__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__control_vertices__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__control_vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		control_vertices__extra__AttributeData* attributeData = newData<control_vertices__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROL_VERTICES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__control_vertices__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPLINE__EXTRA = "spline__extra";

	//---------------------------------------------------------------------
	const spline__extra__AttributeData spline__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spline__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spline__extra__AttributeData* attributeData = newData<spline__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spline__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GEOMETRY__EXTRA = "geometry__extra";

	//---------------------------------------------------------------------
	const geometry__extra__AttributeData geometry__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__geometry__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		geometry__extra__AttributeData* attributeData = newData<geometry__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GEOMETRY__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__geometry__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_GEOMETRIES__EXTRA = "library_geometries__extra";

	//---------------------------------------------------------------------
	const library_geometries__extra__AttributeData library_geometries__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_geometries__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_geometries__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_geometries__extra__AttributeData* attributeData = newData<library_geometries__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_GEOMETRIES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_geometries__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_EFFECTS = "library_effects";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_EFFECTS = "COLLADA__library_effects";

	//---------------------------------------------------------------------
	const library_effects__AttributeData library_effects__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_effects( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_effects( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_effects__AttributeData* attributeData = newData<library_effects__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_EFFECTS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_effects()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_EFFECTS__ASSET = "library_effects__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_effects__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_effects__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_effects__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT = "effect";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_EFFECTS__EFFECT = "library_effects__effect";

	//---------------------------------------------------------------------
	const effect__AttributeData effect__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		effect__AttributeData* attributeData = newData<effect__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__ASSET = "effect__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__ANNOTATE = "effect__annotate";

	//---------------------------------------------------------------------
	const effect__annotate__AttributeData effect__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		effect__annotate__AttributeData* attributeData = newData<effect__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__IMAGE = "effect__image";

	//---------------------------------------------------------------------
	const effect__image__AttributeData effect__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		effect__image__AttributeData* attributeData = newData<effect__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__NEWPARAM = "effect__newparam";

	//---------------------------------------------------------------------
	const effect__newparam__AttributeData effect__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		effect__newparam__AttributeData* attributeData = newData<effect__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLER1D = "newparam__sampler1D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__sampler1D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler1D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLER2D = "newparam__sampler2D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__sampler2D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler2D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLER3D = "newparam__sampler3D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__sampler3D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__sampler3D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLERCUBE = "newparam__samplerCUBE";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__samplerCUBE( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerCUBE()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLERRECT = "newparam__samplerRECT";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__samplerRECT( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerRECT()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__SAMPLERDEPTH = "newparam__samplerDEPTH";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__samplerDEPTH( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__samplerDEPTH()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EFFECT__EXTRA = "effect__extra";

	//---------------------------------------------------------------------
	const effect__extra__AttributeData effect__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__effect__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		effect__extra__AttributeData* attributeData = newData<effect__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__effect__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_EFFECTS__EXTRA = "library_effects__extra";

	//---------------------------------------------------------------------
	const library_effects__extra__AttributeData library_effects__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_effects__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_effects__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_effects__extra__AttributeData* attributeData = newData<library_effects__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_EFFECTS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_effects__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_IMAGES = "library_images";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_IMAGES = "COLLADA__library_images";

	//---------------------------------------------------------------------
	const library_images__AttributeData library_images__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_images( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_images( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_images__AttributeData* attributeData = newData<library_images__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_images()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_IMAGES__ASSET = "library_images__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_images__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_images__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_images__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_IMAGES__IMAGE = "library_images__image";

	//---------------------------------------------------------------------
	const library_images__image__AttributeData library_images__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_images__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_images__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_images__image__AttributeData* attributeData = newData<library_images__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_images__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_IMAGES__EXTRA = "library_images__extra";

	//---------------------------------------------------------------------
	const library_images__extra__AttributeData library_images__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_images__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_images__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_images__extra__AttributeData* attributeData = newData<library_images__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_images__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_LIGHTS = "library_lights";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_LIGHTS = "COLLADA__library_lights";

	//---------------------------------------------------------------------
	const library_lights__AttributeData library_lights__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_lights( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_lights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_lights__AttributeData* attributeData = newData<library_lights__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_LIGHTS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_lights()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_LIGHTS__ASSET = "library_lights__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_lights__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_lights__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_lights__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT = "light";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_LIGHTS__LIGHT = "library_lights__light";

	//---------------------------------------------------------------------
	const light__AttributeData light__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light__AttributeData* attributeData = newData<light__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT__ASSET = "light__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT__TECHNIQUE_COMMON = "light__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AMBIENT = "ambient";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__AMBIENT = "technique_common__ambient";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique_common__ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique_common__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique_common__ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLOR = "color";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AMBIENT__COLOR = "ambient__color";

	//---------------------------------------------------------------------
	const ambient__color__AttributeData ambient__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ambient__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ambient__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ambient__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ambient__color__AttributeData* attributeData = newData<ambient__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ambient__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIRECTIONAL = "directional";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__DIRECTIONAL = "technique_common__directional";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__directional( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__directional( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__directional()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIRECTIONAL__COLOR = "directional__color";

	//---------------------------------------------------------------------
	const directional__color__AttributeData directional__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__directional__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__directional__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__directional__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		directional__color__AttributeData* attributeData = newData<directional__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIRECTIONAL__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__directional__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT = "point";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__POINT = "technique_common__point";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT__COLOR = "point__color";

	//---------------------------------------------------------------------
	const point__color__AttributeData point__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__point__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point__color__AttributeData* attributeData = newData<point__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT_ATTENUATION = "constant_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT__CONSTANT_ATTENUATION = "point__constant_attenuation";

	//---------------------------------------------------------------------
	const point__constant_attenuation__AttributeData point__constant_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point__constant_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__point__constant_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point__constant_attenuation__AttributeData* attributeData = newData<point__constant_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__CONSTANT_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point__constant_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR_ATTENUATION = "linear_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT__LINEAR_ATTENUATION = "point__linear_attenuation";

	//---------------------------------------------------------------------
	const point__linear_attenuation__AttributeData point__linear_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point__linear_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__point__linear_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point__linear_attenuation__AttributeData* attributeData = newData<point__linear_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__LINEAR_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point__linear_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_QUADRATIC_ATTENUATION = "quadratic_attenuation";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_POINT__QUADRATIC_ATTENUATION = "point__quadratic_attenuation";

	//---------------------------------------------------------------------
	const point__quadratic_attenuation__AttributeData point__quadratic_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__point__quadratic_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__point__quadratic_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__point__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		point__quadratic_attenuation__AttributeData* attributeData = newData<point__quadratic_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__QUADRATIC_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__point__quadratic_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT = "spot";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__SPOT = "technique_common__spot";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spot( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spot()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__COLOR = "spot__color";

	//---------------------------------------------------------------------
	const spot__color__AttributeData spot__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spot__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__spot__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spot__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spot__color__AttributeData* attributeData = newData<spot__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spot__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__CONSTANT_ATTENUATION = "spot__constant_attenuation";

	//---------------------------------------------------------------------
	const spot__constant_attenuation__AttributeData spot__constant_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spot__constant_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__spot__constant_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spot__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spot__constant_attenuation__AttributeData* attributeData = newData<spot__constant_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__CONSTANT_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spot__constant_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__LINEAR_ATTENUATION = "spot__linear_attenuation";

	//---------------------------------------------------------------------
	const spot__linear_attenuation__AttributeData spot__linear_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spot__linear_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__spot__linear_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spot__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spot__linear_attenuation__AttributeData* attributeData = newData<spot__linear_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__LINEAR_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spot__linear_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__QUADRATIC_ATTENUATION = "spot__quadratic_attenuation";

	//---------------------------------------------------------------------
	const spot__quadratic_attenuation__AttributeData spot__quadratic_attenuation__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spot__quadratic_attenuation( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__spot__quadratic_attenuation);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spot__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		spot__quadratic_attenuation__AttributeData* attributeData = newData<spot__quadratic_attenuation__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__QUADRATIC_ATTENUATION , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spot__quadratic_attenuation()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FALLOFF_ANGLE = "falloff_angle";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__FALLOFF_ANGLE = "spot__falloff_angle";

	//---------------------------------------------------------------------
	const falloff_angle__AttributeData falloff_angle__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__falloff_angle( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__falloff_angle);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__falloff_angle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		falloff_angle__AttributeData* attributeData = newData<falloff_angle__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FALLOFF_ANGLE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__falloff_angle()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FALLOFF_EXPONENT = "falloff_exponent";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPOT__FALLOFF_EXPONENT = "spot__falloff_exponent";

	//---------------------------------------------------------------------
	const falloff_exponent__AttributeData falloff_exponent__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__falloff_exponent( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__falloff_exponent);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__falloff_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		falloff_exponent__AttributeData* attributeData = newData<falloff_exponent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FALLOFF_EXPONENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__falloff_exponent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT__TECHNIQUE = "light__technique";

	//---------------------------------------------------------------------
	const light__technique__AttributeData light__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light__technique__AttributeData* attributeData = newData<light__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIGHT__EXTRA = "light__extra";

	//---------------------------------------------------------------------
	const light__extra__AttributeData light__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__light__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		light__extra__AttributeData* attributeData = newData<light__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__light__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_LIGHTS__EXTRA = "library_lights__extra";

	//---------------------------------------------------------------------
	const library_lights__extra__AttributeData library_lights__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_lights__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_lights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_lights__extra__AttributeData* attributeData = newData<library_lights__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_LIGHTS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_lights__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_MATERIALS = "library_materials";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_MATERIALS = "COLLADA__library_materials";

	//---------------------------------------------------------------------
	const library_materials__AttributeData library_materials__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_materials( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_materials__AttributeData* attributeData = newData<library_materials__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_MATERIALS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_materials()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_MATERIALS__ASSET = "library_materials__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_materials__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_materials__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_MATERIALS__EXTRA = "library_materials__extra";

	//---------------------------------------------------------------------
	const library_materials__extra__AttributeData library_materials__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_materials__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_materials__extra__AttributeData* attributeData = newData<library_materials__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_MATERIALS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_materials__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_NODES = "library_nodes";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_NODES = "COLLADA__library_nodes";

	//---------------------------------------------------------------------
	const library_nodes__AttributeData library_nodes__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_nodes( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_nodes__AttributeData* attributeData = newData<library_nodes__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_NODES__ASSET = "library_nodes__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_nodes__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_NODES__NODE = "library_nodes__node";

	//---------------------------------------------------------------------
	const library_nodes__node__AttributeData library_nodes__node__AttributeData::DEFAULT = {0, 0, 0, (const GeneratedSaxParser::ParserChar *)"NODE", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_nodes__node( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_nodes__node__AttributeData* attributeData = newData<library_nodes__node__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				case HASH_ATTRIBUTE_LAYER:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES__NODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__node()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_NODES__EXTRA = "library_nodes__extra";

	//---------------------------------------------------------------------
	const library_nodes__extra__AttributeData library_nodes__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_nodes__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_nodes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_nodes__extra__AttributeData* attributeData = newData<library_nodes__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_nodes__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS = "library_physics_materials";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_MATERIALS = "COLLADA__library_physics_materials";

	//---------------------------------------------------------------------
	const library_physics_materials__AttributeData library_physics_materials__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_materials( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_materials__AttributeData* attributeData = newData<library_physics_materials__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__ASSET = "library_physics_materials__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_materials__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__PHYSICS_MATERIAL = "library_physics_materials__physics_material";

	//---------------------------------------------------------------------
	const library_physics_materials__physics_material__AttributeData library_physics_materials__physics_material__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_materials__physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_materials__physics_material__AttributeData* attributeData = newData<library_physics_materials__physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MATERIALS__EXTRA = "library_physics_materials__extra";

	//---------------------------------------------------------------------
	const library_physics_materials__extra__AttributeData library_physics_materials__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_materials__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_materials__extra__AttributeData* attributeData = newData<library_physics_materials__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_materials__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS = "library_physics_models";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_PHYSICS_MODELS = "COLLADA__library_physics_models";

	//---------------------------------------------------------------------
	const library_physics_models__AttributeData library_physics_models__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_models( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_models__AttributeData* attributeData = newData<library_physics_models__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MODELS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__ASSET = "library_physics_models__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_models__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL = "physics_model";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__PHYSICS_MODEL = "library_physics_models__physics_model";

	//---------------------------------------------------------------------
	const physics_model__AttributeData physics_model__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_model( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_model__AttributeData* attributeData = newData<physics_model__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_model()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL__ASSET = "physics_model__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_model__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_BODY = "rigid_body";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL__RIGID_BODY = "physics_model__rigid_body";

	//---------------------------------------------------------------------
	const rigid_body__AttributeData rigid_body__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_body( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_body__AttributeData* attributeData = newData<rigid_body__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE_COMMON = "rigid_body__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_body__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_BODY__TECHNIQUE = "rigid_body__technique";

	//---------------------------------------------------------------------
	const rigid_body__technique__AttributeData rigid_body__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_body__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_body__technique__AttributeData* attributeData = newData<rigid_body__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_BODY__EXTRA = "rigid_body__extra";

	//---------------------------------------------------------------------
	const rigid_body__extra__AttributeData rigid_body__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_body__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_body__extra__AttributeData* attributeData = newData<rigid_body__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_body__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT = "rigid_constraint";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL__RIGID_CONSTRAINT = "physics_model__rigid_constraint";

	//---------------------------------------------------------------------
	const rigid_constraint__AttributeData rigid_constraint__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_constraint( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_constraint__AttributeData* attributeData = newData<rigid_constraint__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REF_ATTACHMENT = "ref_attachment";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT__REF_ATTACHMENT = "rigid_constraint__ref_attachment";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_RIGID_BODY = "rigid_body";

	//---------------------------------------------------------------------
	const ref_attachment__AttributeData ref_attachment__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ref_attachment( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ref_attachment__AttributeData* attributeData = newData<ref_attachment__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_RIGID_BODY:
					{

						attributeData->rigid_body = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REF_ATTACHMENT__TRANSLATE = "ref_attachment__translate";

	//---------------------------------------------------------------------
	const ref_attachment__translate__AttributeData ref_attachment__translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ref_attachment__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ref_attachment__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ref_attachment__translate__AttributeData* attributeData = newData<ref_attachment__translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__translate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REF_ATTACHMENT__ROTATE = "ref_attachment__rotate";

	//---------------------------------------------------------------------
	const ref_attachment__rotate__AttributeData ref_attachment__rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ref_attachment__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__ref_attachment__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ref_attachment__rotate__AttributeData* attributeData = newData<ref_attachment__rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REF_ATTACHMENT__EXTRA = "ref_attachment__extra";

	//---------------------------------------------------------------------
	const ref_attachment__extra__AttributeData ref_attachment__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ref_attachment__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ref_attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ref_attachment__extra__AttributeData* attributeData = newData<ref_attachment__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ref_attachment__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ATTACHMENT = "attachment";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT__ATTACHMENT = "rigid_constraint__attachment";

	//---------------------------------------------------------------------
	const attachment__AttributeData attachment__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__attachment( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		attachment__AttributeData* attributeData = newData<attachment__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_RIGID_BODY:
					{

						attributeData->rigid_body = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__attachment()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ATTACHMENT__TRANSLATE = "attachment__translate";

	//---------------------------------------------------------------------
	const attachment__translate__AttributeData attachment__translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__attachment__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__attachment__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		attachment__translate__AttributeData* attributeData = newData<attachment__translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__attachment__translate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ATTACHMENT__ROTATE = "attachment__rotate";

	//---------------------------------------------------------------------
	const attachment__rotate__AttributeData attachment__rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__attachment__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__attachment__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		attachment__rotate__AttributeData* attributeData = newData<attachment__rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__attachment__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ATTACHMENT__EXTRA = "attachment__extra";

	//---------------------------------------------------------------------
	const attachment__extra__AttributeData attachment__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__attachment__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		attachment__extra__AttributeData* attributeData = newData<attachment__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__attachment__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE_COMMON = "rigid_constraint__technique_common";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_constraint__technique_common( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__technique_common()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ENABLED = "enabled";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__ENABLED = "technique_common__enabled";

	//---------------------------------------------------------------------
	const enabled__AttributeData enabled__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__enabled( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__enabled);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__enabled( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		enabled__AttributeData* attributeData = newData<enabled__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ENABLED , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__enabled()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INTERPENETRATE = "interpenetrate";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__INTERPENETRATE = "technique_common__interpenetrate";

	//---------------------------------------------------------------------
	const interpenetrate__AttributeData interpenetrate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__interpenetrate( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__interpenetrate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__interpenetrate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		interpenetrate__AttributeData* attributeData = newData<interpenetrate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INTERPENETRATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__interpenetrate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIMITS = "limits";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__LIMITS = "technique_common__limits";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__limits( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__limits( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__limits()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SWING_CONE_AND_TWIST = "swing_cone_and_twist";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIMITS__SWING_CONE_AND_TWIST = "limits__swing_cone_and_twist";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MIN = "min";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SWING_CONE_AND_TWIST__MIN = "swing_cone_and_twist__min";

	//---------------------------------------------------------------------
	const swing_cone_and_twist__min__AttributeData swing_cone_and_twist__min__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist__min( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__swing_cone_and_twist__min);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		swing_cone_and_twist__min__AttributeData* attributeData = newData<swing_cone_and_twist__min__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SWING_CONE_AND_TWIST__MIN , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist__min()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_MAX = "max";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SWING_CONE_AND_TWIST__MAX = "swing_cone_and_twist__max";

	//---------------------------------------------------------------------
	const swing_cone_and_twist__max__AttributeData swing_cone_and_twist__max__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__swing_cone_and_twist__max( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__swing_cone_and_twist__max);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__swing_cone_and_twist__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		swing_cone_and_twist__max__AttributeData* attributeData = newData<swing_cone_and_twist__max__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SWING_CONE_AND_TWIST__MAX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__swing_cone_and_twist__max()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR = "linear";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIMITS__LINEAR = "limits__linear";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__limits__linear( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__limits__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__limits__linear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR__MIN = "linear__min";

	//---------------------------------------------------------------------
	const linear__min__AttributeData linear__min__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linear__min( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__min);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linear__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linear__min__AttributeData* attributeData = newData<linear__min__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__MIN , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linear__min()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR__MAX = "linear__max";

	//---------------------------------------------------------------------
	const linear__max__AttributeData linear__max__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linear__max( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__max);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linear__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linear__max__AttributeData* attributeData = newData<linear__max__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__MAX , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linear__max()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPRING = "spring";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE_COMMON__SPRING = "technique_common__spring";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spring( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spring( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spring()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANGULAR = "angular";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPRING__ANGULAR = "spring__angular";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__angular( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__angular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__angular()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_STIFFNESS = "stiffness";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANGULAR__STIFFNESS = "angular__stiffness";

	//---------------------------------------------------------------------
	const angular__stiffness__AttributeData angular__stiffness__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__angular__stiffness( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__angular__stiffness);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__angular__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		angular__stiffness__AttributeData* attributeData = newData<angular__stiffness__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__STIFFNESS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__angular__stiffness()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DAMPING = "damping";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANGULAR__DAMPING = "angular__damping";

	//---------------------------------------------------------------------
	const angular__damping__AttributeData angular__damping__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__angular__damping( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__angular__damping);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__angular__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		angular__damping__AttributeData* attributeData = newData<angular__damping__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__DAMPING , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__angular__damping()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TARGET_VALUE = "target_value";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ANGULAR__TARGET_VALUE = "angular__target_value";

	//---------------------------------------------------------------------
	const angular__target_value__AttributeData angular__target_value__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__angular__target_value( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__angular__target_value);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__angular__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		angular__target_value__AttributeData* attributeData = newData<angular__target_value__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__TARGET_VALUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__angular__target_value()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPRING__LINEAR = "spring__linear";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__spring__linear( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__spring__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__spring__linear()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR__STIFFNESS = "linear__stiffness";

	//---------------------------------------------------------------------
	const linear__stiffness__AttributeData linear__stiffness__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linear__stiffness( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__stiffness);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linear__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linear__stiffness__AttributeData* attributeData = newData<linear__stiffness__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__STIFFNESS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linear__stiffness()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR__DAMPING = "linear__damping";

	//---------------------------------------------------------------------
	const linear__damping__AttributeData linear__damping__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linear__damping( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__damping);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linear__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linear__damping__AttributeData* attributeData = newData<linear__damping__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__DAMPING , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linear__damping()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LINEAR__TARGET_VALUE = "linear__target_value";

	//---------------------------------------------------------------------
	const linear__target_value__AttributeData linear__target_value__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linear__target_value( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__linear__target_value);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linear__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linear__target_value__AttributeData* attributeData = newData<linear__target_value__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__TARGET_VALUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linear__target_value()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE = "rigid_constraint__technique";

	//---------------------------------------------------------------------
	const rigid_constraint__technique__AttributeData rigid_constraint__technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_constraint__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_constraint__technique__AttributeData* attributeData = newData<rigid_constraint__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_RIGID_CONSTRAINT__EXTRA = "rigid_constraint__extra";

	//---------------------------------------------------------------------
	const rigid_constraint__extra__AttributeData rigid_constraint__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rigid_constraint__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rigid_constraint__extra__AttributeData* attributeData = newData<rigid_constraint__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rigid_constraint__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL__INSTANCE_PHYSICS_MODEL = "physics_model__instance_physics_model";

	//---------------------------------------------------------------------
	const physics_model__instance_physics_model__AttributeData physics_model__instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_model__instance_physics_model( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_model__instance_physics_model__AttributeData* attributeData = newData<physics_model__instance_physics_model__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PARENT:
					{

						attributeData->parent = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL__INSTANCE_PHYSICS_MODEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__instance_physics_model()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHYSICS_MODEL__EXTRA = "physics_model__extra";

	//---------------------------------------------------------------------
	const physics_model__extra__AttributeData physics_model__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_model__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_model__extra__AttributeData* attributeData = newData<physics_model__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_model__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_PHYSICS_MODELS__EXTRA = "library_physics_models__extra";

	//---------------------------------------------------------------------
	const library_physics_models__extra__AttributeData library_physics_models__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_physics_models__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_physics_models__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_physics_models__extra__AttributeData* attributeData = newData<library_physics_models__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MODELS__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_physics_models__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES = "library_visual_scenes";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__LIBRARY_VISUAL_SCENES = "COLLADA__library_visual_scenes";

	//---------------------------------------------------------------------
	const library_visual_scenes__AttributeData library_visual_scenes__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_visual_scenes( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_visual_scenes__AttributeData* attributeData = newData<library_visual_scenes__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_VISUAL_SCENES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__ASSET = "library_visual_scenes__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_visual_scenes__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LIBRARY_VISUAL_SCENES__EXTRA = "library_visual_scenes__extra";

	//---------------------------------------------------------------------
	const library_visual_scenes__extra__AttributeData library_visual_scenes__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__library_visual_scenes__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__library_visual_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		library_visual_scenes__extra__AttributeData* attributeData = newData<library_visual_scenes__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_VISUAL_SCENES__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__library_visual_scenes__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCENE = "scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__SCENE = "COLLADA__scene";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_SCENE = "instance_physics_scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCENE__INSTANCE_PHYSICS_SCENE = "scene__instance_physics_scene";

	//---------------------------------------------------------------------
	const instance_physics_scene__AttributeData instance_physics_scene__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_scene__AttributeData* attributeData = newData<instance_physics_scene__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_SCENE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_PHYSICS_SCENE__EXTRA = "instance_physics_scene__extra";

	//---------------------------------------------------------------------
	const instance_physics_scene__extra__AttributeData instance_physics_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_scene__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_scene__extra__AttributeData* attributeData = newData<instance_physics_scene__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_SCENE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_scene__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_VISUAL_SCENE = "instance_visual_scene";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCENE__INSTANCE_VISUAL_SCENE = "scene__instance_visual_scene";

	//---------------------------------------------------------------------
	const instance_visual_scene__AttributeData instance_visual_scene__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_visual_scene( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_visual_scene__AttributeData* attributeData = newData<instance_visual_scene__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_VISUAL_SCENE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_visual_scene()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INSTANCE_VISUAL_SCENE__EXTRA = "instance_visual_scene__extra";

	//---------------------------------------------------------------------
	const instance_visual_scene__extra__AttributeData instance_visual_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_visual_scene__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_visual_scene__extra__AttributeData* attributeData = newData<instance_visual_scene__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_VISUAL_SCENE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_visual_scene__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SCENE__EXTRA = "scene__extra";

	//---------------------------------------------------------------------
	const scene__extra__AttributeData scene__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__scene__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		scene__extra__AttributeData* attributeData = newData<scene__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCENE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__scene__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_COLLADA__EXTRA = "COLLADA__extra";

	//---------------------------------------------------------------------
	const COLLADA__extra__AttributeData COLLADA__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__COLLADA__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__COLLADA__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		COLLADA__extra__AttributeData* attributeData = newData<COLLADA__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLLADA__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__COLLADA__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const param__AttributeData param__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__param( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__param(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		param__AttributeData* attributeData = newData<param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SEMANTIC:
					{

						attributeData->semantic = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const instance_geometry__AttributeData instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_geometry( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_geometry__AttributeData* attributeData = newData<instance_geometry__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_GEOMETRY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_geometry()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL = "profile_GLSL";

	//---------------------------------------------------------------------
	const profile_GLSL__AttributeData profile_GLSL__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__AttributeData* attributeData = newData<profile_GLSL__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__ASSET = "profile_GLSL__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CODE = "code";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__CODE = "profile_GLSL__code";

	//---------------------------------------------------------------------
	const profile_GLSL__code__AttributeData profile_GLSL__code__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__code( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__profile_GLSL__code(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__code__AttributeData* attributeData = newData<profile_GLSL__code__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__CODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__code()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INCLUDE = "include";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__INCLUDE = "profile_GLSL__include";

	//---------------------------------------------------------------------
	const profile_GLSL__include__AttributeData profile_GLSL__include__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__include( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__include__AttributeData* attributeData = newData<profile_GLSL__include__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__INCLUDE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__include()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__IMAGE = "profile_GLSL__image";

	//---------------------------------------------------------------------
	const profile_GLSL__image__AttributeData profile_GLSL__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__image__AttributeData* attributeData = newData<profile_GLSL__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__NEWPARAM = "profile_GLSL__newparam";

	//---------------------------------------------------------------------
	const profile_GLSL__newparam__AttributeData profile_GLSL__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__newparam__AttributeData* attributeData = newData<profile_GLSL__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY = "array";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__ARRAY = "newparam__array";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_LENGTH = "length";

	//---------------------------------------------------------------------
	const newparam__array__AttributeData newparam__array__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__array( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__array__AttributeData* attributeData = newData<newparam__array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_LENGTH:
					{
						bool failed;
						attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL = "array__bool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL2 = "array__bool2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL3 = "array__bool3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL4 = "array__bool4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT = "array__float";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT2 = "array__float2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT3 = "array__float3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT4 = "array__float4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT2X2 = "array__float2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT3X3 = "array__float3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT4X4 = "array__float4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT = "array__int";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT2 = "array__int2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT3 = "array__int3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT4 = "array__int4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SURFACE = "array__surface";

	//---------------------------------------------------------------------
	const array__surface__AttributeData array__surface__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__surface( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		array__surface__AttributeData* attributeData = newData<array__surface__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__SURFACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__surface()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR = "generator";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SURFACE__GENERATOR = "surface__generator";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR__ANNOTATE = "generator__annotate";

	//---------------------------------------------------------------------
	const generator__annotate__AttributeData generator__annotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator__annotate( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		generator__annotate__AttributeData* attributeData = newData<generator__annotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__ANNOTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator__annotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR__CODE = "generator__code";

	//---------------------------------------------------------------------
	const generator__code__AttributeData generator__code__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator__code( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__generator__code(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		generator__code__AttributeData* attributeData = newData<generator__code__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__CODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator__code()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR__INCLUDE = "generator__include";

	//---------------------------------------------------------------------
	const generator__include__AttributeData generator__include__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator__include( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		generator__include__AttributeData* attributeData = newData<generator__include__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__INCLUDE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator__include()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NAME = "name";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR__NAME = "generator__name";

	//---------------------------------------------------------------------
	const generator__name__AttributeData generator__name__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator__name( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__generator__name(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator__name( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		generator__name__AttributeData* attributeData = newData<generator__name__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__NAME , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator__name()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GENERATOR__SETPARAM = "generator__setparam";

	//---------------------------------------------------------------------
	const generator__setparam__AttributeData generator__setparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__generator__setparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__generator__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		generator__setparam__AttributeData* attributeData = newData<generator__setparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__SETPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__generator__setparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLER1D = "array__sampler1D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__sampler1D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler1D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLER2D = "array__sampler2D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__sampler2D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler2D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLER3D = "array__sampler3D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__sampler3D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__sampler3D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLERCUBE = "array__samplerCUBE";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__samplerCUBE( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerCUBE()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLERRECT = "array__samplerRECT";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__samplerRECT( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerRECT()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__SAMPLERDEPTH = "array__samplerDEPTH";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__samplerDEPTH( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__samplerDEPTH()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__ENUM = "array__enum";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__enum( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__array__enum(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__enum()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__ARRAY = "array__array";

	//---------------------------------------------------------------------
	const array__array__AttributeData array__array__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__array( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		array__array__AttributeData* attributeData = newData<array__array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_LENGTH:
					{
						bool failed;
						attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__TECHNIQUE = "profile_GLSL__technique";

	//---------------------------------------------------------------------
	const profile_GLSL__technique__AttributeData profile_GLSL__technique__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__technique__AttributeData* attributeData = newData<profile_GLSL__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__CODE = "technique__code";

	//---------------------------------------------------------------------
	const technique__code__AttributeData technique__code__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__code( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__technique__code(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__code__AttributeData* attributeData = newData<technique__code__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__CODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__code()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__INCLUDE = "technique__include";

	//---------------------------------------------------------------------
	const technique__include__AttributeData technique__include__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__include( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__include__AttributeData* attributeData = newData<technique__include__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__INCLUDE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__include()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_GLSL__EXTRA = "profile_GLSL__extra";

	//---------------------------------------------------------------------
	const profile_GLSL__extra__AttributeData profile_GLSL__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_GLSL__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_GLSL__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_GLSL__extra__AttributeData* attributeData = newData<profile_GLSL__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_GLSL__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const image__AttributeData image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const instance_physics_model__AttributeData instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_model( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_model__AttributeData* attributeData = newData<instance_physics_model__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PARENT:
					{

						attributeData->parent = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_model()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const physics_material__AttributeData physics_material__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const linestrips__AttributeData linestrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__linestrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		linestrips__AttributeData* attributeData = newData<linestrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__linestrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_GL_HOOK_ABSTRACT = "gl_hook_abstract";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PASS__GL_HOOK_ABSTRACT = "pass__gl_hook_abstract";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__gl_hook_abstract( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__gl_hook_abstract(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__gl_hook_abstract( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__gl_hook_abstract()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const node__AttributeData node__AttributeData::DEFAULT = {0, 0, 0, (const GeneratedSaxParser::ParserChar *)"NODE", 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__node( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				case HASH_ATTRIBUTE_LAYER:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__node()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const technique__AttributeData technique__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		technique__AttributeData* attributeData = newData<technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_PROFILE:
					{

						attributeData->profile = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const tristrips__AttributeData tristrips__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__tristrips( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		tristrips__AttributeData* attributeData = newData<tristrips__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__tristrips()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG = "profile_CG";

	//---------------------------------------------------------------------
	const profile_CG__AttributeData profile_CG__AttributeData::DEFAULT = {0, (const GeneratedSaxParser::ParserChar *)"PC"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__AttributeData* attributeData = newData<profile_CG__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_PLATFORM:
					{

						attributeData->platform = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__ASSET = "profile_CG__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__CODE = "profile_CG__code";

	//---------------------------------------------------------------------
	const profile_CG__code__AttributeData profile_CG__code__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__code( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__profile_CG__code(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__code__AttributeData* attributeData = newData<profile_CG__code__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__CODE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__code()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__INCLUDE = "profile_CG__include";

	//---------------------------------------------------------------------
	const profile_CG__include__AttributeData profile_CG__include__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__include( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__include__AttributeData* attributeData = newData<profile_CG__include__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__INCLUDE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__include()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__IMAGE = "profile_CG__image";

	//---------------------------------------------------------------------
	const profile_CG__image__AttributeData profile_CG__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__image__AttributeData* attributeData = newData<profile_CG__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__NEWPARAM = "profile_CG__newparam";

	//---------------------------------------------------------------------
	const profile_CG__newparam__AttributeData profile_CG__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__newparam__AttributeData* attributeData = newData<profile_CG__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL1 = "bool1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL1 = "newparam__bool1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL1X1 = "bool1x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL1X1 = "newparam__bool1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL1X2 = "bool1x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL1X2 = "newparam__bool1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL1X3 = "bool1x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL1X3 = "newparam__bool1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL1X4 = "bool1x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL1X4 = "newparam__bool1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL2X1 = "bool2x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL2X1 = "newparam__bool2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL2X2 = "bool2x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL2X2 = "newparam__bool2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL2X3 = "bool2x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL2X3 = "newparam__bool2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL2X4 = "bool2x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL2X4 = "newparam__bool2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL3X1 = "bool3x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL3X1 = "newparam__bool3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL3X2 = "bool3x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL3X2 = "newparam__bool3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL3X3 = "bool3x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL3X3 = "newparam__bool3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL3X4 = "bool3x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL3X4 = "newparam__bool3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL4X1 = "bool4x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL4X1 = "newparam__bool4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL4X2 = "bool4x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL4X2 = "newparam__bool4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL4X3 = "bool4x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL4X3 = "newparam__bool4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BOOL4X4 = "bool4x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__BOOL4X4 = "newparam__bool4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__bool4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__newparam__bool4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__bool4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FLOAT1 = "float1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FLOAT1 = "newparam__float1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__float1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__float1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__float1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT1 = "int1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT1 = "newparam__int1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT1X1 = "int1x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT1X1 = "newparam__int1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT1X2 = "int1x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT1X2 = "newparam__int1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT1X3 = "int1x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT1X3 = "newparam__int1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT1X4 = "int1x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT1X4 = "newparam__int1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT2X1 = "int2x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT2X1 = "newparam__int2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT2X2 = "int2x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT2X2 = "newparam__int2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT2X3 = "int2x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT2X3 = "newparam__int2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT2X4 = "int2x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT2X4 = "newparam__int2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT3X1 = "int3x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT3X1 = "newparam__int3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT3X2 = "int3x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT3X2 = "newparam__int3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT3X3 = "int3x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT3X3 = "newparam__int3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT3X4 = "int3x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT3X4 = "newparam__int3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT4X1 = "int4x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT4X1 = "newparam__int4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT4X2 = "int4x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT4X2 = "newparam__int4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT4X3 = "int4x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT4X3 = "newparam__int4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INT4X4 = "int4x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__INT4X4 = "newparam__int4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__int4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__newparam__int4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__int4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF = "half";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF = "newparam__half";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF1 = "half1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF1 = "newparam__half1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF2 = "half2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF2 = "newparam__half2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF3 = "half3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF3 = "newparam__half3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF4 = "half4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF4 = "newparam__half4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF1X1 = "half1x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF1X1 = "newparam__half1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF1X2 = "half1x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF1X2 = "newparam__half1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF1X3 = "half1x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF1X3 = "newparam__half1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF1X4 = "half1x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF1X4 = "newparam__half1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF2X1 = "half2x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF2X1 = "newparam__half2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF2X2 = "half2x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF2X2 = "newparam__half2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF2X3 = "half2x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF2X3 = "newparam__half2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF2X4 = "half2x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF2X4 = "newparam__half2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF3X1 = "half3x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF3X1 = "newparam__half3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF3X2 = "half3x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF3X2 = "newparam__half3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF3X3 = "half3x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF3X3 = "newparam__half3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF3X4 = "half3x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF3X4 = "newparam__half3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF4X1 = "half4x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF4X1 = "newparam__half4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF4X2 = "half4x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF4X2 = "newparam__half4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF4X3 = "half4x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF4X3 = "newparam__half4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_HALF4X4 = "half4x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__HALF4X4 = "newparam__half4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__half4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__half4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__half4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED = "fixed";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED = "newparam__fixed";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED1 = "fixed1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED1 = "newparam__fixed1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED2 = "fixed2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED2 = "newparam__fixed2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED3 = "fixed3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED3 = "newparam__fixed3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED4 = "fixed4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED4 = "newparam__fixed4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED1X1 = "fixed1x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED1X1 = "newparam__fixed1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED1X2 = "fixed1x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED1X2 = "newparam__fixed1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED1X3 = "fixed1x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED1X3 = "newparam__fixed1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED1X4 = "fixed1x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED1X4 = "newparam__fixed1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED2X1 = "fixed2x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED2X1 = "newparam__fixed2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED2X2 = "fixed2x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED2X2 = "newparam__fixed2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED2X3 = "fixed2x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED2X3 = "newparam__fixed2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED2X4 = "fixed2x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED2X4 = "newparam__fixed2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED3X1 = "fixed3x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED3X1 = "newparam__fixed3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED3X2 = "fixed3x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED3X2 = "newparam__fixed3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED3X3 = "fixed3x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED3X3 = "newparam__fixed3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED3X4 = "fixed3x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED3X4 = "newparam__fixed3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED4X1 = "fixed4x1";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED4X1 = "newparam__fixed4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED4X2 = "fixed4x2";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED4X2 = "newparam__fixed4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED4X3 = "fixed4x3";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED4X3 = "newparam__fixed4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_FIXED4X4 = "fixed4x4";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__FIXED4X4 = "newparam__fixed4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__fixed4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__newparam__fixed4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__fixed4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__STRING = "newparam__string";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__string( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__newparam__string(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__string()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE = "usertype";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_NEWPARAM__USERTYPE = "newparam__usertype";

	//---------------------------------------------------------------------
	const newparam__usertype__AttributeData newparam__usertype__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__newparam__usertype( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__newparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		newparam__usertype__AttributeData* attributeData = newData<newparam__usertype__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__USERTYPE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__newparam__usertype()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL = "usertype__bool";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL1 = "usertype__bool1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL2 = "usertype__bool2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL3 = "usertype__bool3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL4 = "usertype__bool4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL1X1 = "usertype__bool1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL1X2 = "usertype__bool1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL1X3 = "usertype__bool1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL1X4 = "usertype__bool1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL2X1 = "usertype__bool2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL2X2 = "usertype__bool2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL2X3 = "usertype__bool2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL2X4 = "usertype__bool2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL3X1 = "usertype__bool3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL3X2 = "usertype__bool3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL3X3 = "usertype__bool3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL3X4 = "usertype__bool3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL4X1 = "usertype__bool4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL4X2 = "usertype__bool4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL4X3 = "usertype__bool4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__BOOL4X4 = "usertype__bool4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__bool4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__usertype__bool4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__bool4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT = "usertype__float";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT1 = "usertype__float1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT2 = "usertype__float2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT3 = "usertype__float3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT4 = "usertype__float4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT1X1 = "usertype__float1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT1X2 = "usertype__float1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT1X3 = "usertype__float1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT1X4 = "usertype__float1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT2X1 = "usertype__float2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT2X2 = "usertype__float2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT2X3 = "usertype__float2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT2X4 = "usertype__float2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT3X1 = "usertype__float3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT3X2 = "usertype__float3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT3X3 = "usertype__float3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT3X4 = "usertype__float3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT4X1 = "usertype__float4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT4X2 = "usertype__float4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT4X3 = "usertype__float4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FLOAT4X4 = "usertype__float4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__float4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__float4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__float4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT = "usertype__int";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT1 = "usertype__int1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT2 = "usertype__int2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT3 = "usertype__int3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT4 = "usertype__int4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT1X1 = "usertype__int1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT1X2 = "usertype__int1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT1X3 = "usertype__int1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT1X4 = "usertype__int1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT2X1 = "usertype__int2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT2X2 = "usertype__int2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT2X3 = "usertype__int2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT2X4 = "usertype__int2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT3X1 = "usertype__int3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT3X2 = "usertype__int3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT3X3 = "usertype__int3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT3X4 = "usertype__int3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT4X1 = "usertype__int4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT4X2 = "usertype__int4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT4X3 = "usertype__int4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__INT4X4 = "usertype__int4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__int4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__usertype__int4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__int4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF = "usertype__half";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF1 = "usertype__half1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF2 = "usertype__half2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF3 = "usertype__half3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF4 = "usertype__half4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF1X1 = "usertype__half1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF1X2 = "usertype__half1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF1X3 = "usertype__half1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF1X4 = "usertype__half1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF2X1 = "usertype__half2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF2X2 = "usertype__half2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF2X3 = "usertype__half2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF2X4 = "usertype__half2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF3X1 = "usertype__half3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF3X2 = "usertype__half3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF3X3 = "usertype__half3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF3X4 = "usertype__half3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF4X1 = "usertype__half4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF4X2 = "usertype__half4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF4X3 = "usertype__half4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__HALF4X4 = "usertype__half4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__half4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__half4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__half4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED = "usertype__fixed";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED1 = "usertype__fixed1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED2 = "usertype__fixed2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED3 = "usertype__fixed3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED4 = "usertype__fixed4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED1X1 = "usertype__fixed1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED1X2 = "usertype__fixed1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED1X3 = "usertype__fixed1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED1X4 = "usertype__fixed1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED2X1 = "usertype__fixed2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED2X2 = "usertype__fixed2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED2X3 = "usertype__fixed2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED2X4 = "usertype__fixed2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED3X1 = "usertype__fixed3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED3X2 = "usertype__fixed3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED3X3 = "usertype__fixed3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED3X4 = "usertype__fixed3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED4X1 = "usertype__fixed4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED4X2 = "usertype__fixed4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED4X3 = "usertype__fixed4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__FIXED4X4 = "usertype__fixed4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__fixed4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__usertype__fixed4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__fixed4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SURFACE = "usertype__surface";

	//---------------------------------------------------------------------
	const usertype__surface__AttributeData usertype__surface__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__surface( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		usertype__surface__AttributeData* attributeData = newData<usertype__surface__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TYPE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__SURFACE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__surface()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLER1D = "usertype__sampler1D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__sampler1D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler1D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLER2D = "usertype__sampler2D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__sampler2D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler2D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLER3D = "usertype__sampler3D";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__sampler3D( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__sampler3D()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLERRECT = "usertype__samplerRECT";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__samplerRECT( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerRECT()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLERCUBE = "usertype__samplerCUBE";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__samplerCUBE( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerCUBE()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SAMPLERDEPTH = "usertype__samplerDEPTH";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__samplerDEPTH( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__samplerDEPTH()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__STRING = "usertype__string";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__string( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__usertype__string(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__string()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__ENUM = "usertype__enum";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__enum( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__usertype__enum(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__enum()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__ARRAY = "usertype__array";

	//---------------------------------------------------------------------
	const usertype__array__AttributeData usertype__array__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__array( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		usertype__array__AttributeData* attributeData = newData<usertype__array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_LENGTH:
					{
						bool failed;
						attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL1 = "array__bool1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL1X1 = "array__bool1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL1X2 = "array__bool1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL1X3 = "array__bool1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL1X4 = "array__bool1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL2X1 = "array__bool2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL2X2 = "array__bool2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL2X3 = "array__bool2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL2X4 = "array__bool2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL3X1 = "array__bool3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL3X2 = "array__bool3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL3X3 = "array__bool3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL3X4 = "array__bool3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL4X1 = "array__bool4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL4X2 = "array__bool4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL4X3 = "array__bool4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__BOOL4X4 = "array__bool4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__bool4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__array__bool4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__bool4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT1 = "array__float1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT1X1 = "array__float1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT1X2 = "array__float1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT1X3 = "array__float1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT1X4 = "array__float1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT2X1 = "array__float2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT2X3 = "array__float2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT2X4 = "array__float2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT3X1 = "array__float3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT3X2 = "array__float3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT3X4 = "array__float3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT4X1 = "array__float4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT4X2 = "array__float4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FLOAT4X3 = "array__float4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__float4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__float4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__float4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT1 = "array__int1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT1X1 = "array__int1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT1X2 = "array__int1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT1X3 = "array__int1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT1X4 = "array__int1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT2X1 = "array__int2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT2X2 = "array__int2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT2X3 = "array__int2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT2X4 = "array__int2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT3X1 = "array__int3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT3X2 = "array__int3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT3X3 = "array__int3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT3X4 = "array__int3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT4X1 = "array__int4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT4X2 = "array__int4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT4X3 = "array__int4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__INT4X4 = "array__int4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__int4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__array__int4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__int4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF = "array__half";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF1 = "array__half1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF2 = "array__half2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF3 = "array__half3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF4 = "array__half4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF1X1 = "array__half1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF1X2 = "array__half1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF1X3 = "array__half1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF1X4 = "array__half1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF2X1 = "array__half2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF2X2 = "array__half2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF2X3 = "array__half2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF2X4 = "array__half2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF3X1 = "array__half3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF3X2 = "array__half3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF3X3 = "array__half3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF3X4 = "array__half3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF4X1 = "array__half4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF4X2 = "array__half4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF4X3 = "array__half4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__HALF4X4 = "array__half4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__half4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__half4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__half4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED = "array__fixed";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED1 = "array__fixed1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED2 = "array__fixed2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED3 = "array__fixed3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED4 = "array__fixed4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED1X1 = "array__fixed1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED1X2 = "array__fixed1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED1X3 = "array__fixed1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED1X4 = "array__fixed1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED2X1 = "array__fixed2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED2X2 = "array__fixed2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED2X3 = "array__fixed2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED2X4 = "array__fixed2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED3X1 = "array__fixed3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED3X2 = "array__fixed3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED3X3 = "array__fixed3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED3X4 = "array__fixed3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED4X1 = "array__fixed4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED4X2 = "array__fixed4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED4X3 = "array__fixed4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__FIXED4X4 = "array__fixed4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__fixed4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__array__fixed4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__fixed4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__STRING = "array__string";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__string( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__array__string(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__string()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_ARRAY__USERTYPE = "array__usertype";

	//---------------------------------------------------------------------
	const array__usertype__AttributeData array__usertype__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__array__usertype( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__array__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		array__usertype__AttributeData* attributeData = newData<array__usertype__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__USERTYPE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__array__usertype()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__USERTYPE = "usertype__usertype";

	//---------------------------------------------------------------------
	const usertype__usertype__AttributeData usertype__usertype__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__usertype( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		usertype__usertype__AttributeData* attributeData = newData<usertype__usertype__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__USERTYPE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__usertype()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONNECT_PARAM = "connect_param";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__CONNECT_PARAM = "usertype__connect_param";

	//---------------------------------------------------------------------
	const usertype__connect_param__AttributeData usertype__connect_param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__connect_param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		usertype__connect_param__AttributeData* attributeData = newData<usertype__connect_param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__CONNECT_PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__connect_param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_USERTYPE__SETPARAM = "usertype__setparam";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_PROGRAM = "program";

	//---------------------------------------------------------------------
	const usertype__setparam__AttributeData usertype__setparam__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__usertype__setparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__usertype__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		usertype__setparam__AttributeData* attributeData = newData<usertype__setparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{



						break;
					}
				case HASH_ATTRIBUTE_PROGRAM:
					{

						attributeData->program = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__SETPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__usertype__setparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL1 = "setparam__bool1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL1X1 = "setparam__bool1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL1X2 = "setparam__bool1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL1X3 = "setparam__bool1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL1X4 = "setparam__bool1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL2X1 = "setparam__bool2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL2X2 = "setparam__bool2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL2X3 = "setparam__bool2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL2X4 = "setparam__bool2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL3X1 = "setparam__bool3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL3X2 = "setparam__bool3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL3X3 = "setparam__bool3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL3X4 = "setparam__bool3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL4X1 = "setparam__bool4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL4X2 = "setparam__bool4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL4X3 = "setparam__bool4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__BOOL4X4 = "setparam__bool4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__bool4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2BoolData(text, textLength, &ColladaParserAutoGen::data__setparam__bool4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__bool4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FLOAT1 = "setparam__float1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__float1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__float1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__float1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT1 = "setparam__int1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT1X1 = "setparam__int1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT1X2 = "setparam__int1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT1X3 = "setparam__int1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT1X4 = "setparam__int1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT2X1 = "setparam__int2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT2X2 = "setparam__int2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT2X3 = "setparam__int2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT2X4 = "setparam__int2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT3X1 = "setparam__int3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT3X2 = "setparam__int3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT3X3 = "setparam__int3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT3X4 = "setparam__int3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT4X1 = "setparam__int4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT4X2 = "setparam__int4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT4X3 = "setparam__int4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__INT4X4 = "setparam__int4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__int4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__setparam__int4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__int4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF = "setparam__half";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF1 = "setparam__half1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF2 = "setparam__half2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF3 = "setparam__half3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF4 = "setparam__half4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF1X1 = "setparam__half1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF1X2 = "setparam__half1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF1X3 = "setparam__half1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF1X4 = "setparam__half1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF2X1 = "setparam__half2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF2X2 = "setparam__half2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF2X3 = "setparam__half2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF2X4 = "setparam__half2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF3X1 = "setparam__half3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF3X2 = "setparam__half3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF3X3 = "setparam__half3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF3X4 = "setparam__half3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF4X1 = "setparam__half4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF4X2 = "setparam__half4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF4X3 = "setparam__half4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__HALF4X4 = "setparam__half4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__half4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__half4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__half4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED = "setparam__fixed";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED1 = "setparam__fixed1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED2 = "setparam__fixed2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED3 = "setparam__fixed3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED4 = "setparam__fixed4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED1X1 = "setparam__fixed1x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED1X2 = "setparam__fixed1x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED1X3 = "setparam__fixed1x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED1X4 = "setparam__fixed1x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed1x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed1x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed1x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED2X1 = "setparam__fixed2x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED2X2 = "setparam__fixed2x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED2X3 = "setparam__fixed2x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED2X4 = "setparam__fixed2x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed2x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed2x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed2x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED3X1 = "setparam__fixed3x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED3X2 = "setparam__fixed3x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED3X3 = "setparam__fixed3x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED3X4 = "setparam__fixed3x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed3x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed3x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed3x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED4X1 = "setparam__fixed4x1";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x1( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x1);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x1()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED4X2 = "setparam__fixed4x2";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x2( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x2);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x2()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED4X3 = "setparam__fixed4x3";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x3( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x3);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x3()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__FIXED4X4 = "setparam__fixed4x4";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__fixed4x4( const ParserChar* text, size_t textLength )
	{
		return characterData2FloatData(text, textLength, &ColladaParserAutoGen::data__setparam__fixed4x4);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__fixed4x4()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__STRING = "setparam__string";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__string( const ParserChar* text, size_t textLength )
	{
		return mImpl->data__setparam__string(text, textLength);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__string()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__USERTYPE = "setparam__usertype";

	//---------------------------------------------------------------------
	const setparam__usertype__AttributeData setparam__usertype__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__usertype( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__usertype__AttributeData* attributeData = newData<setparam__usertype__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{



						break;
					}
				case HASH_ATTRIBUTE_SOURCE:
					{

						attributeData->source = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__USERTYPE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__usertype()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__ARRAY = "setparam__array";

	//---------------------------------------------------------------------
	const setparam__array__AttributeData setparam__array__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__array( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__array__AttributeData* attributeData = newData<setparam__array__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_LENGTH:
					{
						bool failed;
						attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
						if ( failed && handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
						{return false;}
						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ARRAY , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__array()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SETPARAM__CONNECT_PARAM = "setparam__connect_param";

	//---------------------------------------------------------------------
	const setparam__connect_param__AttributeData setparam__connect_param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__setparam__connect_param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__setparam__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		setparam__connect_param__AttributeData* attributeData = newData<setparam__connect_param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__CONNECT_PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__setparam__connect_param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__TECHNIQUE = "profile_CG__technique";

	//---------------------------------------------------------------------
	const profile_CG__technique__AttributeData profile_CG__technique__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__technique__AttributeData* attributeData = newData<profile_CG__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_CG__EXTRA = "profile_CG__extra";

	//---------------------------------------------------------------------
	const profile_CG__extra__AttributeData profile_CG__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_CG__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_CG__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_CG__extra__AttributeData* attributeData = newData<profile_CG__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_CG__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON = "profile_COMMON";

	//---------------------------------------------------------------------
	const profile_COMMON__AttributeData profile_COMMON__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_COMMON__AttributeData* attributeData = newData<profile_COMMON__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON__ASSET = "profile_COMMON__asset";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON__IMAGE = "profile_COMMON__image";

	//---------------------------------------------------------------------
	const profile_COMMON__image__AttributeData profile_COMMON__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const GeneratedSaxParser::ParserChar *)"1"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON__image( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_COMMON__image__AttributeData* attributeData = newData<profile_COMMON__image__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_FORMAT:
					{

						attributeData->format = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_HEIGHT:
					{



						break;
					}
				case HASH_ATTRIBUTE_WIDTH:
					{



						break;
					}
				case HASH_ATTRIBUTE_DEPTH:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__IMAGE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__image()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON__NEWPARAM = "profile_COMMON__newparam";

	//---------------------------------------------------------------------
	const profile_COMMON__newparam__AttributeData profile_COMMON__newparam__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON__newparam( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_COMMON__newparam__AttributeData* attributeData = newData<profile_COMMON__newparam__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__NEWPARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__newparam()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON__TECHNIQUE = "profile_COMMON__technique";

	//---------------------------------------------------------------------
	const profile_COMMON__technique__AttributeData profile_COMMON__technique__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON__technique( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_COMMON__technique__AttributeData* attributeData = newData<profile_COMMON__technique__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__TECHNIQUE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__technique()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__CONSTANT = "technique__constant";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__technique__constant( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__technique__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__technique__constant()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EMISSION = "emission";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__EMISSION = "constant__emission";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__emission( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__emission()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EMISSION__COLOR = "emission__color";

	//---------------------------------------------------------------------
	const emission__color__AttributeData emission__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__emission__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__emission__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__emission__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		emission__color__AttributeData* attributeData = newData<emission__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__emission__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EMISSION__PARAM = "emission__param";

	//---------------------------------------------------------------------
	const emission__param__AttributeData emission__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__emission__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__emission__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		emission__param__AttributeData* attributeData = newData<emission__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__emission__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE = "texture";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_EMISSION__TEXTURE = "emission__texture";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_TEXTURE = "texture";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_TEXCOORD = "texcoord";

	//---------------------------------------------------------------------
	const emission__texture__AttributeData emission__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__emission__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__emission__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		emission__texture__AttributeData* attributeData = newData<emission__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__emission__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TEXTURE__EXTRA = "texture__extra";

	//---------------------------------------------------------------------
	const texture__extra__AttributeData texture__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__texture__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__texture__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		texture__extra__AttributeData* attributeData = newData<texture__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__texture__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVE = "reflective";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__REFLECTIVE = "constant__reflective";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__reflective( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__reflective()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVE__COLOR = "reflective__color";

	//---------------------------------------------------------------------
	const reflective__color__AttributeData reflective__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__reflective__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__reflective__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__reflective__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		reflective__color__AttributeData* attributeData = newData<reflective__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__reflective__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVE__PARAM = "reflective__param";

	//---------------------------------------------------------------------
	const reflective__param__AttributeData reflective__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__reflective__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__reflective__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		reflective__param__AttributeData* attributeData = newData<reflective__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__reflective__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVE__TEXTURE = "reflective__texture";

	//---------------------------------------------------------------------
	const reflective__texture__AttributeData reflective__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__reflective__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__reflective__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		reflective__texture__AttributeData* attributeData = newData<reflective__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__reflective__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVITY = "reflectivity";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__REFLECTIVITY = "constant__reflectivity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__reflectivity( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__reflectivity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVITY__FLOAT = "reflectivity__float";

	//---------------------------------------------------------------------
	const reflectivity__float__AttributeData reflectivity__float__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__reflectivity__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__reflectivity__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__reflectivity__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		reflectivity__float__AttributeData* attributeData = newData<reflectivity__float__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVITY__FLOAT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__reflectivity__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_REFLECTIVITY__PARAM = "reflectivity__param";

	//---------------------------------------------------------------------
	const reflectivity__param__AttributeData reflectivity__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__reflectivity__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__reflectivity__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		reflectivity__param__AttributeData* attributeData = newData<reflectivity__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVITY__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__reflectivity__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENT = "transparent";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__TRANSPARENT = "constant__transparent";

	//---------------------------------------------------------------------
	const char* NAME_ATTRIBUTE_OPAQUE = "opaque";

	//---------------------------------------------------------------------
	const constant__transparent__AttributeData constant__transparent__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"A_ONE"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__transparent( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		constant__transparent__AttributeData* attributeData = newData<constant__transparent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OPAQUE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONSTANT__TRANSPARENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__transparent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENT__COLOR = "transparent__color";

	//---------------------------------------------------------------------
	const transparent__color__AttributeData transparent__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__transparent__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__transparent__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__transparent__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		transparent__color__AttributeData* attributeData = newData<transparent__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__transparent__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENT__PARAM = "transparent__param";

	//---------------------------------------------------------------------
	const transparent__param__AttributeData transparent__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__transparent__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__transparent__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		transparent__param__AttributeData* attributeData = newData<transparent__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__transparent__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENT__TEXTURE = "transparent__texture";

	//---------------------------------------------------------------------
	const transparent__texture__AttributeData transparent__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__transparent__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__transparent__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		transparent__texture__AttributeData* attributeData = newData<transparent__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__transparent__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENCY = "transparency";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__TRANSPARENCY = "constant__transparency";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__transparency( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__transparency()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENCY__FLOAT = "transparency__float";

	//---------------------------------------------------------------------
	const transparency__float__AttributeData transparency__float__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__transparency__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__transparency__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__transparency__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		transparency__float__AttributeData* attributeData = newData<transparency__float__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENCY__FLOAT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__transparency__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TRANSPARENCY__PARAM = "transparency__param";

	//---------------------------------------------------------------------
	const transparency__param__AttributeData transparency__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__transparency__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__transparency__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		transparency__param__AttributeData* attributeData = newData<transparency__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENCY__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__transparency__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INDEX_OF_REFRACTION = "index_of_refraction";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_CONSTANT__INDEX_OF_REFRACTION = "constant__index_of_refraction";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__constant__index_of_refraction( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__constant__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__constant__index_of_refraction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INDEX_OF_REFRACTION__FLOAT = "index_of_refraction__float";

	//---------------------------------------------------------------------
	const index_of_refraction__float__AttributeData index_of_refraction__float__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__index_of_refraction__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__index_of_refraction__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__index_of_refraction__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		index_of_refraction__float__AttributeData* attributeData = newData<index_of_refraction__float__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INDEX_OF_REFRACTION__FLOAT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__index_of_refraction__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_INDEX_OF_REFRACTION__PARAM = "index_of_refraction__param";

	//---------------------------------------------------------------------
	const index_of_refraction__param__AttributeData index_of_refraction__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__index_of_refraction__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__index_of_refraction__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		index_of_refraction__param__AttributeData* attributeData = newData<index_of_refraction__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INDEX_OF_REFRACTION__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__index_of_refraction__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT = "lambert";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__LAMBERT = "technique__lambert";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__EMISSION = "lambert__emission";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__emission( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__emission()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__AMBIENT = "lambert__ambient";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AMBIENT__PARAM = "ambient__param";

	//---------------------------------------------------------------------
	const ambient__param__AttributeData ambient__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ambient__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ambient__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ambient__param__AttributeData* attributeData = newData<ambient__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ambient__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_AMBIENT__TEXTURE = "ambient__texture";

	//---------------------------------------------------------------------
	const ambient__texture__AttributeData ambient__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__ambient__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__ambient__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		ambient__texture__AttributeData* attributeData = newData<ambient__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__ambient__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIFFUSE = "diffuse";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__DIFFUSE = "lambert__diffuse";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__diffuse( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__diffuse()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIFFUSE__COLOR = "diffuse__color";

	//---------------------------------------------------------------------
	const diffuse__color__AttributeData diffuse__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__diffuse__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__diffuse__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		diffuse__color__AttributeData* attributeData = newData<diffuse__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIFFUSE__PARAM = "diffuse__param";

	//---------------------------------------------------------------------
	const diffuse__param__AttributeData diffuse__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__diffuse__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		diffuse__param__AttributeData* attributeData = newData<diffuse__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_DIFFUSE__TEXTURE = "diffuse__texture";

	//---------------------------------------------------------------------
	const diffuse__texture__AttributeData diffuse__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__diffuse__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__diffuse__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		diffuse__texture__AttributeData* attributeData = newData<diffuse__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__diffuse__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__REFLECTIVE = "lambert__reflective";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__reflective( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__reflective()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__REFLECTIVITY = "lambert__reflectivity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__reflectivity( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__reflectivity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__TRANSPARENT = "lambert__transparent";

	//---------------------------------------------------------------------
	const lambert__transparent__AttributeData lambert__transparent__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"A_ONE"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__transparent( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		lambert__transparent__AttributeData* attributeData = newData<lambert__transparent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OPAQUE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LAMBERT__TRANSPARENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__transparent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__TRANSPARENCY = "lambert__transparency";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__transparency( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__transparency()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_LAMBERT__INDEX_OF_REFRACTION = "lambert__index_of_refraction";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__lambert__index_of_refraction( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__lambert__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__lambert__index_of_refraction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG = "phong";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__PHONG = "technique__phong";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__EMISSION = "phong__emission";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__emission( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__emission()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__AMBIENT = "phong__ambient";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__DIFFUSE = "phong__diffuse";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__diffuse( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__diffuse()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPECULAR = "specular";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__SPECULAR = "phong__specular";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__specular( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__specular()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPECULAR__COLOR = "specular__color";

	//---------------------------------------------------------------------
	const specular__color__AttributeData specular__color__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__specular__color( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__specular__color);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__specular__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		specular__color__AttributeData* attributeData = newData<specular__color__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__COLOR , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__specular__color()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPECULAR__PARAM = "specular__param";

	//---------------------------------------------------------------------
	const specular__param__AttributeData specular__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__specular__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__specular__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		specular__param__AttributeData* attributeData = newData<specular__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__specular__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SPECULAR__TEXTURE = "specular__texture";

	//---------------------------------------------------------------------
	const specular__texture__AttributeData specular__texture__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__specular__texture( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__specular__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		specular__texture__AttributeData* attributeData = newData<specular__texture__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_TEXTURE:
					{

						attributeData->texture = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TEXCOORD:
					{

						attributeData->texcoord = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__TEXTURE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__specular__texture()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHININESS = "shininess";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__SHININESS = "phong__shininess";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__shininess( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__shininess()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHININESS__FLOAT = "shininess__float";

	//---------------------------------------------------------------------
	const shininess__float__AttributeData shininess__float__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shininess__float( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__shininess__float);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shininess__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shininess__float__AttributeData* attributeData = newData<shininess__float__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHININESS__FLOAT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shininess__float()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_SHININESS__PARAM = "shininess__param";

	//---------------------------------------------------------------------
	const shininess__param__AttributeData shininess__param__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__shininess__param( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__shininess__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		shininess__param__AttributeData* attributeData = newData<shininess__param__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_REF:
					{

						attributeData->ref = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHININESS__PARAM , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__shininess__param()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__REFLECTIVE = "phong__reflective";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__reflective( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__reflective()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__REFLECTIVITY = "phong__reflectivity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__reflectivity( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__reflectivity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__TRANSPARENT = "phong__transparent";

	//---------------------------------------------------------------------
	const phong__transparent__AttributeData phong__transparent__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"A_ONE"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__transparent( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		phong__transparent__AttributeData* attributeData = newData<phong__transparent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OPAQUE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHONG__TRANSPARENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__transparent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__TRANSPARENCY = "phong__transparency";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__transparency( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__transparency()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PHONG__INDEX_OF_REFRACTION = "phong__index_of_refraction";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__phong__index_of_refraction( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__phong__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__phong__index_of_refraction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN = "blinn";

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_TECHNIQUE__BLINN = "technique__blinn";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__EMISSION = "blinn__emission";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__emission( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__emission()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__AMBIENT = "blinn__ambient";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__ambient( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__ambient()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__DIFFUSE = "blinn__diffuse";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__diffuse( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__diffuse()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__SPECULAR = "blinn__specular";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__specular( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__specular()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__SHININESS = "blinn__shininess";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__shininess( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__shininess()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__REFLECTIVE = "blinn__reflective";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__reflective( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__reflective()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__REFLECTIVITY = "blinn__reflectivity";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__reflectivity( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__reflectivity()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__TRANSPARENT = "blinn__transparent";

	//---------------------------------------------------------------------
	const blinn__transparent__AttributeData blinn__transparent__AttributeData::DEFAULT = {(const GeneratedSaxParser::ParserChar *)"A_ONE"};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__transparent( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		blinn__transparent__AttributeData* attributeData = newData<blinn__transparent__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_OPAQUE:
					{



						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLINN__TRANSPARENT , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__transparent()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__TRANSPARENCY = "blinn__transparency";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__transparency( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__transparency()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_BLINN__INDEX_OF_REFRACTION = "blinn__index_of_refraction";

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__blinn__index_of_refraction( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__blinn__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__blinn__index_of_refraction()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const char* NAME_ELEMENT_PROFILE_COMMON__EXTRA = "profile_COMMON__extra";

	//---------------------------------------------------------------------
	const profile_COMMON__extra__AttributeData profile_COMMON__extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__profile_COMMON__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__profile_COMMON__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		profile_COMMON__extra__AttributeData* attributeData = newData<profile_COMMON__extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__profile_COMMON__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const triangles__AttributeData triangles__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__triangles( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		triangles__AttributeData* attributeData = newData<triangles__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__triangles()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const rotate__AttributeData rotate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__rotate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__rotate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ROTATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__rotate()
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__bind_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__bind_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const instance_force_field__AttributeData instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_force_field( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_force_field__AttributeData* attributeData = newData<instance_force_field__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_FORCE_FIELD , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_force_field()
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__asset( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__asset()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const polygons__AttributeData polygons__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polygons( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polygons__AttributeData* attributeData = newData<polygons__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polygons()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const vertices__AttributeData vertices__AttributeData::DEFAULT = {0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__vertices( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		vertices__AttributeData* attributeData = newData<vertices__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__vertices()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const extra__AttributeData extra__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__extra( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_ID:
					{

						attributeData->id = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_TYPE:
					{

						attributeData->type = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EXTRA , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__extra()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const instance_physics_material__AttributeData instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__instance_physics_material( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		instance_physics_material__AttributeData* attributeData = newData<instance_physics_material__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_URL:
					{

						attributeData->url = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__instance_physics_material()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const polylist__AttributeData polylist__AttributeData::DEFAULT = {0, 0, 0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__polylist( const ParserChar* text, size_t textLength )
	{
		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		polylist__AttributeData* attributeData = newData<polylist__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_NAME:
					{

						attributeData->name = attributeValue;

						break;
					}
				case HASH_ATTRIBUTE_COUNT:
					{



						break;
					}
				case HASH_ATTRIBUTE_MATERIAL:
					{

						attributeData->material = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__polylist()
	{
		return true;
	}

	//---------------------------------------------------------------------
	const translate__AttributeData translate__AttributeData::DEFAULT = {0};

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_data__translate( const ParserChar* text, size_t textLength )
	{
		return characterData2DoubleData(text, textLength, &ColladaParserAutoGen::data__translate);
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateBegin__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
	{
		translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

		const ParserChar** attributeArray = attributes.attributes;
		if ( attributeArray )
		{
			while (true)
			{
				const ParserChar * attribute = *attributeArray;
				if ( !attribute ) 
					break;
				StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
				attributeArray++;
				if ( !attributeArray )
					return false;
				const ParserChar* attributeValue = *attributeArray;
				attributeArray++;


				switch ( hash )
				{
				case HASH_ATTRIBUTE_SID:
					{

						attributeData->sid = attributeValue;

						break;
					}
				default:
					{
						if ( handleError(ParserError::SEVERITY_ERROR,ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSLATE , 0, attributeValue))
						{return false;}
					}
				}
			}
		}

		return true;
	}

	//---------------------------------------------------------------------
	bool ColladaParserAutoGenPrivate::_validateEnd__translate()
	{
		return true;
	}




}
