/*
    Copyright (c) 2008 NetAllied Systems GmbH

    This file is part of COLLADASaxFrameworkLoader.

    Licensed under the MIT Open Source License, 
    for details please see LICENSE file or the website
    http://www.opensource.org/licenses/mit-license.php
*/

#include "COLLADASaxFWLStableHeaders.h"
#include "GeneratedSaxParserUtils.h"
#include "COLLADASaxFWLColladaParserAutoGen.h"


namespace COLLADASaxFWL
{


//---------------------------------------------------------------------
const char* ColladaParserAutoGen::PARENT_CHILD_ELEMENT_SEPARATOR = "__";


//---------------------------------------------------------------------
ColladaParserAutoGen::ColladaParserAutoGen( GeneratedSaxParser::IErrorHandler* errorHandler )
    : GeneratedSaxParser::ParserTemplate<ColladaParserAutoGen>(errorHandler)
{
    initFunctionMap();
    initNameMap();
}

//---------------------------------------------------------------------
ColladaParserAutoGen::~ColladaParserAutoGen()
{
}


//---------------------------------------------------------------------
const ColladaParserAutoGen::library_force_fields__AttributeData ColladaParserAutoGen::library_force_fields__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_force_fields( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_force_fields( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_force_fields__AttributeData* attributeData = newData<library_force_fields__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_FORCE_FIELDS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_force_fields()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_force_fields__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_force_fields__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_force_fields__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__contributor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__contributor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__contributor()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__author( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__author( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__author()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__authoring_tool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__authoring_tool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__authoring_tool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__comments( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__comments( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__comments()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__copyright( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__copyright( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__copyright()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__source_data( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__source_data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__source_data()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__created( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__created( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__created()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__keywords( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__keywords( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__keywords()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__modified( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__modified( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__modified()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__revision( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__revision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__revision()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__subject( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__subject( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__subject()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__title( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__title( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__title()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::unit__AttributeData ColladaParserAutoGen::unit__AttributeData::DEFAULT = {1.0E0, (const ParserChar *)"meter"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
unit__AttributeData* attributeData = newData<unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METER:
    {
bool failed;
attributeData->meter = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_UNIT, HASH_ATTRIBUTE_METER, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_UNIT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__unit()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__up_axis( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__up_axis( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__up_axis()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::force_field__AttributeData ColladaParserAutoGen::force_field__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
force_field__AttributeData* attributeData = newData<force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__force_field()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__force_field__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__force_field__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__force_field__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::force_field__technique__AttributeData ColladaParserAutoGen::force_field__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__force_field__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__force_field__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
force_field__technique__AttributeData* attributeData = newData<force_field__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__force_field__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::force_field__extra__AttributeData ColladaParserAutoGen::force_field__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__force_field__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
force_field__extra__AttributeData* attributeData = newData<force_field__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORCE_FIELD__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__force_field__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__extra__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__extra__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__extra__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::extra__technique__AttributeData ColladaParserAutoGen::extra__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__extra__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__extra__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__technique__AttributeData* attributeData = newData<extra__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EXTRA__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__extra__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_force_fields__extra__AttributeData ColladaParserAutoGen::library_force_fields__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_force_fields__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_force_fields__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_force_fields__extra__AttributeData* attributeData = newData<library_force_fields__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_FORCE_FIELDS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_force_fields__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_effect__AttributeData ColladaParserAutoGen::instance_effect__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__AttributeData* attributeData = newData<instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_effect()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique_hint__AttributeData ColladaParserAutoGen::technique_hint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique_hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique_hint__AttributeData* attributeData = newData<technique_hint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_HINT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique_hint()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_effect__setparam__AttributeData ColladaParserAutoGen::instance_effect__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_effect__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_effect__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__setparam__AttributeData* attributeData = newData<instance_effect__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT__SETPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_effect__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float4x4()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__surface__AttributeData ColladaParserAutoGen::setparam__surface__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__surface__AttributeData* attributeData = newData<setparam__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__SURFACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_as_null( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_as_null( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_as_null()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_as_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_as_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_as_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_cube( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_cube( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_cube()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_cube__all__AttributeData ColladaParserAutoGen::init_cube__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_cube__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_cube__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__all__AttributeData* attributeData = newData<init_cube__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__ALL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_cube__all()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_cube__primary__AttributeData ColladaParserAutoGen::init_cube__primary__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_cube__primary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_cube__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__primary__AttributeData* attributeData = newData<init_cube__primary__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__PRIMARY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_cube__primary()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__order( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__order( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__order()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_cube__face__AttributeData ColladaParserAutoGen::init_cube__face__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_cube__face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_cube__face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_cube__face__AttributeData* attributeData = newData<init_cube__face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_CUBE__FACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_cube__face()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_volume( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_volume( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_volume()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_volume__all__AttributeData ColladaParserAutoGen::init_volume__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_volume__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_volume__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_volume__all__AttributeData* attributeData = newData<init_volume__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_VOLUME__ALL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_volume__all()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_volume__primary__AttributeData ColladaParserAutoGen::init_volume__primary__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_volume__primary( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_volume__primary( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_volume__primary__AttributeData* attributeData = newData<init_volume__primary__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_VOLUME__PRIMARY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_volume__primary()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_planar( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_planar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_planar()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::init_planar__all__AttributeData ColladaParserAutoGen::init_planar__all__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__init_planar__all( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__init_planar__all( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
init_planar__all__AttributeData* attributeData = newData<init_planar__all__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INIT_PLANAR__ALL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__init_planar__all()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::surface__init_from__AttributeData ColladaParserAutoGen::surface__init_from__AttributeData::DEFAULT = {0, 0, (const ParserChar *)"POSITIVE_X"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__surface__init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__surface__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
surface__init_from__AttributeData* attributeData = newData<surface__init_from__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_MIP:
    {
bool failed;
attributeData->mip = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_MIP, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_SLICE:
    {
bool failed;
attributeData->slice = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM, HASH_ATTRIBUTE_SLICE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_FACE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__INIT_FROM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__surface__init_from()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__format( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__format( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__format()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__format_hint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__format_hint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__format_hint()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__channels( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__channels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__channels()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__range()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__precision( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__precision( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__precision()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__option( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__option( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__option()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::format_hint__extra__AttributeData ColladaParserAutoGen::format_hint__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__format_hint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__format_hint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
format_hint__extra__AttributeData* attributeData = newData<format_hint__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FORMAT_HINT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__format_hint__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__surface__size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__surface__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__surface__size()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__viewport_ratio( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__viewport_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__viewport_ratio()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mip_levels( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mip_levels( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mip_levels()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mipmap_generate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mipmap_generate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mipmap_generate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::surface__extra__AttributeData ColladaParserAutoGen::surface__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__surface__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__surface__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
surface__extra__AttributeData* attributeData = newData<surface__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SURFACE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__surface__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__border_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__border_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler1D__extra__AttributeData ColladaParserAutoGen::sampler1D__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler1D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler1D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler1D__extra__AttributeData* attributeData = newData<sampler1D__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER1D__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler1D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__border_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__border_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler2D__extra__AttributeData ColladaParserAutoGen::sampler2D__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler2D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler2D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler2D__extra__AttributeData* attributeData = newData<sampler2D__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER2D__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler2D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__wrap_p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__wrap_p()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__border_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__border_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler3D__extra__AttributeData ColladaParserAutoGen::sampler3D__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler3D__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler3D__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler3D__extra__AttributeData* attributeData = newData<sampler3D__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER3D__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler3D__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__wrap_p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__wrap_p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__wrap_p()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__border_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__border_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::samplerCUBE__extra__AttributeData ColladaParserAutoGen::samplerCUBE__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerCUBE__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerCUBE__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
samplerCUBE__extra__AttributeData* attributeData = newData<samplerCUBE__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERCUBE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerCUBE__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__border_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__border_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__border_color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::samplerRECT__extra__AttributeData ColladaParserAutoGen::samplerRECT__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerRECT__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerRECT__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
samplerRECT__extra__AttributeData* attributeData = newData<samplerRECT__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERRECT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerRECT__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::samplerDEPTH__extra__AttributeData ColladaParserAutoGen::samplerDEPTH__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__samplerDEPTH__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__samplerDEPTH__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
samplerDEPTH__extra__AttributeData* attributeData = newData<samplerDEPTH__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLERDEPTH__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__samplerDEPTH__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__enum( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__enum()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_effect__extra__AttributeData ColladaParserAutoGen::instance_effect__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_effect__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_effect__extra__AttributeData* attributeData = newData<instance_effect__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_EFFECT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_effect__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::animation__AttributeData ColladaParserAutoGen::animation__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__AttributeData* attributeData = newData<animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::animation__source__AttributeData ColladaParserAutoGen::animation__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__source__AttributeData* attributeData = newData<animation__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__source__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__source__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__source__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::IDREF_array__AttributeData ColladaParserAutoGen::IDREF_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__IDREF_array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__IDREF_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
IDREF_array__AttributeData* attributeData = newData<IDREF_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IDREF_ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__IDREF_array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::Name_array__AttributeData ColladaParserAutoGen::Name_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__Name_array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__Name_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
Name_array__AttributeData* attributeData = newData<Name_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NAME_ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__Name_array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::bool_array__AttributeData ColladaParserAutoGen::bool_array__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bool_array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bool_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bool_array__AttributeData* attributeData = newData<bool_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BOOL_ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bool_array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::float_array__AttributeData ColladaParserAutoGen::float_array__AttributeData::DEFAULT = {0, 0, 0, 6, 38};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__float_array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__float_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
float_array__AttributeData* attributeData = newData<float_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_DIGITS:
    {
bool failed;
attributeData->digits = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_DIGITS, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MAGNITUDE:
    {
bool failed;
attributeData->magnitude = GeneratedSaxParser::Utils::toInt(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY, HASH_ATTRIBUTE_MAGNITUDE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FLOAT_ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__float_array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::int_array__AttributeData ColladaParserAutoGen::int_array__AttributeData::DEFAULT = {0, 0, 0, -2147483648, 2147483647};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__int_array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__int_array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
int_array__AttributeData* attributeData = newData<int_array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MININCLUSIVE:
    {
bool failed;
attributeData->minInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MININCLUSIVE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_MAXINCLUSIVE:
    {
bool failed;
attributeData->maxInclusive = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY, HASH_ATTRIBUTE_MAXINCLUSIVE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INT_ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__int_array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__source__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__source__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__source__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::accessor__AttributeData ColladaParserAutoGen::accessor__AttributeData::DEFAULT = {0, (const ParserChar *)"0", 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__accessor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__accessor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
accessor__AttributeData* attributeData = newData<accessor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_STRIDE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__accessor()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::accessor__param__AttributeData ColladaParserAutoGen::accessor__param__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__accessor__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__accessor__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
accessor__param__AttributeData* attributeData = newData<accessor__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ACCESSOR__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__accessor__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::source__technique__AttributeData ColladaParserAutoGen::source__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__source__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__source__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
source__technique__AttributeData* attributeData = newData<source__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SOURCE__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__source__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler__AttributeData ColladaParserAutoGen::sampler__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler__AttributeData* attributeData = newData<sampler__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler__input__AttributeData ColladaParserAutoGen::sampler__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler__input__AttributeData* attributeData = newData<sampler__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler__input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::channel__AttributeData ColladaParserAutoGen::channel__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__channel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__channel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
channel__AttributeData* attributeData = newData<channel__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CHANNEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__channel()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::animation__extra__AttributeData ColladaParserAutoGen::animation__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation__extra__AttributeData* attributeData = newData<animation__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::trifans__AttributeData ColladaParserAutoGen::trifans__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__AttributeData* attributeData = newData<trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__trifans()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::trifans__input__AttributeData ColladaParserAutoGen::trifans__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__trifans__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__trifans__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__input__AttributeData* attributeData = newData<trifans__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__trifans__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__trifans__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__trifans__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__trifans__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::trifans__extra__AttributeData ColladaParserAutoGen::trifans__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__trifans__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__trifans__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
trifans__extra__AttributeData* attributeData = newData<trifans__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIFANS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__trifans__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::source__AttributeData ColladaParserAutoGen::source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
source__AttributeData* attributeData = newData<source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__source()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLES__AttributeData ColladaParserAutoGen::profile_GLES__AttributeData::DEFAULT = {0, (const ParserChar *)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__AttributeData* attributeData = newData<profile_GLES__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLES__image__AttributeData ColladaParserAutoGen::profile_GLES__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__image__AttributeData* attributeData = newData<profile_GLES__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES__image()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__image__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__image__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__image__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__data( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__data( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__data()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__image__init_from( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__image__init_from( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__image__init_from()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::image__extra__AttributeData ColladaParserAutoGen::image__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__image__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__image__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__extra__AttributeData* attributeData = newData<image__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__image__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLES__newparam__AttributeData ColladaParserAutoGen::profile_GLES__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__newparam__AttributeData* attributeData = newData<profile_GLES__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES__newparam()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__annotate__AttributeData ColladaParserAutoGen::newparam__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__annotate__AttributeData* attributeData = newData<newparam__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__bool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__bool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__bool2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__bool2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__bool3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__bool3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__bool4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__bool4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__int( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__int()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__int2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__int2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__int3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__int3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__int4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__int4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__float4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__float4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__annotate__string( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__annotate__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__annotate__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__semantic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__semantic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__semantic()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__modifier( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__modifier( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__modifier()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float4x4()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__surface__AttributeData ColladaParserAutoGen::newparam__surface__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__surface__AttributeData* attributeData = newData<newparam__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__SURFACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__surface()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__texture_pipeline__AttributeData ColladaParserAutoGen::newparam__texture_pipeline__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__texture_pipeline__AttributeData* attributeData = newData<newparam__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__TEXTURE_PIPELINE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_pipeline__texcombiner( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_pipeline__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_pipeline__texcombiner()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texcombiner__constant__AttributeData ColladaParserAutoGen::texcombiner__constant__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texcombiner__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texcombiner__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcombiner__constant__AttributeData* attributeData = newData<texcombiner__constant__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__CONSTANT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texcombiner__constant()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::RGB__AttributeData ColladaParserAutoGen::RGB__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__RGB( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__RGB( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
RGB__AttributeData* attributeData = newData<RGB__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {



    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB, HASH_ATTRIBUTE_SCALE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__RGB()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::RGB__argument__AttributeData ColladaParserAutoGen::RGB__argument__AttributeData::DEFAULT = {0, (const ParserChar *)"SRC_COLOR", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__RGB__argument( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__RGB__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
RGB__argument__AttributeData* attributeData = newData<RGB__argument__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {



    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RGB__ARGUMENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__RGB__argument()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texcombiner__alpha__AttributeData ColladaParserAutoGen::texcombiner__alpha__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texcombiner__alpha( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texcombiner__alpha( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcombiner__alpha__AttributeData* attributeData = newData<texcombiner__alpha__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {



    break;
    }
    case HASH_ATTRIBUTE_SCALE:
    {
bool failed;
attributeData->scale = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA, HASH_ATTRIBUTE_SCALE, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOMBINER__ALPHA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texcombiner__alpha()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::alpha__argument__AttributeData ColladaParserAutoGen::alpha__argument__AttributeData::DEFAULT = {0, (const ParserChar *)"SRC_ALPHA", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__alpha__argument( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__alpha__argument( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha__argument__AttributeData* attributeData = newData<alpha__argument__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_OPERAND:
    {



    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA__ARGUMENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__alpha__argument()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture_pipeline__texenv__AttributeData ColladaParserAutoGen::texture_pipeline__texenv__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_pipeline__texenv( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_pipeline__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline__texenv__AttributeData* attributeData = newData<texture_pipeline__texenv__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {



    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__TEXENV , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_pipeline__texenv()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texenv__constant__AttributeData ColladaParserAutoGen::texenv__constant__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texenv__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texenv__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texenv__constant__AttributeData* attributeData = newData<texenv__constant__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXENV__CONSTANT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texenv__constant()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture_pipeline__extra__AttributeData ColladaParserAutoGen::texture_pipeline__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_pipeline__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_pipeline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline__extra__AttributeData* attributeData = newData<texture_pipeline__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_pipeline__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__sampler_state__AttributeData ColladaParserAutoGen::newparam__sampler_state__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__sampler_state( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__sampler_state__AttributeData* attributeData = newData<newparam__sampler_state__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__SAMPLER_STATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__wrap_s( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__wrap_s( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__wrap_s()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__wrap_t( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__wrap_t( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__wrap_t()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__minfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__minfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__minfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__magfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__magfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__magfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__mipfilter( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__mipfilter( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__mipfilter()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__mipmap_maxlevel( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__mipmap_maxlevel( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__mipmap_maxlevel()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__mipmap_bias( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__mipmap_bias( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__mipmap_bias()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sampler_state__extra__AttributeData ColladaParserAutoGen::sampler_state__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sampler_state__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sampler_state__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sampler_state__extra__AttributeData* attributeData = newData<sampler_state__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLER_STATE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sampler_state__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__texture_unit__AttributeData ColladaParserAutoGen::newparam__texture_unit__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__texture_unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__texture_unit__AttributeData* attributeData = newData<newparam__texture_unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__TEXTURE_UNIT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__texture_unit()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_unit__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_unit__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_unit__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_unit__sampler_state( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_unit__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_unit__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texcoord__AttributeData ColladaParserAutoGen::texcoord__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texcoord( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texcoord( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texcoord__AttributeData* attributeData = newData<texcoord__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXCOORD , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texcoord()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture_unit__extra__AttributeData ColladaParserAutoGen::texture_unit__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_unit__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_unit__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_unit__extra__AttributeData* attributeData = newData<texture_unit__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_UNIT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_unit__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__enum( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__enum()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLES__technique__AttributeData ColladaParserAutoGen::profile_GLES__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__technique__AttributeData* attributeData = newData<profile_GLES__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__annotate__AttributeData ColladaParserAutoGen::technique__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__annotate__AttributeData* attributeData = newData<technique__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__annotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__image__AttributeData ColladaParserAutoGen::technique__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__image__AttributeData* attributeData = newData<technique__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__newparam__AttributeData ColladaParserAutoGen::technique__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__newparam__AttributeData* attributeData = newData<technique__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__newparam()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__setparam__AttributeData ColladaParserAutoGen::technique__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__setparam__AttributeData* attributeData = newData<technique__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__SETPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__setparam()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__annotate__AttributeData ColladaParserAutoGen::setparam__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__annotate__AttributeData* attributeData = newData<setparam__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__annotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__texture_pipeline__AttributeData ColladaParserAutoGen::setparam__texture_pipeline__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__texture_pipeline__AttributeData* attributeData = newData<setparam__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__TEXTURE_PIPELINE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__sampler_state__AttributeData ColladaParserAutoGen::setparam__sampler_state__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__sampler_state( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__sampler_state( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__sampler_state__AttributeData* attributeData = newData<setparam__sampler_state__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__SAMPLER_STATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__sampler_state()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__texture_unit__AttributeData ColladaParserAutoGen::setparam__texture_unit__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__texture_unit( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__texture_unit( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__texture_unit__AttributeData* attributeData = newData<setparam__texture_unit__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__TEXTURE_UNIT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__texture_unit()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::pass__AttributeData ColladaParserAutoGen::pass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__pass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__pass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__AttributeData* attributeData = newData<pass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__pass()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::pass__annotate__AttributeData ColladaParserAutoGen::pass__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__pass__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__pass__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__annotate__AttributeData* attributeData = newData<pass__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__pass__annotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__color_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__color_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__color_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_target( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_target( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_target()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__color_clear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__color_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__color_clear()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_clear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_clear()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_clear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_clear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_clear()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__draw( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__draw( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__draw()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__alpha_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__alpha_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__alpha_func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::alpha_func__func__AttributeData ColladaParserAutoGen::alpha_func__func__AttributeData::DEFAULT = {(const ParserChar *)"ALWAYS", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__alpha_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__alpha_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_func__func__AttributeData* attributeData = newData<alpha_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__FUNC , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__alpha_func__func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::alpha_func__value__AttributeData ColladaParserAutoGen::alpha_func__value__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__alpha_func__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__alpha_func__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_func__value__AttributeData* attributeData = newData<alpha_func__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__VALUE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_FUNC__VALUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__alpha_func__value()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blend_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blend_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blend_func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::src__AttributeData ColladaParserAutoGen::src__AttributeData::DEFAULT = {(const ParserChar *)"ONE", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__src( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__src( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
src__AttributeData* attributeData = newData<src__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SRC , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__src()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::dest__AttributeData ColladaParserAutoGen::dest__AttributeData::DEFAULT = {(const ParserChar *)"ZERO", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__dest( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__dest( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dest__AttributeData* attributeData = newData<dest__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEST , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__dest()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::clear_color__AttributeData ColladaParserAutoGen::clear_color__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__clear_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__clear_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_color__AttributeData* attributeData = newData<clear_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__clear_color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::clear_stencil__AttributeData ColladaParserAutoGen::clear_stencil__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__clear_stencil( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__clear_stencil( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_stencil__AttributeData* attributeData = newData<clear_stencil__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_STENCIL, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_STENCIL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__clear_stencil()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::clear_depth__AttributeData ColladaParserAutoGen::clear_depth__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__clear_depth( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__clear_depth( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clear_depth__AttributeData* attributeData = newData<clear_depth__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_DEPTH, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLEAR_DEPTH , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__clear_depth()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::clip_plane__AttributeData ColladaParserAutoGen::clip_plane__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__clip_plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__clip_plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clip_plane__AttributeData* attributeData = newData<clip_plane__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__clip_plane()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::color_mask__AttributeData ColladaParserAutoGen::color_mask__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__color_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__color_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_mask__AttributeData* attributeData = newData<color_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MASK , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__color_mask()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::cull_face__AttributeData ColladaParserAutoGen::cull_face__AttributeData::DEFAULT = {(const ParserChar *)"BACK", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cull_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cull_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
cull_face__AttributeData* attributeData = newData<cull_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cull_face()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::depth_func__AttributeData ColladaParserAutoGen::depth_func__AttributeData::DEFAULT = {(const ParserChar *)"ALWAYS", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_func__AttributeData* attributeData = newData<depth_func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_FUNC , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::depth_mask__AttributeData ColladaParserAutoGen::depth_mask__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_mask__AttributeData* attributeData = newData<depth_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_MASK , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_mask()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::depth_range__AttributeData ColladaParserAutoGen::depth_range__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_range( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_range( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_range__AttributeData* attributeData = newData<depth_range__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_RANGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_range()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_color__AttributeData ColladaParserAutoGen::fog_color__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_color__AttributeData* attributeData = newData<fog_color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_density__AttributeData ColladaParserAutoGen::fog_density__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_density( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_density__AttributeData* attributeData = newData<fog_density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_DENSITY, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_DENSITY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_density()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_mode__AttributeData ColladaParserAutoGen::fog_mode__AttributeData::DEFAULT = {(const ParserChar *)"EXP", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_mode( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_mode( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_mode__AttributeData* attributeData = newData<fog_mode__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_MODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_mode()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_start__AttributeData ColladaParserAutoGen::fog_start__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_start( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_start( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_start__AttributeData* attributeData = newData<fog_start__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_START, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_START , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_start()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_end__AttributeData ColladaParserAutoGen::fog_end__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_end( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_end( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_end__AttributeData* attributeData = newData<fog_end__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_END, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_END , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_end()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::front_face__AttributeData ColladaParserAutoGen::front_face__AttributeData::DEFAULT = {(const ParserChar *)"CCW", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__front_face( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__front_face( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
front_face__AttributeData* attributeData = newData<front_face__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FRONT_FACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__front_face()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::pass__texture_pipeline__AttributeData ColladaParserAutoGen::pass__texture_pipeline__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__pass__texture_pipeline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__pass__texture_pipeline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__texture_pipeline__AttributeData* attributeData = newData<pass__texture_pipeline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__TEXTURE_PIPELINE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__pass__texture_pipeline()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture_pipeline__value__AttributeData ColladaParserAutoGen::texture_pipeline__value__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_pipeline__value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_pipeline__value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline__value__AttributeData* attributeData = newData<texture_pipeline__value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE__VALUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_pipeline__value()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__value__texcombiner( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__value__texcombiner( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__value__texcombiner()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::value__texenv__AttributeData ColladaParserAutoGen::value__texenv__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__value__texenv( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__value__texenv( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
value__texenv__AttributeData* attributeData = newData<value__texenv__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE__OPERATOR:
    {



    break;
    }
    case HASH_ATTRIBUTE_UNIT:
    {

attributeData->unit = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VALUE__TEXENV , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__value__texenv()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::value__extra__AttributeData ColladaParserAutoGen::value__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__value__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__value__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
value__extra__AttributeData* attributeData = newData<value__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VALUE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__value__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::logic_op__AttributeData ColladaParserAutoGen::logic_op__AttributeData::DEFAULT = {(const ParserChar *)"COPY", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__logic_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__logic_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
logic_op__AttributeData* attributeData = newData<logic_op__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LOGIC_OP , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__logic_op()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_ambient__AttributeData ColladaParserAutoGen::light_ambient__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_ambient__AttributeData* attributeData = newData<light_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_AMBIENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_ambient()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_diffuse__AttributeData ColladaParserAutoGen::light_diffuse__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_diffuse__AttributeData* attributeData = newData<light_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_DIFFUSE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_diffuse()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_specular__AttributeData ColladaParserAutoGen::light_specular__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 0.0E1", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_specular__AttributeData* attributeData = newData<light_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPECULAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_specular()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_position__AttributeData ColladaParserAutoGen::light_position__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 1.0E0 0.0E1", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_position( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_position( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_position__AttributeData* attributeData = newData<light_position__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_POSITION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_position()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_constant_attenuation__AttributeData ColladaParserAutoGen::light_constant_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_constant_attenuation__AttributeData* attributeData = newData<light_constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_CONSTANT_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_constant_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_linear_attenutation__AttributeData ColladaParserAutoGen::light_linear_attenutation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_linear_attenutation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_linear_attenutation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_linear_attenutation__AttributeData* attributeData = newData<light_linear_attenutation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_LINEAR_ATTENUTATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_linear_attenutation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_quadratic_attenuation__AttributeData ColladaParserAutoGen::light_quadratic_attenuation__AttributeData::DEFAULT = {1.0E0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_quadratic_attenuation__AttributeData* attributeData = newData<light_quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_QUADRATIC_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_quadratic_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_spot_cutoff__AttributeData ColladaParserAutoGen::light_spot_cutoff__AttributeData::DEFAULT = {1.8E2, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_spot_cutoff( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_spot_cutoff( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_cutoff__AttributeData* attributeData = newData<light_spot_cutoff__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_CUTOFF , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_spot_cutoff()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_spot_direction__AttributeData ColladaParserAutoGen::light_spot_direction__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 -1.0E0", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_spot_direction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_spot_direction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_direction__AttributeData* attributeData = newData<light_spot_direction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_DIRECTION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_spot_direction()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_spot_exponent__AttributeData ColladaParserAutoGen::light_spot_exponent__AttributeData::DEFAULT = {0.0E1, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_spot_exponent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_spot_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_spot_exponent__AttributeData* attributeData = newData<light_spot_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_SPOT_EXPONENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_spot_exponent()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_model_ambient__AttributeData ColladaParserAutoGen::light_model_ambient__AttributeData::DEFAULT = {(const ParserChar *)"2.0E-1 2.0E-1 2.0E-1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_model_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_model_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_model_ambient__AttributeData* attributeData = newData<light_model_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_AMBIENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_model_ambient()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::line_width__AttributeData ColladaParserAutoGen::line_width__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__line_width( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__line_width( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
line_width__AttributeData* attributeData = newData<line_width__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_WIDTH, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_WIDTH , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__line_width()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material_ambient__AttributeData ColladaParserAutoGen::material_ambient__AttributeData::DEFAULT = {(const ParserChar *)"2.0E-1 2.0E-1 2.0E-1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material_ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material_ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_ambient__AttributeData* attributeData = newData<material_ambient__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_AMBIENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material_ambient()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material_diffuse__AttributeData ColladaParserAutoGen::material_diffuse__AttributeData::DEFAULT = {(const ParserChar *)"8.0E-1 8.0E-1 8.0E-1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material_diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material_diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_diffuse__AttributeData* attributeData = newData<material_diffuse__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_DIFFUSE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material_diffuse()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material_emission__AttributeData ColladaParserAutoGen::material_emission__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material_emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material_emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_emission__AttributeData* attributeData = newData<material_emission__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_EMISSION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material_emission()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material_shininess__AttributeData ColladaParserAutoGen::material_shininess__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material_shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material_shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_shininess__AttributeData* attributeData = newData<material_shininess__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SHININESS, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SHININESS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material_shininess()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material_specular__AttributeData ColladaParserAutoGen::material_specular__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1 0.0E1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material_specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material_specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material_specular__AttributeData* attributeData = newData<material_specular__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL_SPECULAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material_specular()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::model_view_matrix__AttributeData ColladaParserAutoGen::model_view_matrix__AttributeData::DEFAULT = {(const ParserChar *)"1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__model_view_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__model_view_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
model_view_matrix__AttributeData* attributeData = newData<model_view_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MODEL_VIEW_MATRIX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__model_view_matrix()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_distance_attenuation__AttributeData ColladaParserAutoGen::point_distance_attenuation__AttributeData::DEFAULT = {(const ParserChar *)"1.0E0 0.0E1 0.0E1", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_distance_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_distance_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_distance_attenuation__AttributeData* attributeData = newData<point_distance_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_DISTANCE_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_distance_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_fade_threshold_size__AttributeData ColladaParserAutoGen::point_fade_threshold_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_fade_threshold_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_fade_threshold_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_fade_threshold_size__AttributeData* attributeData = newData<point_fade_threshold_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_FADE_THRESHOLD_SIZE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_fade_threshold_size()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_size__AttributeData ColladaParserAutoGen::point_size__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size__AttributeData* attributeData = newData<point_size__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_size()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_size_min__AttributeData ColladaParserAutoGen::point_size_min__AttributeData::DEFAULT = {0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_size_min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_size_min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size_min__AttributeData* attributeData = newData<point_size_min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MIN, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MIN , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_size_min()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_size_max__AttributeData ColladaParserAutoGen::point_size_max__AttributeData::DEFAULT = {1.0E0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_size_max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_size_max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_size_max__AttributeData* attributeData = newData<point_size_max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toFloat(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MAX, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SIZE_MAX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_size_max()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polygon_offset__AttributeData ColladaParserAutoGen::polygon_offset__AttributeData::DEFAULT = {(const ParserChar *)"0.0E1 0.0E1", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygon_offset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygon_offset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygon_offset__AttributeData* attributeData = newData<polygon_offset__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygon_offset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::projection_matrix__AttributeData ColladaParserAutoGen::projection_matrix__AttributeData::DEFAULT = {(const ParserChar *)"1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0 0.0E1 0.0E1 0.0E1 0.0E1 1.0E0", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__projection_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__projection_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
projection_matrix__AttributeData* attributeData = newData<projection_matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROJECTION_MATRIX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__projection_matrix()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::scissor__AttributeData ColladaParserAutoGen::scissor__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__scissor( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__scissor( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scissor__AttributeData* attributeData = newData<scissor__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__scissor()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shade_model__AttributeData ColladaParserAutoGen::shade_model__AttributeData::DEFAULT = {(const ParserChar *)"SMOOTH", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shade_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shade_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shade_model__AttributeData* attributeData = newData<shade_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHADE_MODEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shade_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_func__func__AttributeData ColladaParserAutoGen::stencil_func__func__AttributeData::DEFAULT = {(const ParserChar *)"ALWAYS", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_func__func( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_func__func( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__func__AttributeData* attributeData = newData<stencil_func__func__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__FUNC , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_func__func()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_func__ref__AttributeData ColladaParserAutoGen::stencil_func__ref__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_func__ref( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_func__ref( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__ref__AttributeData* attributeData = newData<stencil_func__ref__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__REF, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__REF , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_func__ref()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_func__mask__AttributeData ColladaParserAutoGen::stencil_func__mask__AttributeData::DEFAULT = {255, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_func__mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_func__mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_func__mask__AttributeData* attributeData = newData<stencil_func__mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toUnsignedShort(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_FUNC__MASK , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_func__mask()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_mask__AttributeData ColladaParserAutoGen::stencil_mask__AttributeData::DEFAULT = {4294967295, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_mask( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_mask( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_mask__AttributeData* attributeData = newData<stencil_mask__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {
bool failed;
attributeData->value = GeneratedSaxParser::Utils::toLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_MASK, HASH_ATTRIBUTE_VALUE, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_MASK , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_mask()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_op( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_op( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_op()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_op__fail__AttributeData ColladaParserAutoGen::stencil_op__fail__AttributeData::DEFAULT = {(const ParserChar *)"KEEP", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_op__fail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_op__fail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__fail__AttributeData* attributeData = newData<stencil_op__fail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__FAIL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_op__fail()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_op__zfail__AttributeData ColladaParserAutoGen::stencil_op__zfail__AttributeData::DEFAULT = {(const ParserChar *)"KEEP", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_op__zfail( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_op__zfail( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__zfail__AttributeData* attributeData = newData<stencil_op__zfail__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZFAIL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_op__zfail()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_op__zpass__AttributeData ColladaParserAutoGen::stencil_op__zpass__AttributeData::DEFAULT = {(const ParserChar *)"KEEP", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_op__zpass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_op__zpass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_op__zpass__AttributeData* attributeData = newData<stencil_op__zpass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_OP__ZPASS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_op__zpass()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::alpha_test_enable__AttributeData ColladaParserAutoGen::alpha_test_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__alpha_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__alpha_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
alpha_test_enable__AttributeData* attributeData = newData<alpha_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ALPHA_TEST_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__alpha_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::blend_enable__AttributeData ColladaParserAutoGen::blend_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blend_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blend_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
blend_enable__AttributeData* attributeData = newData<blend_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLEND_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blend_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::clip_plane_enable__AttributeData ColladaParserAutoGen::clip_plane_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__clip_plane_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__clip_plane_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
clip_plane_enable__AttributeData* attributeData = newData<clip_plane_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CLIP_PLANE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__clip_plane_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::color_logic_op_enable__AttributeData ColladaParserAutoGen::color_logic_op_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__color_logic_op_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__color_logic_op_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_logic_op_enable__AttributeData* attributeData = newData<color_logic_op_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_LOGIC_OP_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__color_logic_op_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::color_material_enable__AttributeData ColladaParserAutoGen::color_material_enable__AttributeData::DEFAULT = {(const ParserChar *)"true", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__color_material_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__color_material_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
color_material_enable__AttributeData* attributeData = newData<color_material_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLOR_MATERIAL_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__color_material_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::cull_face_enable__AttributeData ColladaParserAutoGen::cull_face_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cull_face_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cull_face_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
cull_face_enable__AttributeData* attributeData = newData<cull_face_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CULL_FACE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cull_face_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::depth_test_enable__AttributeData ColladaParserAutoGen::depth_test_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__depth_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__depth_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
depth_test_enable__AttributeData* attributeData = newData<depth_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DEPTH_TEST_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__depth_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::dither_enable__AttributeData ColladaParserAutoGen::dither_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__dither_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__dither_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dither_enable__AttributeData* attributeData = newData<dither_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DITHER_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__dither_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::fog_enable__AttributeData ColladaParserAutoGen::fog_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fog_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fog_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
fog_enable__AttributeData* attributeData = newData<fog_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FOG_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fog_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture_pipeline_enable__AttributeData ColladaParserAutoGen::texture_pipeline_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture_pipeline_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture_pipeline_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture_pipeline_enable__AttributeData* attributeData = newData<texture_pipeline_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE_PIPELINE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture_pipeline_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_enable__AttributeData ColladaParserAutoGen::light_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_enable__AttributeData* attributeData = newData<light_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INDEX:
    {
bool failed;
attributeData->index = GeneratedSaxParser::Utils::toLongLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE, HASH_ATTRIBUTE_INDEX, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lighting_enable__AttributeData ColladaParserAutoGen::lighting_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lighting_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lighting_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lighting_enable__AttributeData* attributeData = newData<lighting_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHTING_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lighting_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light_model_two_side_enable__AttributeData ColladaParserAutoGen::light_model_two_side_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light_model_two_side_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light_model_two_side_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light_model_two_side_enable__AttributeData* attributeData = newData<light_model_two_side_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT_MODEL_TWO_SIDE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light_model_two_side_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::line_smooth_enable__AttributeData ColladaParserAutoGen::line_smooth_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__line_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__line_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
line_smooth_enable__AttributeData* attributeData = newData<line_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINE_SMOOTH_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__line_smooth_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::multisample_enable__AttributeData ColladaParserAutoGen::multisample_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__multisample_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__multisample_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
multisample_enable__AttributeData* attributeData = newData<multisample_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MULTISAMPLE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__multisample_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::normalize_enable__AttributeData ColladaParserAutoGen::normalize_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__normalize_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__normalize_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
normalize_enable__AttributeData* attributeData = newData<normalize_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NORMALIZE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__normalize_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point_smooth_enable__AttributeData ColladaParserAutoGen::point_smooth_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point_smooth_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point_smooth_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point_smooth_enable__AttributeData* attributeData = newData<point_smooth_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT_SMOOTH_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point_smooth_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polygon_offset_fill_enable__AttributeData ColladaParserAutoGen::polygon_offset_fill_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygon_offset_fill_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygon_offset_fill_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygon_offset_fill_enable__AttributeData* attributeData = newData<polygon_offset_fill_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGON_OFFSET_FILL_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygon_offset_fill_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rescale_normal_enable__AttributeData ColladaParserAutoGen::rescale_normal_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rescale_normal_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rescale_normal_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rescale_normal_enable__AttributeData* attributeData = newData<rescale_normal_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RESCALE_NORMAL_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rescale_normal_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sample_alpha_to_coverage_enable__AttributeData ColladaParserAutoGen::sample_alpha_to_coverage_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sample_alpha_to_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sample_alpha_to_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_alpha_to_coverage_enable__AttributeData* attributeData = newData<sample_alpha_to_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_COVERAGE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sample_alpha_to_coverage_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sample_alpha_to_one_enable__AttributeData ColladaParserAutoGen::sample_alpha_to_one_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sample_alpha_to_one_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sample_alpha_to_one_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_alpha_to_one_enable__AttributeData* attributeData = newData<sample_alpha_to_one_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_ALPHA_TO_ONE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sample_alpha_to_one_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sample_coverage_enable__AttributeData ColladaParserAutoGen::sample_coverage_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sample_coverage_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sample_coverage_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sample_coverage_enable__AttributeData* attributeData = newData<sample_coverage_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SAMPLE_COVERAGE_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sample_coverage_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::scissor_test_enable__AttributeData ColladaParserAutoGen::scissor_test_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__scissor_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__scissor_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scissor_test_enable__AttributeData* attributeData = newData<scissor_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCISSOR_TEST_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__scissor_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::stencil_test_enable__AttributeData ColladaParserAutoGen::stencil_test_enable__AttributeData::DEFAULT = {(const ParserChar *)"false", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__stencil_test_enable( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__stencil_test_enable( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
stencil_test_enable__AttributeData* attributeData = newData<stencil_test_enable__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VALUE:
    {



    break;
    }
    case HASH_ATTRIBUTE_PARAM:
    {

attributeData->param = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STENCIL_TEST_ENABLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__stencil_test_enable()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::pass__extra__AttributeData ColladaParserAutoGen::pass__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__pass__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__pass__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
pass__extra__AttributeData* attributeData = newData<pass__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PASS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__pass__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__extra__AttributeData ColladaParserAutoGen::technique__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__extra__AttributeData* attributeData = newData<technique__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLES__extra__AttributeData ColladaParserAutoGen::profile_GLES__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLES__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLES__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLES__extra__AttributeData* attributeData = newData<profile_GLES__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLES__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__fx_profile_abstract( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__fx_profile_abstract( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__fx_profile_abstract()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__source__AttributeData ColladaParserAutoGen::mesh__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__source__AttributeData* attributeData = newData<mesh__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__source()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__vertices__AttributeData ColladaParserAutoGen::mesh__vertices__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__vertices__AttributeData* attributeData = newData<mesh__vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__VERTICES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__vertices()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertices__input__AttributeData ColladaParserAutoGen::vertices__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertices__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__input__AttributeData* attributeData = newData<vertices__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertices__input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertices__extra__AttributeData ColladaParserAutoGen::vertices__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertices__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__extra__AttributeData* attributeData = newData<vertices__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertices__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__lines__AttributeData ColladaParserAutoGen::mesh__lines__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__lines__AttributeData* attributeData = newData<mesh__lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__lines()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lines__input__AttributeData ColladaParserAutoGen::lines__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lines__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lines__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__input__AttributeData* attributeData = newData<lines__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lines__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lines__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lines__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lines__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lines__extra__AttributeData ColladaParserAutoGen::lines__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lines__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lines__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__extra__AttributeData* attributeData = newData<lines__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lines__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__linestrips__AttributeData ColladaParserAutoGen::mesh__linestrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__linestrips__AttributeData* attributeData = newData<mesh__linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__LINESTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__linestrips()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linestrips__input__AttributeData ColladaParserAutoGen::linestrips__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linestrips__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linestrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__input__AttributeData* attributeData = newData<linestrips__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linestrips__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linestrips__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linestrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linestrips__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linestrips__extra__AttributeData ColladaParserAutoGen::linestrips__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linestrips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linestrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__extra__AttributeData* attributeData = newData<linestrips__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linestrips__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__polygons__AttributeData ColladaParserAutoGen::mesh__polygons__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__polygons__AttributeData* attributeData = newData<mesh__polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYGONS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__polygons()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polygons__input__AttributeData ColladaParserAutoGen::polygons__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygons__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygons__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__input__AttributeData* attributeData = newData<polygons__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygons__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygons__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygons__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygons__p()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ph()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ph__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ph__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ph__p()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__h( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__h( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__h()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polygons__extra__AttributeData ColladaParserAutoGen::polygons__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygons__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygons__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__extra__AttributeData* attributeData = newData<polygons__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygons__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__polylist__AttributeData ColladaParserAutoGen::mesh__polylist__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__polylist__AttributeData* attributeData = newData<mesh__polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__POLYLIST , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__polylist()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polylist__input__AttributeData ColladaParserAutoGen::polylist__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polylist__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polylist__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__input__AttributeData* attributeData = newData<polylist__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polylist__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polylist__vcount( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polylist__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polylist__vcount()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polylist__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polylist__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polylist__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polylist__extra__AttributeData ColladaParserAutoGen::polylist__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polylist__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polylist__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__extra__AttributeData* attributeData = newData<polylist__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polylist__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__triangles__AttributeData ColladaParserAutoGen::mesh__triangles__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__triangles__AttributeData* attributeData = newData<mesh__triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIANGLES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__triangles()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::triangles__input__AttributeData ColladaParserAutoGen::triangles__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__triangles__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__triangles__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__input__AttributeData* attributeData = newData<triangles__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__triangles__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__triangles__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__triangles__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__triangles__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::triangles__extra__AttributeData ColladaParserAutoGen::triangles__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__triangles__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__triangles__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__extra__AttributeData* attributeData = newData<triangles__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__triangles__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__trifans__AttributeData ColladaParserAutoGen::mesh__trifans__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__trifans__AttributeData* attributeData = newData<mesh__trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRIFANS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__trifans()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__tristrips__AttributeData ColladaParserAutoGen::mesh__tristrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__tristrips__AttributeData* attributeData = newData<mesh__tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__TRISTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__tristrips()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::tristrips__input__AttributeData ColladaParserAutoGen::tristrips__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tristrips__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tristrips__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__input__AttributeData* attributeData = newData<tristrips__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tristrips__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tristrips__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tristrips__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tristrips__p()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::tristrips__extra__AttributeData ColladaParserAutoGen::tristrips__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tristrips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tristrips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__extra__AttributeData* attributeData = newData<tristrips__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tristrips__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mesh__extra__AttributeData ColladaParserAutoGen::mesh__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mesh__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mesh__extra__AttributeData* attributeData = newData<mesh__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MESH__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mesh__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lines__AttributeData ColladaParserAutoGen::lines__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lines__AttributeData* attributeData = newData<lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lines()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_node__AttributeData ColladaParserAutoGen::instance_node__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_node__AttributeData* attributeData = newData<instance_node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_NODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_node()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_node__extra__AttributeData ColladaParserAutoGen::instance_node__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_node__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_node__extra__AttributeData* attributeData = newData<instance_node__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_NODE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_node__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::visual_scene__AttributeData ColladaParserAutoGen::visual_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
visual_scene__AttributeData* attributeData = newData<visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__visual_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__visual_scene__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__visual_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__visual_scene__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::visual_scene__node__AttributeData ColladaParserAutoGen::visual_scene__node__AttributeData::DEFAULT = {0, 0, 0, (const ParserChar *)"NODE", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__visual_scene__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__visual_scene__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
visual_scene__node__AttributeData* attributeData = newData<visual_scene__node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE__NODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__visual_scene__node()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lookat__AttributeData ColladaParserAutoGen::lookat__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lookat( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lookat( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lookat__AttributeData* attributeData = newData<lookat__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LOOKAT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lookat()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::matrix__AttributeData ColladaParserAutoGen::matrix__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
matrix__AttributeData* attributeData = newData<matrix__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATRIX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__matrix()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::node__rotate__AttributeData ColladaParserAutoGen::node__rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__rotate__AttributeData* attributeData = newData<node__rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node__rotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::scale__AttributeData ColladaParserAutoGen::scale__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__scale( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__scale( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scale__AttributeData* attributeData = newData<scale__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCALE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__scale()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::skew__AttributeData ColladaParserAutoGen::skew__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__skew( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__skew( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skew__AttributeData* attributeData = newData<skew__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKEW , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__skew()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::node__translate__AttributeData ColladaParserAutoGen::node__translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__translate__AttributeData* attributeData = newData<node__translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node__translate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_camera__AttributeData ColladaParserAutoGen::instance_camera__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_camera__AttributeData* attributeData = newData<instance_camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CAMERA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_camera()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_camera__extra__AttributeData ColladaParserAutoGen::instance_camera__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_camera__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_camera__extra__AttributeData* attributeData = newData<instance_camera__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CAMERA__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_camera__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_controller__AttributeData ColladaParserAutoGen::instance_controller__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_controller__AttributeData* attributeData = newData<instance_controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CONTROLLER , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_controller()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__skeleton( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__skeleton( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__skeleton()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_controller__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_controller__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_controller__bind_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::bind_material__param__AttributeData ColladaParserAutoGen::bind_material__param__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_material__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_material__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_material__param__AttributeData* attributeData = newData<bind_material__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_material__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_material__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_material__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_material__AttributeData ColladaParserAutoGen::instance_material__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_material__AttributeData* attributeData = newData<instance_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SYMBOL:
    {

attributeData->symbol = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_material__bind__AttributeData ColladaParserAutoGen::instance_material__bind__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_material__bind( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_material__bind( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_material__bind__AttributeData* attributeData = newData<instance_material__bind__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL__BIND , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_material__bind()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::bind_vertex_input__AttributeData ColladaParserAutoGen::bind_vertex_input__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_vertex_input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_vertex_input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_vertex_input__AttributeData* attributeData = newData<bind_vertex_input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SEMANTIC:
    {

attributeData->input_semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_INPUT_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_VERTEX_INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_vertex_input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_material__extra__AttributeData ColladaParserAutoGen::instance_material__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_material__extra__AttributeData* attributeData = newData<instance_material__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_MATERIAL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::bind_material__technique__AttributeData ColladaParserAutoGen::bind_material__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_material__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_material__technique__AttributeData* attributeData = newData<bind_material__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_material__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::bind_material__extra__AttributeData ColladaParserAutoGen::bind_material__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
bind_material__extra__AttributeData* attributeData = newData<bind_material__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BIND_MATERIAL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_controller__extra__AttributeData ColladaParserAutoGen::instance_controller__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_controller__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_controller__extra__AttributeData* attributeData = newData<instance_controller__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_CONTROLLER__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_controller__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::node__instance_geometry__AttributeData ColladaParserAutoGen::node__instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__instance_geometry__AttributeData* attributeData = newData<node__instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__INSTANCE_GEOMETRY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node__instance_geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_geometry__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_geometry__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_geometry__bind_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_geometry__extra__AttributeData ColladaParserAutoGen::instance_geometry__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_geometry__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_geometry__extra__AttributeData* attributeData = newData<instance_geometry__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_GEOMETRY__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_geometry__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_light__AttributeData ColladaParserAutoGen::instance_light__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_light__AttributeData* attributeData = newData<instance_light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_LIGHT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_light()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_light__extra__AttributeData ColladaParserAutoGen::instance_light__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_light__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_light__extra__AttributeData* attributeData = newData<instance_light__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_LIGHT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_light__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::node__extra__AttributeData ColladaParserAutoGen::node__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__extra__AttributeData* attributeData = newData<node__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::evaluate_scene__AttributeData ColladaParserAutoGen::evaluate_scene__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__evaluate_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__evaluate_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
evaluate_scene__AttributeData* attributeData = newData<evaluate_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EVALUATE_SCENE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__evaluate_scene()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::render__AttributeData ColladaParserAutoGen::render__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__render( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__render( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
render__AttributeData* attributeData = newData<render__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CAMERA_NODE:
    {

attributeData->camera_node = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RENDER , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__render()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__layer( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__layer( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__layer()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::render__instance_effect__AttributeData ColladaParserAutoGen::render__instance_effect__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__render__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__render__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
render__instance_effect__AttributeData* attributeData = newData<render__instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RENDER__INSTANCE_EFFECT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__render__instance_effect()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::visual_scene__extra__AttributeData ColladaParserAutoGen::visual_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__visual_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
visual_scene__extra__AttributeData* attributeData = newData<visual_scene__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VISUAL_SCENE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__visual_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material__AttributeData ColladaParserAutoGen::material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material__AttributeData* attributeData = newData<material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material__instance_effect__AttributeData ColladaParserAutoGen::material__instance_effect__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material__instance_effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material__instance_effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material__instance_effect__AttributeData* attributeData = newData<material__instance_effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL__INSTANCE_EFFECT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material__instance_effect()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::material__extra__AttributeData ColladaParserAutoGen::material__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
material__extra__AttributeData* attributeData = newData<material__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MATERIAL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__capsule( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__capsule()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__capsule__height( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__capsule__height()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__capsule__radius( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__capsule__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__capsule__radius()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::capsule__extra__AttributeData ColladaParserAutoGen::capsule__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__capsule__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
capsule__extra__AttributeData* attributeData = newData<capsule__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAPSULE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__capsule__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__p( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__p( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__p()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ellipsoid( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ellipsoid( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ellipsoid()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ellipsoid__size( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ellipsoid__size( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ellipsoid__size()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_scenes__AttributeData ColladaParserAutoGen::library_physics_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_scenes__AttributeData* attributeData = newData<library_physics_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_SCENES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_scenes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_scenes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_scenes__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_scene__AttributeData ColladaParserAutoGen::physics_scene__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__AttributeData* attributeData = newData<physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_scene__instance_force_field__AttributeData ColladaParserAutoGen::physics_scene__instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__instance_force_field__AttributeData* attributeData = newData<physics_scene__instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_FORCE_FIELD , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__instance_force_field()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_force_field__extra__AttributeData ColladaParserAutoGen::instance_force_field__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_force_field__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_force_field__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_force_field__extra__AttributeData* attributeData = newData<instance_force_field__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_FORCE_FIELD__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_force_field__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_scene__instance_physics_model__AttributeData ColladaParserAutoGen::physics_scene__instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__instance_physics_model__AttributeData* attributeData = newData<physics_scene__instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {

attributeData->parent = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__INSTANCE_PHYSICS_MODEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__instance_physics_model()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_model__instance_force_field__AttributeData ColladaParserAutoGen::instance_physics_model__instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_model__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_model__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_model__instance_force_field__AttributeData* attributeData = newData<instance_physics_model__instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__INSTANCE_FORCE_FIELD , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_model__instance_force_field()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_rigid_body__AttributeData ColladaParserAutoGen::instance_rigid_body__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_body__AttributeData* attributeData = newData<instance_rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_BODY:
    {

attributeData->body = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TARGET:
    {

attributeData->target = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_body()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_body__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_body__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__angular_velocity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__angular_velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__angular_velocity()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__velocity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__velocity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__velocity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::dynamic__AttributeData ColladaParserAutoGen::dynamic__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__dynamic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__dynamic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dynamic__AttributeData* attributeData = newData<dynamic__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DYNAMIC , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__dynamic()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique_common__mass__AttributeData ColladaParserAutoGen::technique_common__mass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique_common__mass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique_common__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique_common__mass__AttributeData* attributeData = newData<technique_common__mass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__MASS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique_common__mass()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mass_frame( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mass_frame( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mass_frame()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mass_frame__translate__AttributeData ColladaParserAutoGen::mass_frame__translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mass_frame__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mass_frame__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mass_frame__translate__AttributeData* attributeData = newData<mass_frame__translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MASS_FRAME__TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mass_frame__translate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::mass_frame__rotate__AttributeData ColladaParserAutoGen::mass_frame__rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__mass_frame__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__mass_frame__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
mass_frame__rotate__AttributeData* attributeData = newData<mass_frame__rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MASS_FRAME__ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__mass_frame__rotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::inertia__AttributeData ColladaParserAutoGen::inertia__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__inertia( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__inertia( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
inertia__AttributeData* attributeData = newData<inertia__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INERTIA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__inertia()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique_common__instance_physics_material__AttributeData ColladaParserAutoGen::technique_common__instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique_common__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique_common__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique_common__instance_physics_material__AttributeData* attributeData = newData<technique_common__instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique_common__instance_physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_material__extra__AttributeData ColladaParserAutoGen::instance_physics_material__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_material__extra__AttributeData* attributeData = newData<instance_physics_material__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique_common__physics_material__AttributeData ColladaParserAutoGen::technique_common__physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique_common__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique_common__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique_common__physics_material__AttributeData* attributeData = newData<technique_common__physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE_COMMON__PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique_common__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_material__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_material__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_material__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_material__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_material__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_material__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::dynamic_friction__AttributeData ColladaParserAutoGen::dynamic_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__dynamic_friction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__dynamic_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
dynamic_friction__AttributeData* attributeData = newData<dynamic_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DYNAMIC_FRICTION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__dynamic_friction()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::restitution__AttributeData ColladaParserAutoGen::restitution__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__restitution( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__restitution( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
restitution__AttributeData* attributeData = newData<restitution__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RESTITUTION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__restitution()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::static_friction__AttributeData ColladaParserAutoGen::static_friction__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__static_friction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__static_friction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
static_friction__AttributeData* attributeData = newData<static_friction__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_STATIC_FRICTION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__static_friction()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_material__technique__AttributeData ColladaParserAutoGen::physics_material__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_material__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_material__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__technique__AttributeData* attributeData = newData<physics_material__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_material__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_material__extra__AttributeData ColladaParserAutoGen::physics_material__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_material__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_material__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__extra__AttributeData* attributeData = newData<physics_material__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_material__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::hollow__AttributeData ColladaParserAutoGen::hollow__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__hollow( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__hollow( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
hollow__AttributeData* attributeData = newData<hollow__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_HOLLOW , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__hollow()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__mass__AttributeData ColladaParserAutoGen::shape__mass__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__mass( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__mass( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__mass__AttributeData* attributeData = newData<shape__mass__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__MASS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__mass()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::density__AttributeData ColladaParserAutoGen::density__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__density( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__density( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
density__AttributeData* attributeData = newData<density__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DENSITY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__density()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__instance_physics_material__AttributeData ColladaParserAutoGen::shape__instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__instance_physics_material__AttributeData* attributeData = newData<shape__instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__instance_physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__physics_material__AttributeData ColladaParserAutoGen::shape__physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__physics_material__AttributeData* attributeData = newData<shape__physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__instance_geometry__AttributeData ColladaParserAutoGen::shape__instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__instance_geometry__AttributeData* attributeData = newData<shape__instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__INSTANCE_GEOMETRY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__instance_geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__plane( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__plane( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__plane()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__equation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__equation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__equation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::plane__extra__AttributeData ColladaParserAutoGen::plane__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__plane__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__plane__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
plane__extra__AttributeData* attributeData = newData<plane__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PLANE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__plane__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__box( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__box( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__box()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__half_extents( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__half_extents( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__half_extents()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::box__extra__AttributeData ColladaParserAutoGen::box__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__box__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__box__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
box__extra__AttributeData* attributeData = newData<box__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BOX__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__box__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sphere( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sphere( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sphere()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sphere__radius( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sphere__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sphere__radius()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::sphere__extra__AttributeData ColladaParserAutoGen::sphere__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__sphere__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__sphere__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
sphere__extra__AttributeData* attributeData = newData<sphere__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPHERE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__sphere__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cylinder( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cylinder()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cylinder__height( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cylinder__height()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cylinder__radius( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cylinder__radius( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cylinder__radius()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::cylinder__extra__AttributeData ColladaParserAutoGen::cylinder__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__cylinder__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
cylinder__extra__AttributeData* attributeData = newData<cylinder__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CYLINDER__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__cylinder__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_cylinder( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_cylinder( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_cylinder()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_cylinder__height( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_cylinder__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_cylinder__height()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_cylinder__radius1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_cylinder__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_cylinder__radius1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_cylinder__radius2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_cylinder__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_cylinder__radius2()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::tapered_cylinder__extra__AttributeData ColladaParserAutoGen::tapered_cylinder__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_cylinder__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_cylinder__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tapered_cylinder__extra__AttributeData* attributeData = newData<tapered_cylinder__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TAPERED_CYLINDER__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_cylinder__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_capsule( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_capsule( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_capsule()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_capsule__height( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_capsule__height( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_capsule__height()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_capsule__radius1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_capsule__radius1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_capsule__radius1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_capsule__radius2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_capsule__radius2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_capsule__radius2()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::tapered_capsule__extra__AttributeData ColladaParserAutoGen::tapered_capsule__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tapered_capsule__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tapered_capsule__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tapered_capsule__extra__AttributeData* attributeData = newData<tapered_capsule__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TAPERED_CAPSULE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tapered_capsule__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__translate__AttributeData ColladaParserAutoGen::shape__translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__translate__AttributeData* attributeData = newData<shape__translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__translate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__rotate__AttributeData ColladaParserAutoGen::shape__rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__rotate__AttributeData* attributeData = newData<shape__rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__rotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shape__extra__AttributeData ColladaParserAutoGen::shape__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shape__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shape__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shape__extra__AttributeData* attributeData = newData<shape__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHAPE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shape__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_rigid_body__technique__AttributeData ColladaParserAutoGen::instance_rigid_body__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_body__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_body__technique__AttributeData* attributeData = newData<instance_rigid_body__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_body__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_rigid_body__extra__AttributeData ColladaParserAutoGen::instance_rigid_body__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_body__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_body__extra__AttributeData* attributeData = newData<instance_rigid_body__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_BODY__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_body__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_rigid_constraint__AttributeData ColladaParserAutoGen::instance_rigid_constraint__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_constraint__AttributeData* attributeData = newData<instance_rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONSTRAINT:
    {

attributeData->constraint = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_constraint()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_rigid_constraint__extra__AttributeData ColladaParserAutoGen::instance_rigid_constraint__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_rigid_constraint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_rigid_constraint__extra__AttributeData* attributeData = newData<instance_rigid_constraint__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_RIGID_CONSTRAINT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_rigid_constraint__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_model__extra__AttributeData ColladaParserAutoGen::instance_physics_model__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_model__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_model__extra__AttributeData* attributeData = newData<instance_physics_model__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_model__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::gravity__AttributeData ColladaParserAutoGen::gravity__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__gravity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__gravity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
gravity__AttributeData* attributeData = newData<gravity__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GRAVITY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__gravity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::time_step__AttributeData ColladaParserAutoGen::time_step__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__time_step( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__time_step( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
time_step__AttributeData* attributeData = newData<time_step__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TIME_STEP , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__time_step()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_scene__technique__AttributeData ColladaParserAutoGen::physics_scene__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__technique__AttributeData* attributeData = newData<physics_scene__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_scene__extra__AttributeData ColladaParserAutoGen::physics_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_scene__extra__AttributeData* attributeData = newData<physics_scene__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_SCENE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_scenes__extra__AttributeData ColladaParserAutoGen::library_physics_scenes__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_scenes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_scenes__extra__AttributeData* attributeData = newData<library_physics_scenes__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_SCENES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_scenes__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::COLLADA__AttributeData ColladaParserAutoGen::COLLADA__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__COLLADA( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__COLLADA( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
COLLADA__AttributeData* attributeData = newData<COLLADA__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_VERSION:
    {



    break;
    }
    case HASH_ATTRIBUTE_BASE:
    {

attributeData->base = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLLADA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__COLLADA()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__COLLADA__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__COLLADA__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__COLLADA__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_animations__AttributeData ColladaParserAutoGen::library_animations__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animations( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animations( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animations__AttributeData* attributeData = newData<library_animations__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATIONS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animations()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animations__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animations__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animations__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_animations__extra__AttributeData ColladaParserAutoGen::library_animations__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animations__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animations__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animations__extra__AttributeData* attributeData = newData<library_animations__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATIONS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animations__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_animation_clips__AttributeData ColladaParserAutoGen::library_animation_clips__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animation_clips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animation_clips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animation_clips__AttributeData* attributeData = newData<library_animation_clips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animation_clips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animation_clips__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animation_clips__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animation_clips__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::animation_clip__AttributeData ColladaParserAutoGen::animation_clip__AttributeData::DEFAULT = {0, 0, 0.0E1, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation_clip( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation_clip( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation_clip__AttributeData* attributeData = newData<animation_clip__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_START:
    {
bool failed;
attributeData->start = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_START, attributeValue))
{return false;}
    break;
    }
    case HASH_ATTRIBUTE_END:
    {
bool failed;
attributeData->end = GeneratedSaxParser::Utils::toDouble(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP, HASH_ATTRIBUTE_END, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation_clip()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation_clip__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation_clip__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation_clip__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_animation__AttributeData ColladaParserAutoGen::instance_animation__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_animation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_animation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_animation__AttributeData* attributeData = newData<instance_animation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_ANIMATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_animation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_animation__extra__AttributeData ColladaParserAutoGen::instance_animation__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_animation__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_animation__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_animation__extra__AttributeData* attributeData = newData<instance_animation__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_ANIMATION__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_animation__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::animation_clip__extra__AttributeData ColladaParserAutoGen::animation_clip__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__animation_clip__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__animation_clip__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
animation_clip__extra__AttributeData* attributeData = newData<animation_clip__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANIMATION_CLIP__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__animation_clip__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_animation_clips__extra__AttributeData ColladaParserAutoGen::library_animation_clips__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_animation_clips__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_animation_clips__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_animation_clips__extra__AttributeData* attributeData = newData<library_animation_clips__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_ANIMATION_CLIPS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_animation_clips__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_cameras__AttributeData ColladaParserAutoGen::library_cameras__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_cameras( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_cameras( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_cameras__AttributeData* attributeData = newData<library_cameras__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CAMERAS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_cameras()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_cameras__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_cameras__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_cameras__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::camera__AttributeData ColladaParserAutoGen::camera__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__camera( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__camera( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
camera__AttributeData* attributeData = newData<camera__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAMERA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__camera()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__camera__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__camera__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__camera__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__optics( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__optics( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__optics()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__optics__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__optics__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__optics__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__orthographic( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__orthographic( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__orthographic()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::xmag__AttributeData ColladaParserAutoGen::xmag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__xmag( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__xmag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
xmag__AttributeData* attributeData = newData<xmag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_XMAG , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__xmag()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ymag__AttributeData ColladaParserAutoGen::ymag__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ymag( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ymag( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ymag__AttributeData* attributeData = newData<ymag__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_YMAG , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ymag()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::orthographic__aspect_ratio__AttributeData ColladaParserAutoGen::orthographic__aspect_ratio__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__orthographic__aspect_ratio( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__orthographic__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
orthographic__aspect_ratio__AttributeData* attributeData = newData<orthographic__aspect_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ASPECT_RATIO , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__orthographic__aspect_ratio()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::orthographic__znear__AttributeData ColladaParserAutoGen::orthographic__znear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__orthographic__znear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__orthographic__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
orthographic__znear__AttributeData* attributeData = newData<orthographic__znear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ZNEAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__orthographic__znear()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::orthographic__zfar__AttributeData ColladaParserAutoGen::orthographic__zfar__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__orthographic__zfar( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__orthographic__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
orthographic__zfar__AttributeData* attributeData = newData<orthographic__zfar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ORTHOGRAPHIC__ZFAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__orthographic__zfar()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__perspective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__perspective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__perspective()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::xfov__AttributeData ColladaParserAutoGen::xfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__xfov( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__xfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
xfov__AttributeData* attributeData = newData<xfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_XFOV , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__xfov()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::yfov__AttributeData ColladaParserAutoGen::yfov__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__yfov( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__yfov( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
yfov__AttributeData* attributeData = newData<yfov__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_YFOV , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__yfov()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::perspective__aspect_ratio__AttributeData ColladaParserAutoGen::perspective__aspect_ratio__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__perspective__aspect_ratio( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__perspective__aspect_ratio( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
perspective__aspect_ratio__AttributeData* attributeData = newData<perspective__aspect_ratio__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ASPECT_RATIO , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__perspective__aspect_ratio()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::perspective__znear__AttributeData ColladaParserAutoGen::perspective__znear__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__perspective__znear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__perspective__znear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
perspective__znear__AttributeData* attributeData = newData<perspective__znear__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ZNEAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__perspective__znear()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::perspective__zfar__AttributeData ColladaParserAutoGen::perspective__zfar__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__perspective__zfar( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__perspective__zfar( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
perspective__zfar__AttributeData* attributeData = newData<perspective__zfar__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PERSPECTIVE__ZFAR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__perspective__zfar()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::optics__technique__AttributeData ColladaParserAutoGen::optics__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__optics__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__optics__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
optics__technique__AttributeData* attributeData = newData<optics__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_OPTICS__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__optics__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::optics__extra__AttributeData ColladaParserAutoGen::optics__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__optics__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__optics__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
optics__extra__AttributeData* attributeData = newData<optics__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_OPTICS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__optics__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__imager( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__imager( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__imager()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::imager__technique__AttributeData ColladaParserAutoGen::imager__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__imager__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__imager__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
imager__technique__AttributeData* attributeData = newData<imager__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGER__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__imager__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::imager__extra__AttributeData ColladaParserAutoGen::imager__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__imager__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__imager__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
imager__extra__AttributeData* attributeData = newData<imager__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGER__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__imager__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::camera__extra__AttributeData ColladaParserAutoGen::camera__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__camera__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__camera__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
camera__extra__AttributeData* attributeData = newData<camera__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CAMERA__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__camera__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_cameras__extra__AttributeData ColladaParserAutoGen::library_cameras__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_cameras__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_cameras__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_cameras__extra__AttributeData* attributeData = newData<library_cameras__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CAMERAS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_cameras__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_controllers__AttributeData ColladaParserAutoGen::library_controllers__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_controllers( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_controllers( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_controllers__AttributeData* attributeData = newData<library_controllers__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CONTROLLERS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_controllers()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_controllers__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_controllers__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_controllers__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::controller__AttributeData ColladaParserAutoGen::controller__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__controller( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__controller( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
controller__AttributeData* attributeData = newData<controller__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROLLER , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__controller()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__controller__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__controller__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__controller__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::skin__AttributeData ColladaParserAutoGen::skin__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__skin( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__skin( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skin__AttributeData* attributeData = newData<skin__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__skin()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_shape_matrix( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_shape_matrix( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_shape_matrix()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::skin__source__AttributeData ColladaParserAutoGen::skin__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__skin__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__skin__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skin__source__AttributeData* attributeData = newData<skin__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__skin__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__joints( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__joints( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__joints()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::joints__input__AttributeData ColladaParserAutoGen::joints__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__joints__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__joints__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
joints__input__AttributeData* attributeData = newData<joints__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_JOINTS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__joints__input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::joints__extra__AttributeData ColladaParserAutoGen::joints__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__joints__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__joints__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
joints__extra__AttributeData* attributeData = newData<joints__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_JOINTS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__joints__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertex_weights__AttributeData ColladaParserAutoGen::vertex_weights__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertex_weights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertex_weights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertex_weights__AttributeData* attributeData = newData<vertex_weights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertex_weights()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertex_weights__input__AttributeData ColladaParserAutoGen::vertex_weights__input__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertex_weights__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertex_weights__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertex_weights__input__AttributeData* attributeData = newData<vertex_weights__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OFFSET:
    {



    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    case HASH_ATTRIBUTE_SET:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertex_weights__input()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertex_weights__vcount( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertex_weights__vcount( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertex_weights__vcount()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__v( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__v( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__v()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertex_weights__extra__AttributeData ColladaParserAutoGen::vertex_weights__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertex_weights__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertex_weights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertex_weights__extra__AttributeData* attributeData = newData<vertex_weights__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTEX_WEIGHTS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertex_weights__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::skin__extra__AttributeData ColladaParserAutoGen::skin__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__skin__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__skin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
skin__extra__AttributeData* attributeData = newData<skin__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SKIN__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__skin__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::morph__AttributeData ColladaParserAutoGen::morph__AttributeData::DEFAULT = {(const ParserChar *)"NORMALIZED", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__morph( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__morph( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
morph__AttributeData* attributeData = newData<morph__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_METHOD:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__morph()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::morph__source__AttributeData ColladaParserAutoGen::morph__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__morph__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__morph__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
morph__source__AttributeData* attributeData = newData<morph__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__morph__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__targets( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__targets( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__targets()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::targets__input__AttributeData ColladaParserAutoGen::targets__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__targets__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__targets__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
targets__input__AttributeData* attributeData = newData<targets__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TARGETS__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__targets__input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::targets__extra__AttributeData ColladaParserAutoGen::targets__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__targets__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__targets__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
targets__extra__AttributeData* attributeData = newData<targets__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TARGETS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__targets__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::morph__extra__AttributeData ColladaParserAutoGen::morph__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__morph__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__morph__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
morph__extra__AttributeData* attributeData = newData<morph__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_MORPH__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__morph__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::controller__extra__AttributeData ColladaParserAutoGen::controller__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__controller__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__controller__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
controller__extra__AttributeData* attributeData = newData<controller__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROLLER__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__controller__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_controllers__extra__AttributeData ColladaParserAutoGen::library_controllers__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_controllers__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_controllers__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_controllers__extra__AttributeData* attributeData = newData<library_controllers__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_CONTROLLERS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_controllers__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_geometries__AttributeData ColladaParserAutoGen::library_geometries__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_geometries( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_geometries( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
	library_geometries__AttributeData* attributeData = newData<library_geometries__AttributeData>(attributeDataPtr);

	const ParserChar** attributeArray = attributes.attributes;
	if ( attributeArray )
	{
		while (true)
		{
			const ParserChar * attribute = *attributeArray;
			if ( !attribute ) 
				break;
			StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
			attributeArray++;
			if ( !attributeArray )
				return false;
			const ParserChar* attributeValue = *attributeArray;
			attributeArray++;


			switch ( hash )
			{
			case HASH_ATTRIBUTE_ID:
				{

					attributeData->id = attributeValue;

					break;
				}
			case HASH_ATTRIBUTE_NAME:
				{

					attributeData->name = attributeValue;

					break;
				}
			default:
				{
					if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_GEOMETRIES , 0, attributeValue))
					{return false;}
				}
			}
		}
	}
	return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_geometries()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_geometries__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_geometries__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_geometries__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::geometry__AttributeData ColladaParserAutoGen::geometry__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
geometry__AttributeData* attributeData = newData<geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GEOMETRY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__geometry()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__geometry__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__geometry__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__geometry__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__AttributeData ColladaParserAutoGen::convex_mesh__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__AttributeData* attributeData = newData<convex_mesh__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CONVEX_HULL_OF:
    {

attributeData->convex_hull_of = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__source__AttributeData ColladaParserAutoGen::convex_mesh__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__source__AttributeData* attributeData = newData<convex_mesh__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__source()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__vertices__AttributeData ColladaParserAutoGen::convex_mesh__vertices__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__vertices__AttributeData* attributeData = newData<convex_mesh__vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__VERTICES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__vertices()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__lines__AttributeData ColladaParserAutoGen::convex_mesh__lines__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__lines( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__lines( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__lines__AttributeData* attributeData = newData<convex_mesh__lines__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__lines()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__linestrips__AttributeData ColladaParserAutoGen::convex_mesh__linestrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__linestrips__AttributeData* attributeData = newData<convex_mesh__linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__LINESTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__linestrips()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__polygons__AttributeData ColladaParserAutoGen::convex_mesh__polygons__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__polygons__AttributeData* attributeData = newData<convex_mesh__polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYGONS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__polygons()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__polylist__AttributeData ColladaParserAutoGen::convex_mesh__polylist__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__polylist__AttributeData* attributeData = newData<convex_mesh__polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__POLYLIST , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__polylist()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__triangles__AttributeData ColladaParserAutoGen::convex_mesh__triangles__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__triangles__AttributeData* attributeData = newData<convex_mesh__triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIANGLES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__triangles()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__trifans__AttributeData ColladaParserAutoGen::convex_mesh__trifans__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__trifans( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__trifans( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__trifans__AttributeData* attributeData = newData<convex_mesh__trifans__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRIFANS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__trifans()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__tristrips__AttributeData ColladaParserAutoGen::convex_mesh__tristrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__tristrips__AttributeData* attributeData = newData<convex_mesh__tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__TRISTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__tristrips()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::convex_mesh__extra__AttributeData ColladaParserAutoGen::convex_mesh__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__convex_mesh__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__convex_mesh__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
convex_mesh__extra__AttributeData* attributeData = newData<convex_mesh__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONVEX_MESH__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__convex_mesh__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spline__AttributeData ColladaParserAutoGen::spline__AttributeData::DEFAULT = {(const ParserChar *)"false"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spline( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spline( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spline__AttributeData* attributeData = newData<spline__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_CLOSED:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spline()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spline__source__AttributeData ColladaParserAutoGen::spline__source__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spline__source( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spline__source( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spline__source__AttributeData* attributeData = newData<spline__source__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE__SOURCE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spline__source()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__control_vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__control_vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__control_vertices()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::control_vertices__input__AttributeData ColladaParserAutoGen::control_vertices__input__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__control_vertices__input( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__control_vertices__input( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
control_vertices__input__AttributeData* attributeData = newData<control_vertices__input__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROL_VERTICES__INPUT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__control_vertices__input()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::control_vertices__extra__AttributeData ColladaParserAutoGen::control_vertices__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__control_vertices__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__control_vertices__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
control_vertices__extra__AttributeData* attributeData = newData<control_vertices__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONTROL_VERTICES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__control_vertices__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spline__extra__AttributeData ColladaParserAutoGen::spline__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spline__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spline__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spline__extra__AttributeData* attributeData = newData<spline__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPLINE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spline__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::geometry__extra__AttributeData ColladaParserAutoGen::geometry__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__geometry__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__geometry__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
geometry__extra__AttributeData* attributeData = newData<geometry__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GEOMETRY__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__geometry__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_geometries__extra__AttributeData ColladaParserAutoGen::library_geometries__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_geometries__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_geometries__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_geometries__extra__AttributeData* attributeData = newData<library_geometries__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_GEOMETRIES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_geometries__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_effects__AttributeData ColladaParserAutoGen::library_effects__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_effects( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_effects( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_effects__AttributeData* attributeData = newData<library_effects__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_EFFECTS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_effects()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_effects__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_effects__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_effects__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::effect__AttributeData ColladaParserAutoGen::effect__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__AttributeData* attributeData = newData<effect__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::effect__annotate__AttributeData ColladaParserAutoGen::effect__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__annotate__AttributeData* attributeData = newData<effect__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect__annotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::effect__image__AttributeData ColladaParserAutoGen::effect__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__image__AttributeData* attributeData = newData<effect__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::effect__newparam__AttributeData ColladaParserAutoGen::effect__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__newparam__AttributeData* attributeData = newData<effect__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::effect__extra__AttributeData ColladaParserAutoGen::effect__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__effect__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__effect__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
effect__extra__AttributeData* attributeData = newData<effect__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EFFECT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__effect__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_effects__extra__AttributeData ColladaParserAutoGen::library_effects__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_effects__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_effects__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_effects__extra__AttributeData* attributeData = newData<library_effects__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_EFFECTS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_effects__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_images__AttributeData ColladaParserAutoGen::library_images__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_images( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_images( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_images__AttributeData* attributeData = newData<library_images__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_images()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_images__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_images__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_images__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_images__image__AttributeData ColladaParserAutoGen::library_images__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_images__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_images__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_images__image__AttributeData* attributeData = newData<library_images__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_images__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_images__extra__AttributeData ColladaParserAutoGen::library_images__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_images__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_images__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_images__extra__AttributeData* attributeData = newData<library_images__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_IMAGES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_images__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_lights__AttributeData ColladaParserAutoGen::library_lights__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_lights( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_lights( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_lights__AttributeData* attributeData = newData<library_lights__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_LIGHTS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_lights()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_lights__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_lights__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_lights__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light__AttributeData ColladaParserAutoGen::light__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light__AttributeData* attributeData = newData<light__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light__asset()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique_common__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique_common__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique_common__ambient()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ambient__color__AttributeData ColladaParserAutoGen::ambient__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ambient__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ambient__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ambient__color__AttributeData* attributeData = newData<ambient__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ambient__color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__directional( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__directional( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__directional()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::directional__color__AttributeData ColladaParserAutoGen::directional__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__directional__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__directional__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
directional__color__AttributeData* attributeData = newData<directional__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIRECTIONAL__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__directional__color()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point__color__AttributeData ColladaParserAutoGen::point__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point__color__AttributeData* attributeData = newData<point__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point__constant_attenuation__AttributeData ColladaParserAutoGen::point__constant_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point__constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point__constant_attenuation__AttributeData* attributeData = newData<point__constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__CONSTANT_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point__constant_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point__linear_attenuation__AttributeData ColladaParserAutoGen::point__linear_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point__linear_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point__linear_attenuation__AttributeData* attributeData = newData<point__linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__LINEAR_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point__linear_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::point__quadratic_attenuation__AttributeData ColladaParserAutoGen::point__quadratic_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__point__quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__point__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
point__quadratic_attenuation__AttributeData* attributeData = newData<point__quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POINT__QUADRATIC_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__point__quadratic_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spot( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spot( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spot()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spot__color__AttributeData ColladaParserAutoGen::spot__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spot__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spot__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spot__color__AttributeData* attributeData = newData<spot__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spot__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spot__constant_attenuation__AttributeData ColladaParserAutoGen::spot__constant_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spot__constant_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spot__constant_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spot__constant_attenuation__AttributeData* attributeData = newData<spot__constant_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__CONSTANT_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spot__constant_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spot__linear_attenuation__AttributeData ColladaParserAutoGen::spot__linear_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spot__linear_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spot__linear_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spot__linear_attenuation__AttributeData* attributeData = newData<spot__linear_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__LINEAR_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spot__linear_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::spot__quadratic_attenuation__AttributeData ColladaParserAutoGen::spot__quadratic_attenuation__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spot__quadratic_attenuation( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spot__quadratic_attenuation( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
spot__quadratic_attenuation__AttributeData* attributeData = newData<spot__quadratic_attenuation__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPOT__QUADRATIC_ATTENUATION , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spot__quadratic_attenuation()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::falloff_angle__AttributeData ColladaParserAutoGen::falloff_angle__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__falloff_angle( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__falloff_angle( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
falloff_angle__AttributeData* attributeData = newData<falloff_angle__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FALLOFF_ANGLE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__falloff_angle()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::falloff_exponent__AttributeData ColladaParserAutoGen::falloff_exponent__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__falloff_exponent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__falloff_exponent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
falloff_exponent__AttributeData* attributeData = newData<falloff_exponent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_FALLOFF_EXPONENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__falloff_exponent()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light__technique__AttributeData ColladaParserAutoGen::light__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light__technique__AttributeData* attributeData = newData<light__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::light__extra__AttributeData ColladaParserAutoGen::light__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__light__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__light__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
light__extra__AttributeData* attributeData = newData<light__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIGHT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__light__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_lights__extra__AttributeData ColladaParserAutoGen::library_lights__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_lights__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_lights__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_lights__extra__AttributeData* attributeData = newData<library_lights__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_LIGHTS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_lights__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_materials__AttributeData ColladaParserAutoGen::library_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_materials__AttributeData* attributeData = newData<library_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_MATERIALS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_materials()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_materials__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_materials__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_materials__extra__AttributeData ColladaParserAutoGen::library_materials__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_materials__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_materials__extra__AttributeData* attributeData = newData<library_materials__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_MATERIALS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_materials__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_nodes__AttributeData ColladaParserAutoGen::library_nodes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_nodes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_nodes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_nodes__AttributeData* attributeData = newData<library_nodes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_nodes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_nodes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_nodes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_nodes__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_nodes__node__AttributeData ColladaParserAutoGen::library_nodes__node__AttributeData::DEFAULT = {0, 0, 0, (const ParserChar *)"NODE", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_nodes__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_nodes__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_nodes__node__AttributeData* attributeData = newData<library_nodes__node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES__NODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_nodes__node()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_nodes__extra__AttributeData ColladaParserAutoGen::library_nodes__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_nodes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_nodes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_nodes__extra__AttributeData* attributeData = newData<library_nodes__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_NODES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_nodes__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_materials__AttributeData ColladaParserAutoGen::library_physics_materials__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_materials( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_materials( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_materials__AttributeData* attributeData = newData<library_physics_materials__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_materials()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_materials__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_materials__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_materials__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_materials__physics_material__AttributeData ColladaParserAutoGen::library_physics_materials__physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_materials__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_materials__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_materials__physics_material__AttributeData* attributeData = newData<library_physics_materials__physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_materials__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_materials__extra__AttributeData ColladaParserAutoGen::library_physics_materials__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_materials__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_materials__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_materials__extra__AttributeData* attributeData = newData<library_physics_materials__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MATERIALS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_materials__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_models__AttributeData ColladaParserAutoGen::library_physics_models__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_models( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_models( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_models__AttributeData* attributeData = newData<library_physics_models__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MODELS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_models()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_models__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_models__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_models__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_model__AttributeData ColladaParserAutoGen::physics_model__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_model__AttributeData* attributeData = newData<physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_model()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_model__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_model__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_model__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_body__AttributeData ColladaParserAutoGen::rigid_body__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_body( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_body( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_body__AttributeData* attributeData = newData<rigid_body__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_body()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_body__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_body__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_body__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_body__technique__AttributeData ColladaParserAutoGen::rigid_body__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_body__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_body__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_body__technique__AttributeData* attributeData = newData<rigid_body__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_body__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_body__extra__AttributeData ColladaParserAutoGen::rigid_body__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_body__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_body__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_body__extra__AttributeData* attributeData = newData<rigid_body__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_BODY__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_body__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_constraint__AttributeData ColladaParserAutoGen::rigid_constraint__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_constraint( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_constraint( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_constraint__AttributeData* attributeData = newData<rigid_constraint__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_constraint()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ref_attachment__AttributeData ColladaParserAutoGen::ref_attachment__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ref_attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ref_attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ref_attachment__AttributeData* attributeData = newData<ref_attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {

attributeData->rigid_body = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ref_attachment()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ref_attachment__translate__AttributeData ColladaParserAutoGen::ref_attachment__translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ref_attachment__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ref_attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ref_attachment__translate__AttributeData* attributeData = newData<ref_attachment__translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ref_attachment__translate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ref_attachment__rotate__AttributeData ColladaParserAutoGen::ref_attachment__rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ref_attachment__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ref_attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ref_attachment__rotate__AttributeData* attributeData = newData<ref_attachment__rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ref_attachment__rotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ref_attachment__extra__AttributeData ColladaParserAutoGen::ref_attachment__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ref_attachment__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ref_attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ref_attachment__extra__AttributeData* attributeData = newData<ref_attachment__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REF_ATTACHMENT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ref_attachment__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::attachment__AttributeData ColladaParserAutoGen::attachment__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__attachment( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__attachment( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
attachment__AttributeData* attributeData = newData<attachment__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_RIGID_BODY:
    {

attributeData->rigid_body = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__attachment()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::attachment__translate__AttributeData ColladaParserAutoGen::attachment__translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__attachment__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__attachment__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
attachment__translate__AttributeData* attributeData = newData<attachment__translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__attachment__translate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::attachment__rotate__AttributeData ColladaParserAutoGen::attachment__rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__attachment__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__attachment__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
attachment__rotate__AttributeData* attributeData = newData<attachment__rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__attachment__rotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::attachment__extra__AttributeData ColladaParserAutoGen::attachment__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__attachment__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__attachment__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
attachment__extra__AttributeData* attributeData = newData<attachment__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ATTACHMENT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__attachment__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_constraint__technique_common( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_constraint__technique_common( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_constraint__technique_common()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::enabled__AttributeData ColladaParserAutoGen::enabled__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__enabled( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__enabled( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
enabled__AttributeData* attributeData = newData<enabled__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ENABLED , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__enabled()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::interpenetrate__AttributeData ColladaParserAutoGen::interpenetrate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__interpenetrate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__interpenetrate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
interpenetrate__AttributeData* attributeData = newData<interpenetrate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INTERPENETRATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__interpenetrate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__limits( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__limits( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__limits()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__swing_cone_and_twist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__swing_cone_and_twist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__swing_cone_and_twist()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::swing_cone_and_twist__min__AttributeData ColladaParserAutoGen::swing_cone_and_twist__min__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__swing_cone_and_twist__min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__swing_cone_and_twist__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
swing_cone_and_twist__min__AttributeData* attributeData = newData<swing_cone_and_twist__min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SWING_CONE_AND_TWIST__MIN , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__swing_cone_and_twist__min()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::swing_cone_and_twist__max__AttributeData ColladaParserAutoGen::swing_cone_and_twist__max__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__swing_cone_and_twist__max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__swing_cone_and_twist__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
swing_cone_and_twist__max__AttributeData* attributeData = newData<swing_cone_and_twist__max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SWING_CONE_AND_TWIST__MAX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__swing_cone_and_twist__max()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__limits__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__limits__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__limits__linear()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linear__min__AttributeData ColladaParserAutoGen::linear__min__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linear__min( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linear__min( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear__min__AttributeData* attributeData = newData<linear__min__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__MIN , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linear__min()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linear__max__AttributeData ColladaParserAutoGen::linear__max__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linear__max( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linear__max( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear__max__AttributeData* attributeData = newData<linear__max__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__MAX , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linear__max()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spring( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spring( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spring()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__angular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__angular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__angular()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::angular__stiffness__AttributeData ColladaParserAutoGen::angular__stiffness__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__angular__stiffness( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__angular__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
angular__stiffness__AttributeData* attributeData = newData<angular__stiffness__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__STIFFNESS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__angular__stiffness()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::angular__damping__AttributeData ColladaParserAutoGen::angular__damping__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__angular__damping( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__angular__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
angular__damping__AttributeData* attributeData = newData<angular__damping__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__DAMPING , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__angular__damping()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::angular__target_value__AttributeData ColladaParserAutoGen::angular__target_value__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__angular__target_value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__angular__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
angular__target_value__AttributeData* attributeData = newData<angular__target_value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ANGULAR__TARGET_VALUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__angular__target_value()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__spring__linear( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__spring__linear( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__spring__linear()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linear__stiffness__AttributeData ColladaParserAutoGen::linear__stiffness__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linear__stiffness( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linear__stiffness( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear__stiffness__AttributeData* attributeData = newData<linear__stiffness__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__STIFFNESS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linear__stiffness()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linear__damping__AttributeData ColladaParserAutoGen::linear__damping__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linear__damping( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linear__damping( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear__damping__AttributeData* attributeData = newData<linear__damping__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__DAMPING , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linear__damping()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linear__target_value__AttributeData ColladaParserAutoGen::linear__target_value__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linear__target_value( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linear__target_value( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linear__target_value__AttributeData* attributeData = newData<linear__target_value__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINEAR__TARGET_VALUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linear__target_value()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_constraint__technique__AttributeData ColladaParserAutoGen::rigid_constraint__technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_constraint__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_constraint__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_constraint__technique__AttributeData* attributeData = newData<rigid_constraint__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_constraint__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rigid_constraint__extra__AttributeData ColladaParserAutoGen::rigid_constraint__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rigid_constraint__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rigid_constraint__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rigid_constraint__extra__AttributeData* attributeData = newData<rigid_constraint__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_RIGID_CONSTRAINT__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rigid_constraint__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_model__instance_physics_model__AttributeData ColladaParserAutoGen::physics_model__instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_model__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_model__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_model__instance_physics_model__AttributeData* attributeData = newData<physics_model__instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {

attributeData->parent = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL__INSTANCE_PHYSICS_MODEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_model__instance_physics_model()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_model__extra__AttributeData ColladaParserAutoGen::physics_model__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_model__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_model__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_model__extra__AttributeData* attributeData = newData<physics_model__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MODEL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_model__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_physics_models__extra__AttributeData ColladaParserAutoGen::library_physics_models__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_physics_models__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_physics_models__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_physics_models__extra__AttributeData* attributeData = newData<library_physics_models__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_PHYSICS_MODELS__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_physics_models__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_visual_scenes__AttributeData ColladaParserAutoGen::library_visual_scenes__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_visual_scenes( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_visual_scenes( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_visual_scenes__AttributeData* attributeData = newData<library_visual_scenes__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
if (!attributeArray) return true;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_VISUAL_SCENES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_visual_scenes()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_visual_scenes__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_visual_scenes__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_visual_scenes__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::library_visual_scenes__extra__AttributeData ColladaParserAutoGen::library_visual_scenes__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__library_visual_scenes__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__library_visual_scenes__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
library_visual_scenes__extra__AttributeData* attributeData = newData<library_visual_scenes__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LIBRARY_VISUAL_SCENES__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__library_visual_scenes__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__scene()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_scene__AttributeData ColladaParserAutoGen::instance_physics_scene__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_scene__AttributeData* attributeData = newData<instance_physics_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_SCENE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_scene()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_scene__extra__AttributeData ColladaParserAutoGen::instance_physics_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_scene__extra__AttributeData* attributeData = newData<instance_physics_scene__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_SCENE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_visual_scene__AttributeData ColladaParserAutoGen::instance_visual_scene__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_visual_scene( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_visual_scene( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_visual_scene__AttributeData* attributeData = newData<instance_visual_scene__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_VISUAL_SCENE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_visual_scene()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_visual_scene__extra__AttributeData ColladaParserAutoGen::instance_visual_scene__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_visual_scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_visual_scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_visual_scene__extra__AttributeData* attributeData = newData<instance_visual_scene__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_VISUAL_SCENE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_visual_scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::scene__extra__AttributeData ColladaParserAutoGen::scene__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__scene__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__scene__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
scene__extra__AttributeData* attributeData = newData<scene__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SCENE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__scene__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::COLLADA__extra__AttributeData ColladaParserAutoGen::COLLADA__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__COLLADA__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__COLLADA__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
COLLADA__extra__AttributeData* attributeData = newData<COLLADA__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_COLLADA__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__COLLADA__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::param__AttributeData ColladaParserAutoGen::param__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
param__AttributeData* attributeData = newData<param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SEMANTIC:
    {

attributeData->semantic = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_geometry__AttributeData ColladaParserAutoGen::instance_geometry__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_geometry( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_geometry( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_geometry__AttributeData* attributeData = newData<instance_geometry__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_GEOMETRY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_geometry()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__AttributeData ColladaParserAutoGen::profile_GLSL__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__AttributeData* attributeData = newData<profile_GLSL__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__code__AttributeData ColladaParserAutoGen::profile_GLSL__code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__code( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__code__AttributeData* attributeData = newData<profile_GLSL__code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__CODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__code()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__include__AttributeData ColladaParserAutoGen::profile_GLSL__include__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__include__AttributeData* attributeData = newData<profile_GLSL__include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__INCLUDE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__include()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__image__AttributeData ColladaParserAutoGen::profile_GLSL__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__image__AttributeData* attributeData = newData<profile_GLSL__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__newparam__AttributeData ColladaParserAutoGen::profile_GLSL__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__newparam__AttributeData* attributeData = newData<profile_GLSL__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__newparam()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__array__AttributeData ColladaParserAutoGen::newparam__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__array__AttributeData* attributeData = newData<newparam__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int4()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::array__surface__AttributeData ColladaParserAutoGen::array__surface__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
array__surface__AttributeData* attributeData = newData<array__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__SURFACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::generator__annotate__AttributeData ColladaParserAutoGen::generator__annotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator__annotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator__annotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__annotate__AttributeData* attributeData = newData<generator__annotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__ANNOTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator__annotate()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::generator__code__AttributeData ColladaParserAutoGen::generator__code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator__code( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__code__AttributeData* attributeData = newData<generator__code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__CODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator__code()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::generator__include__AttributeData ColladaParserAutoGen::generator__include__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__include__AttributeData* attributeData = newData<generator__include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__INCLUDE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator__include()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::generator__name__AttributeData ColladaParserAutoGen::generator__name__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator__name( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator__name( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__name__AttributeData* attributeData = newData<generator__name__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__NAME , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator__name()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::generator__setparam__AttributeData ColladaParserAutoGen::generator__setparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__generator__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__generator__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
generator__setparam__AttributeData* attributeData = newData<generator__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_GENERATOR__SETPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__generator__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__enum( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__enum()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::array__array__AttributeData ColladaParserAutoGen::array__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
array__array__AttributeData* attributeData = newData<array__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__technique__AttributeData ColladaParserAutoGen::profile_GLSL__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__technique__AttributeData* attributeData = newData<profile_GLSL__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__code__AttributeData ColladaParserAutoGen::technique__code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__code( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__code__AttributeData* attributeData = newData<technique__code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__CODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__code()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__include__AttributeData ColladaParserAutoGen::technique__include__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__include__AttributeData* attributeData = newData<technique__include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE__INCLUDE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__include()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_GLSL__extra__AttributeData ColladaParserAutoGen::profile_GLSL__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_GLSL__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_GLSL__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_GLSL__extra__AttributeData* attributeData = newData<profile_GLSL__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_GLSL__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_GLSL__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::image__AttributeData ColladaParserAutoGen::image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
image__AttributeData* attributeData = newData<image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_model__AttributeData ColladaParserAutoGen::instance_physics_model__AttributeData::DEFAULT = {0, 0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_model( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_model( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_model__AttributeData* attributeData = newData<instance_physics_model__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PARENT:
    {

attributeData->parent = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MODEL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_model()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::physics_material__AttributeData ColladaParserAutoGen::physics_material__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
physics_material__AttributeData* attributeData = newData<physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::linestrips__AttributeData ColladaParserAutoGen::linestrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__linestrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__linestrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
linestrips__AttributeData* attributeData = newData<linestrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LINESTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__linestrips()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__gl_hook_abstract( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__gl_hook_abstract( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__gl_hook_abstract()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::node__AttributeData ColladaParserAutoGen::node__AttributeData::DEFAULT = {0, 0, 0, (const ParserChar *)"NODE", 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__node( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__node( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
node__AttributeData* attributeData = newData<node__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    case HASH_ATTRIBUTE_LAYER:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__node()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::technique__AttributeData ColladaParserAutoGen::technique__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
technique__AttributeData* attributeData = newData<technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_PROFILE:
    {

attributeData->profile = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::tristrips__AttributeData ColladaParserAutoGen::tristrips__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__tristrips( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__tristrips( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
tristrips__AttributeData* attributeData = newData<tristrips__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRISTRIPS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__tristrips()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__AttributeData ColladaParserAutoGen::profile_CG__AttributeData::DEFAULT = {0, (const ParserChar *)"PC"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__AttributeData* attributeData = newData<profile_CG__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_PLATFORM:
    {

attributeData->platform = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__code__AttributeData ColladaParserAutoGen::profile_CG__code__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__code( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__code( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__code__AttributeData* attributeData = newData<profile_CG__code__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__CODE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__code()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__include__AttributeData ColladaParserAutoGen::profile_CG__include__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__include( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__include( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__include__AttributeData* attributeData = newData<profile_CG__include__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__INCLUDE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__include()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__image__AttributeData ColladaParserAutoGen::profile_CG__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__image__AttributeData* attributeData = newData<profile_CG__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__newparam__AttributeData ColladaParserAutoGen::profile_CG__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__newparam__AttributeData* attributeData = newData<profile_CG__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__newparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__bool4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__bool4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__float1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__float1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__int4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__int4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__half4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__half4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__fixed4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__fixed4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__string( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__string()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::newparam__usertype__AttributeData ColladaParserAutoGen::newparam__usertype__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__newparam__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__newparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
newparam__usertype__AttributeData* attributeData = newData<newparam__usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_NEWPARAM__USERTYPE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__newparam__usertype()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__bool4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__bool4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__float4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__float4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__float4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__int4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__int4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__half4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__half4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__fixed4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__fixed4x4()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::usertype__surface__AttributeData ColladaParserAutoGen::usertype__surface__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__surface( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__surface( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__surface__AttributeData* attributeData = newData<usertype__surface__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TYPE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__SURFACE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__surface()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__sampler1D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__sampler1D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__sampler1D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__sampler2D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__sampler2D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__sampler2D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__sampler3D( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__sampler3D( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__sampler3D()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__samplerRECT( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__samplerRECT( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__samplerRECT()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__samplerCUBE( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__samplerCUBE( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__samplerCUBE()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__samplerDEPTH( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__samplerDEPTH( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__samplerDEPTH()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__string( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__string()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__enum( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__enum( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__enum()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::usertype__array__AttributeData ColladaParserAutoGen::usertype__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__array__AttributeData* attributeData = newData<usertype__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__array()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__bool4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__bool4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__float4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__float4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__float4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__int4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__int4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__half4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__half4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__fixed4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__fixed4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__string( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__string()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::array__usertype__AttributeData ColladaParserAutoGen::array__usertype__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__array__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__array__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
array__usertype__AttributeData* attributeData = newData<array__usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ARRAY__USERTYPE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__array__usertype()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::usertype__usertype__AttributeData ColladaParserAutoGen::usertype__usertype__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__usertype__AttributeData* attributeData = newData<usertype__usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__USERTYPE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__usertype()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::usertype__connect_param__AttributeData ColladaParserAutoGen::usertype__connect_param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__connect_param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__connect_param__AttributeData* attributeData = newData<usertype__connect_param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__CONNECT_PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__connect_param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::usertype__setparam__AttributeData ColladaParserAutoGen::usertype__setparam__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__usertype__setparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__usertype__setparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
usertype__setparam__AttributeData* attributeData = newData<usertype__setparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {



    break;
    }
    case HASH_ATTRIBUTE_PROGRAM:
    {

attributeData->program = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_USERTYPE__SETPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__usertype__setparam()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__bool4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__bool4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__bool4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__float1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__float1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__float1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__int4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__int4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__int4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__half4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__half4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__half4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed1x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed1x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed1x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed1x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed1x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed1x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed1x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed1x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed1x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed1x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed1x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed1x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed2x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed2x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed2x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed2x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed2x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed2x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed2x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed2x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed2x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed2x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed2x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed2x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed3x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed3x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed3x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed3x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed3x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed3x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed3x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed3x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed3x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed3x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed3x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed3x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed4x1( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed4x1( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed4x1()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed4x2( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed4x2( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed4x2()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed4x3( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed4x3( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed4x3()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__fixed4x4( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__fixed4x4( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__fixed4x4()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__string( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__string( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__string()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__usertype__AttributeData ColladaParserAutoGen::setparam__usertype__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__usertype( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__usertype( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__usertype__AttributeData* attributeData = newData<setparam__usertype__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {



    break;
    }
    case HASH_ATTRIBUTE_SOURCE:
    {

attributeData->source = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__USERTYPE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__usertype()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__array__AttributeData ColladaParserAutoGen::setparam__array__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__array( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__array( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__array__AttributeData* attributeData = newData<setparam__array__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_LENGTH:
    {
bool failed;
attributeData->length = GeneratedSaxParser::Utils::toUnsignedLong(attributeValue, failed);
if ( failed && handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ARRAY, HASH_ATTRIBUTE_LENGTH, attributeValue))
{return false;}
    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__ARRAY , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__array()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::setparam__connect_param__AttributeData ColladaParserAutoGen::setparam__connect_param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__setparam__connect_param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__setparam__connect_param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
setparam__connect_param__AttributeData* attributeData = newData<setparam__connect_param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SETPARAM__CONNECT_PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__setparam__connect_param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__technique__AttributeData ColladaParserAutoGen::profile_CG__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__technique__AttributeData* attributeData = newData<profile_CG__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__technique()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_CG__extra__AttributeData ColladaParserAutoGen::profile_CG__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_CG__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_CG__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_CG__extra__AttributeData* attributeData = newData<profile_CG__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_CG__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_CG__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_COMMON__AttributeData ColladaParserAutoGen::profile_COMMON__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__AttributeData* attributeData = newData<profile_COMMON__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_COMMON__image__AttributeData ColladaParserAutoGen::profile_COMMON__image__AttributeData::DEFAULT = {0, 0, 0, 0, 0, (const ParserChar *)"1"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON__image( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON__image( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__image__AttributeData* attributeData = newData<profile_COMMON__image__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_FORMAT:
    {

attributeData->format = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_HEIGHT:
    {



    break;
    }
    case HASH_ATTRIBUTE_WIDTH:
    {



    break;
    }
    case HASH_ATTRIBUTE_DEPTH:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__IMAGE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON__image()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_COMMON__newparam__AttributeData ColladaParserAutoGen::profile_COMMON__newparam__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON__newparam( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON__newparam( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__newparam__AttributeData* attributeData = newData<profile_COMMON__newparam__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__NEWPARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON__newparam()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_COMMON__technique__AttributeData ColladaParserAutoGen::profile_COMMON__technique__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON__technique( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON__technique( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__technique__AttributeData* attributeData = newData<profile_COMMON__technique__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__TECHNIQUE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON__technique()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__technique__constant( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__technique__constant( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__technique__constant()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__emission()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::emission__color__AttributeData ColladaParserAutoGen::emission__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__emission__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__emission__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
emission__color__AttributeData* attributeData = newData<emission__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__emission__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::emission__param__AttributeData ColladaParserAutoGen::emission__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__emission__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__emission__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
emission__param__AttributeData* attributeData = newData<emission__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__emission__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::emission__texture__AttributeData ColladaParserAutoGen::emission__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__emission__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__emission__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
emission__texture__AttributeData* attributeData = newData<emission__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EMISSION__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__emission__texture()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::texture__extra__AttributeData ColladaParserAutoGen::texture__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__texture__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__texture__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
texture__extra__AttributeData* attributeData = newData<texture__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TEXTURE__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__texture__extra()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__reflective()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::reflective__color__AttributeData ColladaParserAutoGen::reflective__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__reflective__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__reflective__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflective__color__AttributeData* attributeData = newData<reflective__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__reflective__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::reflective__param__AttributeData ColladaParserAutoGen::reflective__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__reflective__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__reflective__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflective__param__AttributeData* attributeData = newData<reflective__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__reflective__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::reflective__texture__AttributeData ColladaParserAutoGen::reflective__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__reflective__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__reflective__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflective__texture__AttributeData* attributeData = newData<reflective__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVE__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__reflective__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::reflectivity__float__AttributeData ColladaParserAutoGen::reflectivity__float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__reflectivity__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__reflectivity__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflectivity__float__AttributeData* attributeData = newData<reflectivity__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVITY__FLOAT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__reflectivity__float()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::reflectivity__param__AttributeData ColladaParserAutoGen::reflectivity__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__reflectivity__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__reflectivity__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
reflectivity__param__AttributeData* attributeData = newData<reflectivity__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_REFLECTIVITY__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__reflectivity__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::constant__transparent__AttributeData ColladaParserAutoGen::constant__transparent__AttributeData::DEFAULT = {(const ParserChar *)"A_ONE"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
constant__transparent__AttributeData* attributeData = newData<constant__transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_CONSTANT__TRANSPARENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__transparent()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::transparent__color__AttributeData ColladaParserAutoGen::transparent__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__transparent__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__transparent__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__color__AttributeData* attributeData = newData<transparent__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__transparent__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::transparent__param__AttributeData ColladaParserAutoGen::transparent__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__transparent__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__transparent__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__param__AttributeData* attributeData = newData<transparent__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__transparent__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::transparent__texture__AttributeData ColladaParserAutoGen::transparent__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__transparent__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__transparent__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparent__texture__AttributeData* attributeData = newData<transparent__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENT__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__transparent__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__transparency()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::transparency__float__AttributeData ColladaParserAutoGen::transparency__float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__transparency__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__transparency__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparency__float__AttributeData* attributeData = newData<transparency__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENCY__FLOAT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__transparency__float()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::transparency__param__AttributeData ColladaParserAutoGen::transparency__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__transparency__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__transparency__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
transparency__param__AttributeData* attributeData = newData<transparency__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSPARENCY__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__transparency__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__constant__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__constant__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__constant__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::index_of_refraction__float__AttributeData ColladaParserAutoGen::index_of_refraction__float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__index_of_refraction__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__index_of_refraction__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
index_of_refraction__float__AttributeData* attributeData = newData<index_of_refraction__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INDEX_OF_REFRACTION__FLOAT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__index_of_refraction__float()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::index_of_refraction__param__AttributeData ColladaParserAutoGen::index_of_refraction__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__index_of_refraction__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__index_of_refraction__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
index_of_refraction__param__AttributeData* attributeData = newData<index_of_refraction__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INDEX_OF_REFRACTION__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__index_of_refraction__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__ambient()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ambient__param__AttributeData ColladaParserAutoGen::ambient__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ambient__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ambient__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ambient__param__AttributeData* attributeData = newData<ambient__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ambient__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::ambient__texture__AttributeData ColladaParserAutoGen::ambient__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__ambient__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__ambient__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
ambient__texture__AttributeData* attributeData = newData<ambient__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_AMBIENT__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__ambient__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::diffuse__color__AttributeData ColladaParserAutoGen::diffuse__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__diffuse__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__diffuse__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
diffuse__color__AttributeData* attributeData = newData<diffuse__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__diffuse__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::diffuse__param__AttributeData ColladaParserAutoGen::diffuse__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__diffuse__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__diffuse__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
diffuse__param__AttributeData* attributeData = newData<diffuse__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__diffuse__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::diffuse__texture__AttributeData ColladaParserAutoGen::diffuse__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__diffuse__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__diffuse__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
diffuse__texture__AttributeData* attributeData = newData<diffuse__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_DIFFUSE__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__diffuse__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::lambert__transparent__AttributeData ColladaParserAutoGen::lambert__transparent__AttributeData::DEFAULT = {(const ParserChar *)"A_ONE"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
lambert__transparent__AttributeData* attributeData = newData<lambert__transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_LAMBERT__TRANSPARENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__lambert__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__lambert__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__lambert__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__specular()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::specular__color__AttributeData ColladaParserAutoGen::specular__color__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__specular__color( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__specular__color( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
specular__color__AttributeData* attributeData = newData<specular__color__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__COLOR , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__specular__color()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::specular__param__AttributeData ColladaParserAutoGen::specular__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__specular__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__specular__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
specular__param__AttributeData* attributeData = newData<specular__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__specular__param()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::specular__texture__AttributeData ColladaParserAutoGen::specular__texture__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__specular__texture( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__specular__texture( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
specular__texture__AttributeData* attributeData = newData<specular__texture__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_TEXTURE:
    {

attributeData->texture = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TEXCOORD:
    {

attributeData->texcoord = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SPECULAR__TEXTURE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__specular__texture()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__shininess()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shininess__float__AttributeData ColladaParserAutoGen::shininess__float__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shininess__float( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shininess__float( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shininess__float__AttributeData* attributeData = newData<shininess__float__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHININESS__FLOAT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shininess__float()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::shininess__param__AttributeData ColladaParserAutoGen::shininess__param__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__shininess__param( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__shininess__param( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
shininess__param__AttributeData* attributeData = newData<shininess__param__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_REF:
    {

attributeData->ref = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_SHININESS__PARAM , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__shininess__param()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::phong__transparent__AttributeData ColladaParserAutoGen::phong__transparent__AttributeData::DEFAULT = {(const ParserChar *)"A_ONE"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
phong__transparent__AttributeData* attributeData = newData<phong__transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PHONG__TRANSPARENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__phong__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__phong__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__phong__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__emission( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__emission( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__emission()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__ambient( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__ambient( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__ambient()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__diffuse( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__diffuse( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__diffuse()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__specular( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__specular( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__specular()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__shininess( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__shininess( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__shininess()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__reflective( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__reflective( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__reflective()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__reflectivity( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__reflectivity( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__reflectivity()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::blinn__transparent__AttributeData ColladaParserAutoGen::blinn__transparent__AttributeData::DEFAULT = {(const ParserChar *)"A_ONE"};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__transparent( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__transparent( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
blinn__transparent__AttributeData* attributeData = newData<blinn__transparent__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_OPAQUE:
    {



    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_BLINN__TRANSPARENT , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__transparent()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__transparency( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__transparency( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__transparency()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__blinn__index_of_refraction( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__blinn__index_of_refraction( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__blinn__index_of_refraction()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::profile_COMMON__extra__AttributeData ColladaParserAutoGen::profile_COMMON__extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__profile_COMMON__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__profile_COMMON__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
profile_COMMON__extra__AttributeData* attributeData = newData<profile_COMMON__extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_PROFILE_COMMON__EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__profile_COMMON__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::triangles__AttributeData ColladaParserAutoGen::triangles__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__triangles( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__triangles( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
triangles__AttributeData* attributeData = newData<triangles__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRIANGLES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__triangles()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::rotate__AttributeData ColladaParserAutoGen::rotate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__rotate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__rotate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
rotate__AttributeData* attributeData = newData<rotate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_ROTATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__rotate()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__bind_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__bind_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__bind_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_force_field__AttributeData ColladaParserAutoGen::instance_force_field__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_force_field( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_force_field( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_force_field__AttributeData* attributeData = newData<instance_force_field__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_FORCE_FIELD , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_force_field()
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__asset( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__asset( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__asset()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polygons__AttributeData ColladaParserAutoGen::polygons__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polygons( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polygons( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polygons__AttributeData* attributeData = newData<polygons__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYGONS , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polygons()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::vertices__AttributeData ColladaParserAutoGen::vertices__AttributeData::DEFAULT = {0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__vertices( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__vertices( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
vertices__AttributeData* attributeData = newData<vertices__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_VERTICES , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__vertices()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::extra__AttributeData ColladaParserAutoGen::extra__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__extra( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__extra( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
extra__AttributeData* attributeData = newData<extra__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_ID:
    {

attributeData->id = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_TYPE:
    {

attributeData->type = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_EXTRA , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__extra()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::instance_physics_material__AttributeData ColladaParserAutoGen::instance_physics_material__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__instance_physics_material( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__instance_physics_material( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
instance_physics_material__AttributeData* attributeData = newData<instance_physics_material__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_URL:
    {

attributeData->url = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_INSTANCE_PHYSICS_MATERIAL , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__instance_physics_material()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::polylist__AttributeData ColladaParserAutoGen::polylist__AttributeData::DEFAULT = {0, 0, 0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__polylist( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__polylist( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
polylist__AttributeData* attributeData = newData<polylist__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_NAME:
    {

attributeData->name = attributeValue;

    break;
    }
    case HASH_ATTRIBUTE_COUNT:
    {



    break;
    }
    case HASH_ATTRIBUTE_MATERIAL:
    {

attributeData->material = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_POLYLIST , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__polylist()
{
    return true;
}

//---------------------------------------------------------------------
const ColladaParserAutoGen::translate__AttributeData ColladaParserAutoGen::translate__AttributeData::DEFAULT = {0};

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_data__translate( const ParserChar* text, size_t textLength )
{
    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateBegin__translate( const ParserAttributes& attributes, void ** attributeDataPtr, void ** validationDataPtr )
{
translate__AttributeData* attributeData = newData<translate__AttributeData>(attributeDataPtr);

const ParserChar** attributeArray = attributes.attributes;
while (true)
{
    const ParserChar * attribute = *attributeArray;
    if ( !attribute ) 
        break;
    StringHash hash = GeneratedSaxParser::Utils::calculateStringHash(attribute);
    attributeArray++;
    if ( !attributeArray )
        return false;
    const ParserChar* attributeValue = *attributeArray;
    attributeArray++;


    switch ( hash )
    {
    case HASH_ATTRIBUTE_SID:
    {

attributeData->sid = attributeValue;

    break;
    }
    default:
    {
        if ( handleError(GeneratedSaxParser::ParserError::SEVERITY_ERROR,GeneratedSaxParser::ParserError::ERROR_ATTRIBUTE_PARSING_FAILED,HASH_ELEMENT_TRANSLATE , 0, attributeValue))
            {return false;}
    }
    }
}

    return true;
}

//---------------------------------------------------------------------
bool ColladaParserAutoGen::_validateEnd__translate()
{
    return true;
}




}
